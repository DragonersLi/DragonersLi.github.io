<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP操作MongoDB进行数据库集合文档复制至本地服务！]]></title>
    <url>%2F2017%2F06%2F16%2FPHP%E6%93%8D%E4%BD%9CMongodb%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E6%96%87%E6%A1%A3%E5%A4%8D%E5%88%B6%E8%87%B3%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%EF%BC%81%2F</url>
    <content type="text"><![CDATA[####需求：把服务器mongo数据库，集合文档copy到本地 #####查手册：https://secure.php.net/manual/zh/book.mongo.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php//基于Thinkphp框架的mongodb 数据库，集合，文档复制方法 public function mongoCopy() &#123; set_time_limit(0); //解除php时间30秒限制 $con1 = new Mongo(&quot;mongodb://192.168.1.243:7788&quot;); // 连接到243 $con2 = new Mongo(&quot;mongodb://127.0.0.1:27017&quot;); // 连接到本地 $dbs = $this-&gt;getDBs($con1); //获取服务器端所有表 foreach($dbs as $k1=&gt;$v1)&#123; $c = $this-&gt;getCollections($con1,$v1[&apos;name&apos;]); //获取单个集合的所有文档 foreach($c as $k2=&gt;$v2)&#123; $res = $this-&gt;setCollection($con1,$v1[&apos;name&apos;],$v2,$con2); //把服务端mongo数据库，集合文档复制到本地 &#125; &#125;&#125; //获取所有数据库 //传递mongo配置 //返回所有数据库 private function getDBs($con)&#123; $db = $con-&gt;listDBs(); return $db[&apos;databases&apos;]; &#125; //获取所有集合方法 //传递mongo配置，单个数据库 //返回所有此数据库下所有集合 private function getCollections($con,$db)&#123; $collections = $con-&gt;$db-&gt;getCollectionNames();//循环获取单条数据库下的所有集合 return $collections; &#125; //获取所有文档插入$con2方法 //copy数据库和集合文档 //传递mongo配置，单个数据库，单个集合，复制到的第二个mongo配置 //逐条进行读取插入，成功返回success，失败返回failed private function setCollection($con1,$db,$collection,$con2)&#123;//集合//使用游标获取所有文档 $cursor = $con1-&gt;$db-&gt;selectCollection($collection)-&gt;find(); foreach ( $cursor as $k =&gt; $v )&#123; $result = $con2-&gt;$db-&gt;$collection-&gt;insert($v); #简单插入 echo $result ? &apos;success&apos; : &apos;failed&apos;;echo &quot;&lt;br&gt;&quot;; &#125; &#125;?&gt; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2017/06/16/PHP操作Mongodb进行数据库集合文档复制至本地服务！/]]></content>
      <categories>
        <category>MongoDB笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPHINX学习笔记！]]></title>
    <url>%2F2017%2F06%2F16%2FSPHINX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一：什么是sphinxsphinx是一个基于SQL的全文检索引擎，可以结合mysql，postgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能。使得应用程序更容易实现专业化的全文检索。sphinx特别为一些脚本语言设计搜索API接口，如php，python，perl，ruby等。同时为mysql也专业设计了一个存储引擎插件。（扩展：还有Lucence） 二：什么时候使用？在MYSQL中当对一个文本类型的字段进行LIKE 并以%开头的查询时，会进行全表扫描。比如 我们商品中有商品500万件。如果我们要搜索商品名称中带红色的，如果不且SPHINX肯定是这样写：原因一、全表扫描慢：SELECT * FROM php34_goods WHERE goods_name LIKE ‘%红色%’;这条SQL会进行全表扫描，所以性能非常慢，查询速度非常慢。原因二、MYSQL没有中文分词，而一般对短语搜索时必须分词才能搜索sphinx就可以解决以上两个问题：总结：当一个功能需要对表中text,varchar等文本类型的字段进行LIKE 查询时，如（根据歌词搜索歌曲这个功能）MYSQL是全表扫描非常慢，需要使用SPHINX： 我们商城中的根据关键字搜索的功能需要使用SPHINX优化。1.解决性能问题 2.解决中文分词的问题 三、怎么用sphinx有两种使用方式：用法一原始用法：SPHINX和mysql是两个独立的服务器 流程： PHP要先把要搜索的短语发给SPHINX服务器，SPHINX返回的是记录的ID PHP 再使用sphinx返回的ID查询数据库用法一、：shpinxse:把SPHINX集成到MYSQL里去（没有单独的shpinx服务器） PHP只需要写一个SQL语句即可，不用很管SPHINX，MYSQL会自己连接查询sphinx。如果要使用这种 需要在LINUX下重新编译MYSQL，把SPHINX当成插件编译到MYSQL中去。 实际操作： 先下载sphinx的包， coreseek可以理解成加了中文语言包的sphinx(sphinx默认支持俄语和英语，不支持中文) 下载包之后几个重要文件说明： 实际应用：先复制MYSQL的配置文件模板到根目录下并改名为sphinx.conf 配置文件配置好之后就可以使用这个文件生成索引了： 安装sphinx服务器 打开服务窗口启用sphinx: 写PHP代码操作SPHINXA. 先复制coreseek包中的sphinxapi.php文件到项目中： B 写PHP代码： sphinx自动更新在使用SPHINX生成索引时只会为当前数据库中的数据生成索引，生成索引之后如果在数据库中又添加了新的数据那么在SPHINX是无法搜索到新的数据的，需要把新的数据也生成索引并添加到SPHINX中去才行。如果每次插入新的数据之后都要手动再重建索引太麻烦了，所以我们一般要配置SPHINX每隔一段时间自动把数据库中最新插入的数据重新新的索引文件，并把这个新的索引文件合并到主索引文件上。 实际操作： 每次生成索引文件之后，要把最后一条记录的ID保存下来，下次ID大于这个ID就是新的数据a. 建一张表用来保存这个ID b. 配置SPHINX让每次生成索引之后能够直接 把最大的ID更新进来 定期为新添加的数据生成索引a. 修改sphinx定义一个新的数据源（新插入的还没有创建索引的数据）b. 再添加一个index索引（每个数据源对应一个index） c. 写一个bat脚本，让这个定期用新的数据源生成索引文件，并把这个索引文件合并到主索引（第一次生成的索引文件）文件上。 d. 配置windows系统让系统定期执行这个bat.脚本即可： 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2017/06/16/SPHINX学习笔记！/]]></content>
      <categories>
        <category>SPHINX笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SPHINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下MongoDB介绍及下载与安装!]]></title>
    <url>%2F2017%2F06%2F16%2FWindows%E4%B8%8BMongoDB%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85!%2F</url>
    <content type="text"><![CDATA[引言 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bjson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它的特点是高性能、易部署、易使用，存储数据非常方便。主要功能特性有：面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。 文件存储格式为BSON（一种JSON的扩展） 可通过网络访问 所谓“面向集合”（Collenction-Orented），意思是数据被分组存储在数据集中，被称为一个集合（Collenction)。每个 集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定 义任何模式（schema)。模式自由（schema-free)，意味着对于存储在mongodb数据库中的文件，我们不需要知道它的任何结构定义。如果需要的话，你完全可以把不同结构的文件存储在同一个数据库里。存储在集合中的文档，被存储为键-值对的形式。键用于唯一标识一个文档，为字符串类型，而值则可以是各中复杂的文件类型。我们称这种存储形式为BSON（Binary Serialized dOcument Format）。MongoDB服务端可运行在Linux、Windows或OS X平台，支持32位和64位应用，默认端口为27017。推荐运行在64位平台，因为MongoDB在32位模式运行时支持的最大文件尺寸为2GB。MongoDB把数据存储在文件中（默认路径为：/data/db），为提高效率使用内存映射文件进行管理。以上为随便摘的，其实就是非传统的非关系数据库，现在归到文档型数据库分类之中，注意32位操作系统支持的最大文件为2GB，所以做大文件海量储存的朋友要选择64位的系统安装。开始我们的下载安装之路吧。 MongoDB 是介于关系型数据库和非关系型数据库之间的一种NoSQL数据库，用C++编写，是一款集敏捷性、可伸缩性、扩展性于一身的高性能的面向文档的通用数据库。 MongoDB 具有以下几个特征： a）、灵活的文档数据模型 可以非常容易的存储不同结构的的数据，并且还能动态的修改这些数据的源结构模式 b）、可伸缩可扩展性 从单个服务器到数千个节点，MongoDB可以很轻松的进行水平扩展，部署多个数据中心 c）、二级索引 包括在完全一致的任何字段上的索引、地理空间、文本搜索以及TTL索引，都能进行快速、细粒度的访问到数据 d）、丰富的查询语言 MongoDB的查询语言提供了多样化的字段级别的操作符、数据类型以及即时更新。几乎提供了所有编程语言的驱动来更直观的使用它 e）、健壮的操作工具 MongoDB的管理服务和运维管理工具可以使你很轻松的部署，监控、备份和规划它 MongoDB 以下几个使用场合： a）、需要写入大量的数据，但是这些这些数据的价值并不是太高，比如：日志 b）、数据增长量较大，而且数据结构有时候还不一致 c）、未来数据会很大 MongoDB的官网是：http://www.mongodb.org/MongoDB最新版本下载在官网的DownLoad菜单下：http://www.mongodb.org/downloadsMongoDB For .net 驱动开发包位于官网的Driver菜单下（含其它语言开发链接）：https://github.com/mongodb/mongo-csharp-driver/downloads 下载安装完成后接着在目录下新建:存放数据文件夹：D:\workplace\mongodb\db\存放日志文件夹：D:\workplace\mongodb\log\存放日志文件：D:\workplace\mongodb\log\mongodb.log存放配置文件：D:\workplace\mongodb\mongodb.conf mongodb.conf文件，内容如下：123456dbpath=D:\workplace\mongodb\db #数据库路径logpath=D:\workplace\mongodb\log\mongodb.log #日志输出文件路径logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件journal=true #启用日志文件，默认启用quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falseport=27017 #端口号 默认为27017 开启mongodb服务，以管理员身份启动dos命令窗口，启动mongodb服务之后，可在服务中看到mongodb服务，下次直接执行bin目录下的mongo.exe客户端就可以进行操作了。 1234567891011121314151617D:\workplace\mongodb\bin&gt;mongod.exe --config D:\workplace\mongodb\mongodb.conf --install --serviceName &quot;mongodb&quot; D:\workplace\mongodb\bin&gt;net start mongodb #或者D:\workplace\mongodb\bin&gt;sc start mongodb #打开windows服务查看D:\workplace\mongodb\bin&gt;services.msc ``` 打开：http://localhost:27017/显示如下：It looks like you are trying to access MongoDB over HTTP on the native driver port. 表示OK了！如果php 操作 mongodb报错：Fatal error: Class &apos;Mongo&apos; not found解决办法：http://windows.php.net/downloads/pecl/releases/下载mongodb和mongo的php扩展都下载放到php的ext目录；推荐两款图形化管理软件：MongoVUE和Robomongo demo:插入数据：db.User.insert({“id”:1,”username”:”admin”,”age”:18});查询数据：db.User.find();查询具体数据：db.User.find({“usrname”:”test”}); ``` 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2017/06/16/Windows下MongoDB介绍及下载与安装!/]]></content>
      <categories>
        <category>MongoDB笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Apache-80端口占用问题！]]></title>
    <url>%2F2016%2F10%2F16%2F%E8%A7%A3%E5%86%B3Apache-80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%81%2F</url>
    <content type="text"><![CDATA[突然有一天Apache无法启动，查看是否80端口被占用， win+r 运行cmd，输入netstat -ano可以看到80端口被PID9728占用，于是快捷键：ctr+alt+del 打开任务管理器-进程-查看，选择列，勾选PID可以看到pid 9728 的被 nginx 占用！结束进程树，重试！~ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/解决Apache-80端口占用问题！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下PHP服务nginx不能使用file_get_contents-curl-fopen的原因！]]></title>
    <url>%2F2016%2F10%2F16%2FWindows%E4%B8%8BPHP%E6%9C%8D%E5%8A%A1Nginx%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8file_get_contents-curl-fopen%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[#转： ####今天研究一个项目用到file_get_contents获取本地虚拟主机：http://blog.cc/index.php 文件结果等了半天超时也没获取到信息，试了http://localhost/index.php 也不行。本地电脑php环境为：nginx+php+mysql；于是找到这篇文章做个笔记，记录下！ 这两天一直在搞windows下nginx+fastcgi的file_get_contents请求。我想，很多同学都遇到当file_get_contents请求外网的http/https的php文件时毫无压力，比如echo file_get_contents(‘http://www.baidu.com’) ，它会显示百度的页面。但当你请求localhost/127.0.0.1本地网络的php服务时却一直是timeout，无论你将请求时间和脚本运行时间多长都无法返回数据，如file_get_contents(‘http://localhost/phpinfo.php’) 。然而当你尝试请求html这样的静态文件时却完全没有问题。是什么原因呢？！ 首先，我们知道file_get_contents/curl/fopen打开一个基于tcp/ip的http请求时，请求数据发送到nginx，而nginx则委托给php-cgi(fastcgi)处理php文件，一般情况fastcgi处理完一个php请求后会马上释放结束信号，等待下一个处理请求（当然也有程序假死，一直占用资源的情况）。打开nginx.conf，我们看到下面这一行： 123456location ~ .php &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME d:/www/htdocs$fastcgi_script_name; include fastcgi_params;&#125; 上面已经清楚地看到，所有使用php结尾的文件都经过fastcgi处理，而在php.ini的配置文件中也有一句：1cgi.force_redirect = 1 表明，所有php程序安全地强制转向交给cgi处理。 但在windows中，本地127.0.0.1:9000怎样与php-cgi联系的呢？！答案是增加一个php-cgi进程，用它来监听127.0.0.1:9000。通过控制器命令：1RunHiddenConsole.exe D:/www/php/php-cgi.exe -b 127.0.0.1:9000 -c C:/WINDOWS/php.ini 我们就可以在启动windows时，开启一个php-cgi.exe进程监听来自127.0.0.1:9000 的请求。在dos命令下打开netstat –a就可以看到本地计算机下的9000端口处于listening状态（也就是空置，如果没有发送任何请求的话）。 好了，该说说在php中使用file_get_contents()、curl()、fopen()函数访问localhost时为什么不能返回结果。我们再来试验在index.php中加入file_get_contents(‘http://127.0.0.1/phpinfo.php’) 语句向phpinfo.php发送一个请求，这时浏览器中的状态指示一直在打转，表示它一直在工作中。打开Dos中的netstat命令，可以看到本地的9000端口的状态为：ESTABLISHED，表示该进程在联机处理中。实际上，这里我们已经同时向nginx发送了两个基于http的php请求，一个是解析index.php，而另一个是phpinfo.php，这样矛盾就出来了，因为我们的windows系统只加载了一个http进程，因此，它无法同时处理两个php请求，它只能先处理第一个请求（index.php），而index.php却又在等待phpinfo.php处理结果，phpinfo.php没人帮它处理请求，因为它一直在等待index.php释放结束信号，因此，造成了程序的阻塞状态，陷入了死循环。所以我们就看到了浏览器的状态指示一直在打转。Curl()与fopen函数的原因也相同。 找到了原因，我们也就有了解决办法。 一是，向系统增加一个http请求，当一个php-cig内要加载另一个请求时，它能够分配其它http处理额外的php请求。这时需给另一个http sever分配不同的端口，比如8080。nginx的案例如下：12345678910111213141516171819http &#123; server &#123; listen 80; server_name 127.0.0.1; location / &#123; index index.php; root /web/www/htdocs; &#125; &#125; server &#123; listen 8080; server_name 127.0.0.1; location / &#123; index index.html; root /web/www/htdocs; &#125; &#125; include /opt/nginx/conf/vhosts/php.conf; &#125; 这样，端口80与8080可以分别处理不同的程序，比如： test.php1echo file_get_contents(&apos;http://localhost:8080/phpinfo.php&apos;); 当然，在*unix下有更多选择，比如fork。 另外提醒下，网上有人说，通过去掉地址中的http://协议标记，而使用相对地址就规避函数的检查，实际情况是不是这样呢？！当在index.php中使用file_get_contents(‘phpinfo.php’); 时，我们可以看到函数输出了phpinfo.php的源代码，相当于file_get_contents(‘file:\c:wwwphpinfo.php’); ，它实际上只是读取你的文本内容，因为file_get_contents()函数首先是处理file协议的，而curl则直接报错无法解析。因此这些人纯粹是不学无术的骗子。 还有人提出修改hosts文件，增加localhost www.xxx.com影射关系，函数通过www.xxx.com访问本地php，这其实也是不治本的偏方，因为这只是方便计算机的dns解析，最终www.xxx.com交给127.0.0.1，而后者交给唯一http，还是阻塞。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/Windows下PHP服务Nginx不能使用file_get_contents-curl-fopen的原因！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nignx根据端口号配置虚拟主机，并重启加载！]]></title>
    <url>%2F2016%2F10%2F16%2FNginx%E6%A0%B9%E6%8D%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%EF%BC%8C%E5%B9%B6%E9%87%8D%E5%90%AF%E5%8A%A0%E8%BD%BD%EF%BC%81%2F</url>
    <content type="text"><![CDATA[###配置完重启！1234cd /usr/local/nginx/sbin #进入nginx./nginx -s reload #重启加载配置 浏览器访问ok！ ###配置文件内容! 12345678910111213141516171819202122232425262728293031323334353637383940server &#123; listen 83; #端口号 server_name quda.septwolves.cn; #主机名 index index.php index.html index.htm; root /data/webserver/qpl/ymall; #主机所在文件夹 error_page 404 /404.html; # 错误页面 location / &#123; if (!-e $request_filename)&#123; rewrite ^/(.*)$ /index.php/$1 last; &#125; &#125; location ~ \.php($|/) &#123; set $script $uri; set $path_info &quot;&quot;; if ($uri ~ &quot;^(.+?\.php)(/.+)$&quot;) &#123; set $script $1; set $path_info $2; &#125; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$script; fastcgi_param SCRIPT_NAME $script; fastcgi_param PATH_INFO $path_info; &#125; location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 1d; &#125; location ~ .*\.(js|css)?$ &#123; expires 12h; &#125; location /ngx_status &#123; stub_status on; access_log off; #allow 127.0.0.1; #deny all; &#125; access_log /var/log/nginx/access_ymall.log; #日志文件&#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/Nginx根据端口号配置虚拟主机，并重启加载！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache本地配置多域名(wampserver本地配置多域名)]]></title>
    <url>%2F2016%2F10%2F16%2FApache%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E5%9F%9F%E5%90%8D(wampserver%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E5%9F%9F%E5%90%8D)%2F</url>
    <content type="text"><![CDATA[我们在本地开发时，一般是在浏览器输入 http://localhost/项目文件夹名 来测试网页文件，你有没有想过在本地在浏览器输入你自己设定的一个域名进入项目文件夹中去，本地配置多域名可以测试二级域名以及其他与域名相关的问题。 比如我想配置一个主域名www.test.com和二级域名img.test.com(其实二级域名与配置另外一个独立域名的原理是一样的) 第一步：打开本地系统安装目录，比如我安装的是windows7，安装在c盘，进入目录C:\Windows\System32\drivers\etc找到一个叫hosts的文件，用记事本打开：在文件结尾加入以下代码：127.0.0.1 www.lz13.com127.0.0.1 www.vivijk.com127.0.0.1 localhost输入完成后保存。hosts文件修改不能保存问题：开始-&gt;附件-&gt;记事本以管理员身份运行，打开编辑保存！第二步：打开apache的安装位置，如我用的是wampserver，安装目录为：D:\wamp\bin\apache\Apache2.2.21打开一个叫conf的文件夹，它是apache的配置文件夹打开一个叫httpd.conf文件搜索一下Directory，找到一个如：的一行，看到把代码：Order deny,allow deny from all Allow from 127.0.0.1改成： Order allow,deny Allow from all 第三步：在刚才这个httpd.conf文件中，搜索Include conf/extra/httpd-vhosts.conf去掉它前面的#，然后保存这个文件第四步：打开conf这个文件夹下一个子目录：extra，找到一个httpd-vhosts.conf这个文件，一般是最后一个文件，在文件最后添加上： DocumentRoot “D:/workspace/www/lz13” ServerName www.lz13.com DocumentRoot “D:/workspace/www/vivijk” ServerName www.vivijk.com DocumentRoot “D:/workspace/www/“ ServerName localhost 这个根据目录根据自己的apache文件目录来自行调整，我的apache工作目录为D:/wamp/www/,改成自己的apache工作目录即可。 最后一步，重启apache，在浏览器中输入：www.test.com会出现test文件夹的默认的内容 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/Apache本地配置多域名(wampserver本地配置多域名)/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Apache</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN连接之后无法上网问题解决方法！]]></title>
    <url>%2F2016%2F10%2F16%2FVPN%E8%BF%9E%E6%8E%A5%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%81%2F</url>
    <content type="text"><![CDATA[#####鼠标右键【VPN连接】 点击 【属性】找到 【网络】 选择【Internet协议版本4（tcp/Ipv4）】 双击 #####点击 【高级】把【在远程网络上使用默认网关】前面的勾去掉。一路确定就OK啦。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/VPN连接之后无法上网问题解决方法！/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局域网无法访问Vmware虚拟机WEB服务器解决办法！]]></title>
    <url>%2F2016%2F10%2F16%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEVmware%E8%99%9A%E6%8B%9F%E6%9C%BAWEB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%81%2F</url>
    <content type="text"><![CDATA[具体情况如下 ： 环境：虚拟机服务器是centos，apache+php+mysql环境，但是局域网无法访问 1.本机能ping通虚拟机 2.虚拟机也能ping通本机 3.虚拟机能访问自己的web 4.本机无法访问虚拟己的web 后来发现是防火墙将80端口屏蔽了的缘故。 检查是不是服务器的80端口被防火墙堵了，可以通过命令： telnet {服务器ip}80 来测试。 解决方法如下： /sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT 然后保存： /etc/rc.d/init.d/iptables save 重启防火墙 /etc/init.d/iptables restartCentOS防火墙的关闭，关闭其服务即可： 查看CentOS防火墙信息： /etc/init.d/iptables status 关闭CentOS防火墙服务： /etc/init.d/iptables stop 永久关闭防火墙： chkconfig –level 35 iptables off 最后，打开主机浏览器，输入虚拟机地方，就可以访问虚拟机的WEB服务器了！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/局域网无法访问Vmware虚拟机WEB服务器解决办法！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wamp的安装与配置图解]]></title>
    <url>%2F2016%2F10%2F16%2FWamp%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%9B%BE%E8%A7%A3%EF%BC%81%2F</url>
    <content type="text"><![CDATA[先准备好软件：apache官方下载地址：apache_2.0.55-win32-x86-no_ssl.msi，更多版本在这里；php官方下载地址：php-5.0.5-Win32.zip，更多镜像下载地址，更多版本下载；mysql官方下载地址。 先准备好软件： Apache官方下载地址：apache_2.0.55-win32-x86-no_ssl.msi，更多版本在这里； php官方下载地址：php-5.0.5-Win32.zip，更多镜像下载地址，更多版本下载； mysql官方下载地址：mysql-4.1.14-win32.zip，更多镜像下载地址，更多版本下载。 一、安装Apache，配置成功一个普通网站服务器 运行下载好的“apache_2.0.55-win32-x86-no_ssl.msi”，出现如下界面： 出现Apache HTTP Server 2.0.55的安装向导界面，点“Next”继续 确认同意软件安装使用许可条例，选择“I accept the terms in the license agreement”，点“Next”继续 将Apache安装到Windows上的使用须知，请阅读完毕后，按“Next”继续 设置系统信息，在Network Domain下填入您的域名（比如：goodwaiter.com），在Server Name下填入您的服务器名称（比如：www.goodwaiter.com，也就是主机名加上域名），在Administrator’s Email Address下填入系统管理员的联系电子邮件地址（比如：yinpeng@xinhuanet.com），上述三条信息仅供参考，其中联系电子邮件地址会在当系统故障时提供给访问者，三条信息均可任意填写，无效的也行。下面有两个选择，图片上选择的是为系统所有用户安装，使用默认的80端口，并作为系统服务自动启动；另外一个是仅为当前用户安装，使用端口8080，手动启动。一般选择如图所示。按“Next”继续。] 选择安装类型，Typical为默认安装，Custom为用户自定义安装，我们这里选择Custom，有更多可选项。按“Next”继续 出现选择安装选项界面，如图所示，左键点选“Apache HTTP Server 2.0.55”，选择“This feature, and all subfeatures, will be installed on local hard drive.”，即“此部分，及下属子部分内容，全部安装在本地硬盘上”。点选“Change…”，手动指定安装目录。 我这里选择安装在“D:\”，各位自行选取了，一般建议不要安装在操作系统所在盘，免得操作系统坏了之后，还原操作把Apache配置文件也清除了。选“OK”继续。 返回刚才的界面，选“Next”继续。 确认安装选项无误，如果您认为要再检查一遍，可以点“Back”一步步返回检查。点“Install”开始按前面设定的安装选项安装。 正在安装界面，请耐心等待，直到出现下面的画面。 安装向导成功完成，这时右下角状态栏应该出现了下面的这个绿色图标，表示Apache服务已经开始运行，按“Finish”结束Apache的软件安装 我们来熟悉一下这个图标，很方便的，在图标上左键单击，出现如下界面，有“Start（启动）”、“Stop（停止）”、“Restart（重启动）”三个选项，可以很方便的对安装的Apache服务器进行上述操作。 好了现在我们来测试一下按默认配置运行的网站界面，在IE地址栏打“http://127.0.0.1”，点“转到”，就可以看到如下页面，表示Apache服务器已安装成功。 现在开始配置Apache服务器，使它更好的替我们服务，事实上，如果不配置，你的安装目录下的Apache2\htdocs文件夹就是网站的默认根目录，在里面放入文件就可以了。这里我们还是要配置一下，有什么问题或修改，配置始终是要会的，如图所示，“开始”、“所有程序”、“Apache HTTP Server 2.0.55”、“Configure Apache Server”、“Edit the Apache httpd conf Configuration file”，点击打开。 (图片较大，请拉动滚动条观看) XP的记事本有了些小变化，很实用的一个功能就是可以看到文件内容的行、列位置，按下图所示，点“查看”，勾选“状态栏”，界面右下角就多了个标记，“Ln 78, Col 10”就表示“行 78，列 10”，这样可以迅速的在文件中定位，方便解说。当然，你也可以通过“编辑”，“查找”输入关键字来快速定位。每次配置文件的改变，保存后，必须在 Apache服务器重启动后生效，可以用前面讲的小图标方便的控制服务器随时“重启动”。 现在正式开始配置Apache服务器，“Ln 228”，或者查找关键字“DocumentRoot”（也就是网站根目录），找到如下图所示地方，然后将””内的地址改成你的网站根目录，地址格式请照图上的写，主要是一般文件地址的“\”在Apache里要改成“/”。 “Ln 253”，同样，你也可以通过查找“ “Ln321”，DirectoryIndex（目录索引，也就是在仅指定目录的情况下，默认显示的文件名），可以添加很多，系统会根据从左至右的顺序来优先显示，以单个半角空格隔开，比如有些网站的首页是index.htm，就在光标那里加上“index.htm ”文件名是任意的，不一定非得“index.html”，比如“test.php”等，都可以。 这里有一个选择配置选项，以前可能要配置，现在好像修正过来了，不用配置了，就是强制所有输出文件的语言编码，html文件里有语言标记（，这个就是设定文档语言为gb2312）的也会强制转换。如果打开的网页出现乱码，请先检查网页内有没有上述 html语言标记，如果没有，添加上去就能正常显示了。把“# DefaultLanguage nl”前面的“# ”去掉，把“nl”改成你要强制输出的语言，中文是“zh-cn”，保存，关闭。 好了，简单的Apache配置就到此结束了，现在利用先前的小图标重启动，所有的配置就生效了，你的网站就成了一个网站服务器，如果你加载了防火墙，请打开80或8080端口，或者允许Apache程序访问网络，否则别人不能访问。如果你有公网IP（一般ADSL或电话拨号上网的都是），就可以邀请所有能上网的朋友访问使用http://你的IP地址（IP地址查询可访问http://www.goodwaiter.com，查询内容内即是）你的网站了；如果你没有公网IP，也可以把内网IP地址告诉局域网内的其它用户，让他们通过http://你的内网IP地址，访问你的网站。 首先来说明一下Apache目录下各个文件夹的作用： bin：存放Apache运行的的各个软件，包括一个名为ad.exe的服务器调试工具 conf：Apache的配置文件放在这个文件夹里面，我们要修改其中的httpd.conf文件 htdocs：默认的web主目录，我们可以在httpd.conf中修改网站根目录的路径 下面让我们来修改httpd.conf文件 httpd.conf文件是Apache工作的重要配置文件，在X:Apache GroupApache2conf里面，找到并用记事本打开。大家可以参照下面进行修改： ServerRoot “X:/Apache Group/Apache2” 这个是服务器的根路径，不用更改 MaxKeepAliveRequests 100 最大在线人数，根据你需要的人数和你服务器机器的配置来确定 Listen 80 Apache2监听端口，一般情况下不用改，也就是网站的http端口 DocumentRoot “C:/htroot” 这个是你放置网页文件的地方，编译后的PHP文件就放在这里，一定要确保这个文件夹存在,这个也就是是你的站点目录 同上，跟着上一步一起修改，确保文件夹的存在 DirectoryIndex index.htm index.php index.html 这个是服务器默认打开的主页文档类型，可以改成如上的，中间用空格格开 LanguagePriority zh-CN zh-TW en ca cs da de el eo es et fr he hr it ja ko ltz nl nn no pl pt pt-BR ru sv 语言优先级，把中文（zh-CN zh-TW）的部分剪切放到前面（也就是将原来文件中的相应部分改成如上的） 另外，如果想要禁止主页浏览，找到如下代码： Options Indexes FollowSymLinks 去掉其中的indexes即可，即改成： Options FollowSymLinks 第三步：PHP的挂载 还是在httpd.conf中搜索LoadModule找到相关章节 ，在后面添加如下内容 LoadModule php5_module “X:/PHP/php5Apache2.dll” AddType application/x-httpd-php .php 注意:其中X:PHP/PHP5Apache2.dll 中的X:/PHP/是你安装PHP的路径 重启Apache使修改生效 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/Wamp的安装与配置图解！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Apache</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache本地配置多域名！]]></title>
    <url>%2F2016%2F10%2F16%2FApache%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%A4%9A%E5%9F%9F%E5%90%8D%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1234LoadModule php5_module &quot;C:/workplace/workspace/PHP/php5apache2_2.dll&quot;addtype application/x-httpd-php .phpPHPIniDir &quot;C:/workplace/workspace/PHP/&quot; php.ini文件加载LoadFile &quot;C:/workplace/workspace/PHP/libmysql.dll&quot; //无法加载mysql apache本地配置多域名(wampserver本地配置多域名) 我们在本地开发时，一般是在浏览器输入 http://localhost/项目文件夹名 来测试网页文件，你有没有想过在本地在浏览器输入你自己设定的一个域名进入项目文件夹中去，本地配置多域名可以测试二级域名以及其他与域名相关的问题。 比如我想配置一个主域名www.test.com和二级域名img.test.com(其实二级域名与配置另外一个独立域名的原理是一样的) 第一步：打开本地系统安装目录，比如我安装的是windows7，安装在c盘，进入目录123456C:\Windows\System32\drivers\etc找到一个叫hosts的文件，用记事本打开：在文件结尾加入以下代码：127.0.0.1 www.lz13.com127.0.0.1 www.vivijk.com127.0.0.1 localhost 输入完成后保存。hosts文件修改不能保存问题：开始-&gt;附件-&gt;记事本以管理员身份运行，打开编辑保存！第二步：打开apache的安装位置，如我用的是wampserver，安装目录为：D:\wamp\bin\apache\Apache2.2.21打开一个叫conf的文件夹，它是apache的配置文件夹打开一个叫httpd.conf文件搜索一下Directory，找到一个如：的一行，看到把代码：改成：123456&lt;Directory /&gt; Options FollowSymLinks AllowOverride All Order deny,allow Deny from all&lt;/Directory&gt; 第三步：在刚才这个httpd.conf文件中，搜索Include conf/extra/httpd-vhosts.conf去掉它前面的#，然后保存这个文件第四步：打开conf这个文件夹下一个子目录：extra，找到一个httpd-vhosts.conf这个文件，一般是最后一个文件，在文件最后添加上： 1234567891011121314151617181920212223 &lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/workspace/www/lz13&quot; ServerName www.lz13.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/workspace/www/vivijk&quot; ServerName www.vivijk.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/workspace/www/&quot; ServerName localhost&lt;/VirtualHost&gt; 这个根据目录根据自己的apache文件目录来自行调整，我的apache工作目录为D:/wamp/www/,改成自己的apache工作目录即可 最后一步，重启apache，在浏览器中输入：www.test.com会出现test文件夹的默认的内容 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/Apache本地配置多域名！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Apache</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Windows环境下的PHP开发环境搭建]]></title>
    <url>%2F2016%2F10%2F16%2F%E5%9F%BA%E4%BA%8EWindows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84PHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一、准备工作 Apache2.2.11 下载地址：http://www.apache.org MySQL5.0 下载地址：http://www.mysql.com PHP5.2.9 下载地址：http://www.php.net 二、配置PHP 1、 将php-5.2.9-win32.zip解压缩到指定位置（如C:\ ），并将其改为php[如下图] 2、打开php文件夹，并将php.ini-dist更名为php.ini[如下图] 3、 双击php.ini，进入到php.ini的编辑状态 4、 查找extension=php_gd2.dll和extension=php_mysql.dll，并去掉其前面的分号(;)，保存设置，然后关闭文件[如下图] 5、 将php/ext文件夹内的php_gd2.dll和php_mysql.dll复制到c:\windows\system32 6、 将php文件夹下的libmysql.dll复制到c:\windows\system32 7.保存设置 三、安装MySQL 1.双击MySQL安装文件，出现如下图所示的界面 2.选择安装类型：Typical(典型安装)、Custom(自定义安装) 3.系统提示按照典型安装的配置如下图示所示 4.安装进度条 5.广告1 6.广告2 7.询问是否进行MySQL服务器的配置 8.MySQL服务器配置向导的欢迎界面 9.选择配置类型:Detailed(详细配置)、Standard(标准配置) 10.选择服务器类型：Developer Machine（开发测试类，MySQL占用很少资源）”、“Server Machine（服务器类型，MySQL占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，MySQL占用所有可用资源）” 11.选择MySQL数据库的用途：Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional） 对InnoDB Tablespace进行配置，就是为InnoDB 数据库文件选择一个存储空间，如果修改了，要记住位置，重装的时候要选择一样的地方，否则可能会造成数据库损坏。 选择您的网站的一般mysql访问量，同时连接的数目，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500个左右）”、“Manual Setting（手动设置，自己输一个数）” 是否启用TCP/IP连接，设定端口，如果不启用，就只能在自己的机器上访问MySQL数据库了 对MySQL默认数据库语言编码进行设置 选择是否将MySQL安装为windows服务，还可以指定Service Name（服务标识名称），是否将mysql的bin目录加入到Windows PATH 询问是否要修改默认root用户（超级管理）的密码（默认为空） 确认设置无误，如果有误，按“Back”返回检查。按“Execute”使设置生效。 四、安装Apache 1、双击Apache的安装文件，出现如下图所示的界面 2、确认同意软件安装使用许可条例，选择“I accept the terms in the license agreement”，点“Next”继续 3、将Apache安装到Windows上的使用须知，请阅读完毕后，按“Next”继续 4、设置系统信息，在Network Domain下填入您的域名（比如：wuhua.com），在Server Name下填入您的服务器名称（比如：www.wuhua.com，也就是主机名加上域名），在Administrator’s Email Address下填入系统管理员的联系电子邮件地址（比如：admin@wuhua.com），上述三条信息仅供参考，其中联系电子邮件地址会在当系统故障时提供给访问者，三条信息均可任意填写，无效的也行。下面有两个选择，图片上选择的是为系统所有用户安装，使用默认的80端口，并作为系统服务自动启动；另外一个是仅为当前用户安装，使用端口8080，手动启动。一般选择如图所示。按“Next”继续。 5、选择安装类型:typical(典型安装)、custom(自定义安装) 6、选择安装的组件及安装位置 7.指定安装位置为c:\apache，当然用户也可以选择自定义安装。如果选择自定安装的话，就省略了第6、7步 8.返回用户刚才设置的界面 9.确认设置，如果用户感觉有哪些设置还需要进行调整，可以单击”Back”按钮后，重新进行设置，如果感觉设置无误了，可以进接单击”Install”按钮进行安装！ 10、出现安装进度条 11、安装完毕 在正常情况下，在屏幕右下角出现了Apache的图标；而且这个图标的颜色应该是绿色的，表示Apache已经在正常运行了，但有时可能出现红色的情况，这表明Apache配置的过程中出现了错误，没有关系，我们一会再来调试这个错误！ 五、配置Apache 打开Apache的配置文件—httpd.conf，打开方法如下图 查找关键字“DocumentRoot”（也就是网站根目录），找到如下图所示地方，然后将””内的地址改成你的网站根目录，地址格式请照图上的写，主要是一般文件地址的“\”在Apache里要改成“/”。 查找Directory关键字，其设置的目录位置必须为DocumentRoot相同 查找DirectoryIndex关键字,也就是在仅指定目录的情况下，默认显示的文件名。可以添加很多，系统会根据从左至右的顺序来优先显示，以单个半角空格隔开，比如有些网站的首页是index.htm，就在光标那里加上“index.htm ”文件名是任意的，不一定非得“index.html”，比如“test.php”等，都可以。 查找LoadModule关键词，并添加以下语句 php5_module “c:\php\php5apache2_2.dll” PHPIniDir “c:\php” AddType application/x-httpd-php .php 指定apache服务器监听的端口号Listen 8080 保存设置并重启Apache 六、安装测试 在主目录下创建文本文件，然后双击进入文件的编辑状态，添加以下语句 &lt;?php phpinfo(); ?&gt; 保存文件后，将其重命名为index.php 启动浏览器，在地址栏中输入 http://127.0.0.1:8080如果用户看到以下界面，则证明Apache环境已经搭建好了，现在可以开始PHP之旅了… 搭建PHP 运行环境中可能出现的问题及处理方法 初学者在搭建PHP运行环境中经常可能遇到一些错误，这个时候可能就无所事从了！其实，错误是任何人都难免的，即使是程序高手！关键是我们如何来找到错误并且纠正它！当用户安装好Apache后，在开始菜单了就多了一项Apache HTTP Server 2.2的选项(这一项目的名称与用户安装的Apache版本是相关的)，我们可以通过”Configuare Apache Server”来测试我们刚刚做的配置！ 1、 错误一：DocumentRoot must be a directory 如果出现这个错误，则证明Apache所指定的主目录不存在或者主目录的名称输入有错误！应该打开httpd.conf文件后纠正DocumentRoot的配置。 2、 错误二：80端口被占用 如果出现这个错误则需要在Apache的配置文件中将listen 80的端口号修改为没有被占用的端口号即可。 周知端口(Well Known Ports) 周知端口是众所周知的端口号，范围从0到1023，其中80端口分配给WWW服务，21端口分配给FTP服务等。我们在IE的地址栏里输入一个网址的时候（例如：www.123.com）是不必指定端口号的，因为在默认情况下WWW服务的端口号是”80”。 网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏上指定端口号，方法是在地址后面加上冒号”:”（半角），再加上端口号。比如使用”8080”作为WWW服务的端口，则需要在地址栏里输入”www.123.com:8080”。 但是有些系统协议使用固定的端口号，它是不能被改变的，比如139端口专门用于NetBIOS与TCP/IP之间的通信，不能手动改变。 动态端口（Dynamic Ports） 动态端口的范围是从1024到65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。动态分配是指当一个系统进程或应用程序进程需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。当这个进程关闭时，同时也就释放了所占用的端口号。 3、 错误三：当运行PHP文件时浏览器询问是否下载文件 如果出现这个错误，则证明Apache不支持PHP类型的文件，所以我们需要检测Apache配置文件中的AddType application/x-httpd-php .php中的语句是否书写正确。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/10/16/基于Windows环境下的PHP开发环境搭建/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Apache</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下nginx配置虚拟主机！]]></title>
    <url>%2F2016%2F08%2F16%2FLinux%E4%B8%8BNginx%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%EF%BC%81%2F</url>
    <content type="text"><![CDATA[什么虚拟主机?一台linux服务器上放置多套网站:一家公司可能企业网站要点:一旦一台linux服务器上加设虚拟主机，则不能再用ip来访问这台linux服务器，而应该用每个虚拟主机网站的相应域名来访问相应的网站通过一台服务器的同一个ip同一个端口用不同的域名去访问不同的网站 1.准备两个网站,一个是baidu，一个是sina2.在nginx中进行设置，准备两个网站的虚拟主机自我总结：１.通过 ps -ef | grep nginx 命令获取ｎｇｉｎｘ安装目录。 ２.打开/etc/nginx/vhost 目录，新建ｂａｉｄｕ．ｃｏｎｆ，编辑 vi /usr/local/nginx/conf/nginx.conf ：12345678910111213http&#123; //全局配置 server&#123; //局部配置 name www.baidu.com html /web/baidu &#125; server&#123; //局部配置 name www.sina.com html /web/sina &#125;&#125; 详细配置:server { listen 80; server_name www.baidu.com; access_log logs/baidu.access.log main; location / { root /web/baidu; index index.html index.htm; } } server { listen 80; server_name www.sina.com; access_log logs/sina.access.log main; location / { root /web/sina; index index.html index.htm; } } 重新启动服务或者重新加载服务:1.pkill nginx//关闭nginx进程 2./usr/local/nginx/sbin/nginx//重新启动nginx服务 重新加载服务或者平滑重启:1.pkill -HUP nginx//把配置文件中的新更改的东西加载到正在运行nginx的进程中，接着对用户提供服务，但是nginx进程并没有关闭. 用域名去访问web服务器，需要dns服务器支持,还可能用自己系统中的hosts解析文件来帮你解析域名: C:\Windows\System32\drivers\etcvi hosts192.168.100.1 www.baidu.com192.168.100.1 www.sina.com lnmp集成包安装步骤：https://lnmp.org/install.html lnmp集成包配置虚拟主机：http://lnmp.org/faq/lnmp-vhost-add-howto.html 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Linux下Nginx配置虚拟主机！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据量高并发的数据库优化！]]></title>
    <url>%2F2016%2F08%2F16%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一、数据库结构的设计 如果不能设计一个合理的数据库模型，不仅会增加客户端和服务器段程序的编程和维护的难度，而且将会影响系统实际运行的性能。所以，在一个系统开始实施之前，完备的数据库模型的设计是必须的。 在一个系统分析、设计阶段，因为数据量较小，负荷较低。我们往往只注意到功能的实现，而很难注意到性能的薄弱之处，等到系统投入实际运行一段时间后，才发现系统的性能在降低，这时再来考虑提高系统性能则要花费更多的人力物力，而整个系统也不可避免的形成了一个打补丁工程。 所以在考虑整个系统的流程的时候，我们必须要考虑，在高并发大数据量的访问情况下，我们的系统会不会出现极端的情况。（例如：对外统计系统在7月16日出现的数据异常的情况，并发大数据量的的访问造成，数据库的响应时间不能跟上数据刷新的速度造成。具体情况是：在日期临界时（00：00：00），判断数据库中是否有当前日期的记录，没有则插入一条当前日期的记录。在低并发访问的情况下，不会发生问题，但是当日期临界时的访问量相当大的时候，在做这一判断的时候，会出现多次条件成立，则数据库里会被插入多条当前日期的记录，从而造成数据错误。），数据库的模型确定下来之后，我们有必要做一个系统内数据流向图，分析可能出现的瓶颈。 为了保证数据库的一致性和完整性，在逻辑设计的时候往往会设计过多的表间关联，尽可能的降低数据的冗余。（例如用户表的地区，我们可以把地区另外存放到一个地区表中）如果数据冗余低，数据的完整性容易得到保证，提高了数据吞吐速度，保证了数据的完整性，清楚地表达数据元素之间的关系。而对于多表之间的关联查询（尤其是大数据表）时，其性能将会降低，同时也提高了客户端程序的编程难度，因此，物理设计需折衷考虑，根据业务规则，确定对关联表的数据量大小、数据项的访问频度，对此类数据表频繁的关联查询应适当提高数据冗余设计但增加了表间连接查询的操作，也使得程序的变得复杂，为了提高系统的响应时间，合理的数据冗余也是必要的。设计人员在设计阶段应根据系统操作的类型、频度加以均衡考虑。 另外，最好不要用自增属性字段作为主键与子表关联。不便于系统的迁移和数据恢复。对外统计系统映射关系丢失（**）。 原来的表格必须可以通过由它分离出去的表格重新构建。使用这个规定的好处是，你可以确保不会在分离的表格中引入多余的列，所有你创建的表格结构都与它们的实际需要一样大。应用这条规定是一个好习惯，不过除非你要处理一个非常大型的数据，否则你将不需要用到它。（例如一个通行证系统，我可以将 USERID，USERNAME，USERPASSWORD，单独出来作个表，再把USERID作为其他表的外键） 表的设计具体注意的问题： 1、数据行的长度不要超过8020字节，如果超过这个长度的话在物理页中这条数据会占用两行从而造成存储碎片，降低查询效率。 2、能够用数字类型的字段尽量选择数字类型而不用字符串类型的（电话号码），这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 3、对于不可变字符类型char和可变字符类型varchar 都是8000字节,char查询快，但是耗存储空间，varchar查询相对慢一些但是节省存储空间。在设计字段的时候可以灵活选择，例如用户名、密码等长度变化不大的字段可以选择CHAR，对于评论等长度变化大的字段可以选择VARCHAR。 4、字段的长度在最大限度的满足可能的需要的前提下，应该尽可能的设得短一些，这样可以提高查询的效率，而且在建立索引的时候也可以减少资源的消耗。 二、查询的优化保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如SELECT FROM T1语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM T1；在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。在没有建索引的情况下，数据库查找某一条数据，就必须进行全表扫描了，对所有数据进行一次遍历，查找出符合条件的记录。在数据量比较小的情况下，也许看不出明显的差别，但是当数据量大的情况下，这种情况就是极为糟糕的了。SQL语句在SQL SERVER中是如何执行的，他们担心自己所写的SQL语句会被SQL SERVER误解。比如：select from table1 where name=’zhangsan’ and tID &gt; 10000和执行:select from table1 where tID &gt; 10000 and name=’zhangsan’一些人不知道以上两条语句的执行效率是否一样，因为如果简单的从语句先后上看，这两个语句的确是不一样，如果tID是一个聚合索引，那么后一句仅仅从表的 10000条以后的记录中查找就行了；而前一句则要先从全表中查找看有几个name=’zhangsan’的，而后再根据限制条件条件tID&gt; 10000来提出查询结果。事实上，这样的担心是不必要的。SQL SERVER中有一个“查询分析优化器”，它可以计算出where子句中的搜索条件并确定哪个索引能缩小表扫描的搜索空间，也就是说，它能实现自动优化。虽然查询优化器可以根据where子句自动的进行查询优化，但有时查询优化器就会不按照您的本意进行快速查询。在查询分析阶段，查询优化器查看查询的每个阶段并决定限制需要扫描的数据量是否有用。如果一个阶段可以被用作一个扫描参数（SARG），那么就称之为可优化的，并且可以利用索引快速获得所需数据。SARG的定义：用于限制搜索的一个操作，因为它通常是指一个特定的匹配，一个值的范围内的匹配或者两个以上条件的AND连接。形式如下：列名 操作符 &lt;常数 或 变量&gt; 或 &lt;常数 或 变量&gt; 操作符 列名列名可以出现在操作符的一边，而常数或变量出现在操作符的另一边。如：Name=’张三’价格&gt;50005000&lt;价格Name=’张三’ and 价格&gt;5000如果一个表达式不能满足SARG的形式，那它就无法限制搜索的范围了，也就是SQL SERVER必须对每一行都判断它是否满足WHERE子句中的所有条件。所以一个索引对于不满足SARG形式的表达式来说是无用的。 所以，优化查询最重要的就是，尽量使语句符合查询优化器的规则避免全表扫描而使用索引查询。具体要注意的：1.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=02.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。3.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10union allselect id from t where num=204.in 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。如：select id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 35.尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。见如下例子：SELECT FROM T1 WHERE NAME LIKE ‘%L%’SELECT FROM T1 WHERE SUBSTING(NAME,2,1)=’L’SELECT FROM T1 WHERE NAME LIKE ‘L%’即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。6.必要时强制查询优化器使用某个索引，如在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：SELECT FROM T1 WHERE F1/2=100应改为:SELECT FROM T1 WHERE F1=1002SELECT FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=’5378’应改为:SELECT FROM RECORD WHERE CARD_NO LIKE ‘5378%’SELECT member_number, first_name, last_name FROM membersWHERE DATEDIFF(yy,datofbirth,GETDATE()) &gt; 21应改为:SELECT member_number, first_name, last_name FROM membersWHERE dateofbirth &lt; DATEADD(yy,-21,GETDATE())即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’–name以abc开头的idselect id from t where datediff(day,createdate,’2005-11-30’)=0–‘2005-11-30’生成的id应改为:select id from t where name like ‘abc%’select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。11.很多时候用 exists是一个好的选择：elect num from a where num in(select num from b)用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)SELECT SUM(T1.C1)FROM T1 WHERE((SELECT COUNT()FROM T2 WHERE T2.C2=T1.C2&gt;0)SELECT SUM(T1.C1) FROM T1WHERE EXISTS(SELECT FROM T2 WHERE T2.C2=T1.C2)两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。如果你想校验表里是否存在某条纪录，不要用count()那样效率很低，而且浪费服务器资源。可以用EXISTS代替。如：IF (SELECT COUNT() FROM table_name WHERE column_name = ‘xxx’)可以写成：IF EXISTS (SELECT FROM table_name WHERE column_name = ‘xxx’)经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父结果集中有而在子结果集中没有的记录，如：SELECT a.hdr_key FROM hdr_tbl a—- tbl a 表示tbl用别名a代替WHERE NOT EXISTS (SELECT * FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key)SELECT a.hdr_key FROM hdr_tbl aLEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULLSELECT hdr_key FROM hdr_tblWHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl)三种写法都可以得到同样正确的结果，但是效率依次降低。12.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。13.避免频繁创建和删除临时表，以减少系统表资源的消耗。14.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。15.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。16.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。17.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。18.尽量避免大事务操作，提高系统并发能力。19.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 避免使用不兼容的数据类型。例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如:SELECT name FROM employee WHERE salary &gt; 60000在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。21.充分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。例：SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NOSELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO第二句将比第一句执行快得多。22、使用视图加速查询把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序 操作，而且在其他方面还能简化优化器的工作。例如：SELECT cust.name，rcvbles.balance，……other columnsFROM cust，rcvblesWHERE cust.customer_id = rcvlbes.customer_idAND rcvblls.balance&gt;0AND cust.postcode&gt;“98000”ORDER BY cust.name如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个视图中，并按客户的名字进行排序：CREATE VIEW DBO.V_CUST_RCVLBESASSELECT cust.name，rcvbles.balance，……other columnsFROM cust，rcvblesWHERE cust.customer_id = rcvlbes.customer_idAND rcvblls.balance&gt;0ORDER BY cust.name然后以下面的方式在视图中查询：SELECT ＊ FROM V_CUST_RCVLBESWHERE postcode&gt;“98000”视图中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘I/O，所以查询工作量可以得到大幅减少。23、能用DISTINCT的就不用GROUP BYSELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID可改为：SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 1024.能用UNION ALL就不要用UNIONUNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源35.尽量不要用SELECT INTO语句。SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体上看询成本百分比即可。三、算法的优化尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 游标提供了对特定集合中逐行扫描的手段，一般使用游标逐行遍历数据，根据取出的数据不同条件进行不同的操作。尤其对多表和大表定义的游标（大的数据集合）循环很容易使程序进入一个漫长的等特甚至死机。 在有些场合，有时也非得使用游标，此时也可考虑将符合条件的数据行转入临时表中，再对临时表定义游标进行操作，可时性能得到明显提高。（例如：对内统计第一版）封装存储过程四、建立高效的索引 创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。大型数据库有两种索引即簇索引和非簇索引，一个没有簇索引的表是按堆结构存储数据，所有的数据均添加在表的尾部，而建立了簇索引的表，其数据在物理上会按照簇索引键的顺序存储，一个表只允许有一个簇索引，因此，根据B树结构，可以理解添加任何一种索引均能提高按索引列查询的速度，但会降低插入、更新、删除操作的性能，尤其是当填充因子（Fill Factor）较大时。所以对索引较多的表进行频繁的插入、更新、删除操作，建表和索引时因设置较小的填充因子，以便在各数据页中留下较多的自由空间，减少页分割及重新组织的工作。索引是从数据库中获取数据的最高效方式之一。95% 的数据库性能问题都可以采用索引技术得到解决。作为一条规则，我通常对逻辑主键使用唯一的成组索引，对系统键（作为存储过程）采用唯一的非成组索引，对任何外键列[字段]采用非成组索引。不过，索引就象是盐，太多了菜就咸了。你得考虑数据库的空间有多大，表如何进行访问，还有这些访问是否主要用作读写。实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以 “z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查 “张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。（一）何时使用聚集索引或非聚集索引下面的表总结了何时使用聚集索引或非聚集索引（很重要）。动作描述 使用聚集索引 使用非聚集索引列经常被分组排序 应 应返回某范围内的数据 应 不应一个或极少不同值 不应 不应小数目的不同值 应 不应大数目的不同值 不应 应频繁更新的列 不应 应外键列 应 应主键列 应 应频繁修改索引列 不应 应 事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。 （二）结合实际，谈索引使用的误区理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。1、主键就是聚集索引这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。2、只要建立索引就能显著提高查询速度事实上，我们可以发现上面的例子中，第2、3条语句完全相同，且建立索引的字段也相同；不同的仅是前者在fariqi字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。从建表的语句中，我们可以看到这个有着1000万数据的表中fariqi字段有5003个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合建立聚集索引要求的：“既不能绝大多数都相同，又不能只有极少数相同”的规则。由此看来，我们建立“适当”的聚合索引对于我们提高查询速度是非常重要的。3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度上面已经谈到：在进行数据查询时都离不开字段的是“日期”还有用户本身的“用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个复合索引（compound index）。很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。（三）其他注意事项“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/大数据量高并发的数据库优化！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装lnmp集成包！]]></title>
    <url>%2F2016%2F08%2F16%2FLinux%E5%AE%89%E8%A3%85lnmp%E9%9B%86%E6%88%90%E5%8C%85%EF%BC%81%2F</url>
    <content type="text"><![CDATA[LNMP一键安装包 - Readme LNMP一键安装包是什么? LNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RadHat/Fedora、Debian/Ubuntu/Raspbian/Deepin Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。同时提供一些实用的辅助工具如：虚拟主机管理、FTP用户管理、Nginx、MySQL/MariaDB、PHP的升级、常用缓存组件的安装、重置MySQL root密码、502自动重启、日志切割、SSH防护DenyHosts/Fail2Ban、备份等许多实用脚本。 LNMP官网：https://lnmp.org作者: licess admin@lnmp.org 安装 安装前建议使用screen，执行：screen -S lnmp 后执行wget -c http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gz &amp;&amp; tar zxf lnmp1.3-full.tar.gz &amp;&amp; cd lnmp1.3-full &amp;&amp; ./install.sh {lnmp|lnmpa|lamp} 如断线可使用screen -r lnmp 恢复。详细安装教程参考：https://lnmp.org/install.html注意:1.3版增加了lnmp.conf配置文件，可以自定义下载服务器地址、数据库目录及nginx和php编译参数，不论安装升级都会调用该文件里的设置，安装或升级时可跟进需求自己更改。 常用功能 以下操作需lnmp目录下执行，如lnmp1.3-full或lnmp1.3 FTP服务器 执行：./pureftpd.sh 安装，可使用lnmp ftp {add|list|del}进行管理。 升级脚本： 执行：./upgrade.sh 按提示进行选择也可以直接使用参数：./upgrade.sh {nginx|mysql|mariadb|php|phpa|m2m|phpmyadmin} 参数: nginx 可升级至任意Nginx版本。 参数: mysql 可升级至任意MySQL版本，MySQL升级风险较大，虽然会自动备份数据，依然建议自行再备份一下。 参数: mariadb 可升级已安装的Mariadb，虽然会自动备份数据，依然建议自行再备份一下。 参数: m2m 可从MySQL升级至Mariadb，虽然会自动备份数据，依然建议自行再备份一下。 参数: php 仅适用于LNMP，可升级至大部分PHP版本。 参数: phpa 可升级LNMPA/LAMP的PHP至大部分版本。 参数: phpmyadmin 可升级phpMyadmin。 扩展插件 执行: ./addons.sh {install|uninstall} {eaccelerator|xcache|memcached|opcache|redis|imagemagick|ioncube}缓存加速： 参数: xcache 安装时需选择版本和设置密码，http://yourIP/xcache/ 进行管理，用户名 admin，密码为安装xcache时设置的。 参数: redis 参数: memcached 可选择php-memcache或php-memcached扩展。 参数: opcache http://yourIP/ocp.php 进行管理。 参数: eaccelerator 安装。 请勿安装多个缓存类扩展模块，多个可能导致网站出现问题 ！ 图像处理： 参数: ./addons.sh {install|uninstall} imageMagick imageMagick路径：/usr/local/imagemagick/bin/。 解密： IonCube，执行：./addons.sh {install|uninstall} ionCube 。 其他： 可选1，执行：./php5.2.17.sh 可安装一个不与LNMP冲突的PHP 5.2.17单独存在，目录在/usr/local/php52/，使用时需要将nginx虚拟主机配置文件里的 php-cgi.sock 修改为 php-cgi52.sock即可调用PHP5.2.17。 以下工具在lnmp安装包tools目录下 可选2，执行：./reset_mysql_root_password.sh 可重置MySQL/MariaDB的root密码。 可选3，执行：./check502.sh 可检测php-fpm是否挂掉,502报错时重启，配合crontab使用。 可选4，执行：./cut_nginx_logs.sh 日志切割脚本。 可选5，执行：./remove_disable_function.sh 运行此脚本可删掉禁用函数。 卸载 卸载LNMP、LNMPA或LAMP可执行：./uninstall.sh 按提示选择即可卸载。 状态管理 LNMP/LNMPA/LMAP状态管理：lnmp {start|stop|reload|restart|kill|status} Nginx状态管理：lnmp nginx或/etc/init.d/nginx {start|stop|reload|restart} MySQL状态管理：lnmp mysql或/etc/init.d/mysql {start|stop|restart|reload|force-reload|status} MariaDB状态管理：lnmp mariadb或/etc/init.d/mariadb {start|stop|restart|reload|force-reload|status} PHP-FPM状态管理：lnmp php-fpm或/etc/init.d/php-fpm {start|stop|quit|restart|reload|logrotate} PureFTPd状态管理：lnmp pureftpd或/etc/init.d/pureftpd {start|stop|restart|kill|status} Apache状态管理：lnmp httpd或/etc/init.d/httpd {start|stop|restart|graceful|graceful-stop|configtest|status} 虚拟主机管理 添加：lnmp vhost add 删除：lnmp vhost del 列出：lnmp vhost list 相关图形界面 PHPMyAdmin：http://yourIP/phpmyadmin/ phpinfo：http://yourIP/phpinfo.php PHP探针：http://yourIP/p.php Xcache管理界面：http://yourIP/xcache/ Zend Opcache管理界面：http://yourIP/ocp.php LNMP相关目录文件 目录位置 Nginx：/usr/local/nginx/ MySQL：/usr/local/mysql/ MariaDB：/usr/local/mariadb/ PHP：/usr/local/php/ PHPMyAdmin：/home/wwwroot/default/phpmyadmin/ 默认虚拟主机网站目录：/home/wwwroot/default/ Nginx日志目录：/home/wwwlogs/ 配置文件： Nginx主配置文件：/usr/local/nginx/conf/nginx.conf MySQL/MariaDB配置文件：/etc/my.cnf PHP配置文件：/usr/local/php/etc/php.ini PHP-FPM配置文件：/usr/local/php/etc/php-fpm.conf PureFtpd配置文件：/usr/local/pureftpd/etc/pure-ftpd.conf Apache配置文件：/usr/local/apache/conf/httpd.conf 进入解压厚的lnmp文件夹,输入命令：./install.sh安装lnmp环境，lnmp vhost list 查看虚拟主机列表，lnmp vhost add 添加虚拟主机列表，lnmp vhost del 删除虚拟主机列表，service nginx restart 重启nginx服务器，安装memcache和redis命令：./addons.sh install技术支持 技术支持论坛：http://bbs.vpser.net/forum-25-1.html 问题：Another app is currently holding the yum lock; waiting for it to exit… The other application is: PackageKit Memory : 160 M RSS (567 MB VSZ) Started: Mon Jul 11 20:16:35 2016 - 2:26:42 ago State : Sleeping, pid: 12855 解决：编辑器加载中another app is currently holding the yum lock;waiting for it to exit… 有时用yum升级一些文件时，会出现以下情况： another app is currently holding the yum lock;waiting for it to exit… 可以通过强制关掉yum进程： #rm -f /var/run/yum.pid 然后就可以使用yum了。 … 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Linux安装lnmp集成包！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql视图笔记!]]></title>
    <url>%2F2016%2F08%2F16%2FMYSQL%E8%A7%86%E5%9B%BE%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[mysql视图笔记：视图是虚表，实际数据表的映射。实际数据发生变化视图也跟着变化。当查询数据要关联多张表的时候，要写很长的sql语句，可以使用视图简化。视图主要用来查询方便，如果修改也是可以的，一次只能修改一张实表的数据 。 文章分类表：文章表： 文章视图： 123456789101112131415161718//创建文章视图（文章表关联文章分类表,最好是inner join 关联） create view article as select c.title cat_name,a.* from db_article a inner join db_article_cat c on a.cid = c.id //查询视图(实表数据变化查询结果也跟着变化)select * from article //更新视图1. 根据主键更新数据，一次更改多张表会失败 update article set cat_name = &apos;test&apos;,title = &apos;testabc&apos; where id=602 and cid=612 根据主键更新数据，更新视图中的文章分类名称，根据视图文章ID，实际修改了文章分类表update article set cat_name =&apos;修改后的分类名称&apos; where id =1 //删除视图，和删除表一样drop view article 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/MYSQL视图笔记！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大并发处理解决方案！]]></title>
    <url>%2F2016%2F08%2F16%2F%E5%A4%A7%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%81%2F</url>
    <content type="text"><![CDATA[摘要： 大型网站，比如门户网站。在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。关键词： 服务器数据库 一个小型的网站，比如个人网站，可以使用最简单的html静态页面就实现了，配合一些图片达到美化效果，所有的页面均存放在一个目录下，这样的网站对系统架构、性能的要求都很简单，随着互联网业务的不断丰富，网站相关的技术经过这些年的发展，已经细分到很细的方方面面，尤其对于大型网站来说，所采用的技术更是涉及面非常广，从硬件到软件、编程语言、数据库、WebServer、防火墙等各个领域都有了很高的要求，已经不是原来简单的html静态网站所能比拟的。 大型网站，比如门户网站。在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。但是除了这几个方面，还没法根本解决大型网站面临的高负载和高并发问题。 上面提供的几个解决思路在一定程度上也意味着更大的投入，并且这样的解决思路具备瓶颈，没有很好的扩展性，下面我从低成本、高性能和高扩张性的角度来说说我的一些经验。 1、HTML静态化 其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统CMS，像我们常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。 除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化，有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。 同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现，比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储再数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。 2、图片服务器分离 大家知道，对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的图片服务器，甚至很多台图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃，在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持，尽可能少的LoadModule，保证更高的系统消耗和执行效率。 3、数据库集群和库表散列 大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表散列。 在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是类似的方案，您使用了什么样的DB，就参考相应的解决方案来实施即可。 上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用DB类型的限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并且最有效的解决方案。我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。sohu的论坛就是采用了这样的架构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板块和ID进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系统随时增加一台低成本的数据库进来补充系统性能。 4、缓存 缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。这里先讲述最基本的两种缓存。高级和分布式的缓存在后面讲述。 架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。 网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用Java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，。net不是很熟悉，相信也肯定有。 5、镜像 镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。 6、负载均衡 负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。 负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择，我个人接触过一些解决方法，其中有两个架构可以给大家做参考。 1）硬件四层交换 第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。 第四层交换功能就象是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、TCP和UDP端口共同决定。 在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。Yahoo中国当初接近2000台服务器使用了三四台Alteon就搞定了。 2）软件四层交换 大家知道了硬件四层交换机的原理后，基于OSI模型来实现的软件四层交换也就应运而生，这样的解决方案实现的原理一致，不过性能稍差。但是满足一定量的压力还是游刃有余的，有人说软件实现方式其实更灵活，处理能力完全看你配置的熟悉能力。 软件四层交换我们可以使用Linux上常用的LVS来解决，LVS就是Linux Virtual Server，他提供了基于心跳线heartbeat的实时灾难应对解决方案，提高系统的鲁棒性，同时可供了灵活的虚拟VIP配置和管理功能，可以同时满足多种应用需求，这对于分布式的系统来说必不可少。 一个典型的使用负载均衡的策略就是，在软件或者硬件四层交换的基础上搭建squid集群，这种思路在很多大型网站包括搜索引擎上被采用，这样的架构低成本、高性能还有很强的扩张性，随时往架构里面增减节点都非常容易。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/大并发处理解决方案！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高并发高负载数据库架构策略！]]></title>
    <url>%2F2016%2F08%2F16%2F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E8%B4%9F%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E7%AD%96%E7%95%A5%EF%BC%81%2F</url>
    <content type="text"><![CDATA[在WEB网站的规模从小到大不断扩展的过程中，数据库的访问压力也不断的增加，数据库的架构也需要动态扩展，在数据库的扩展过程基本上包含如下几步，每一个扩展都可以比上一步骤的部署方式的性能得到数量级的提升。 WEB应用和数据库部署在同一台服务器上一般的小规模的网站采用这种方式，用户量、数据量、并发访问量都比较小，否则单台服务器无法承受，并且在遇到性能瓶颈的时候升级硬件所需要的费用非常高 昂，在访问量增加的时候，应用程序和数据库都来抢占有限的系统资源，很快就又会遇到性能问题。 WEB应用和数据库部署在各自独立的服务器上web应用和数据库分开部署，WEB应用服务器和数据库服务器各司其职，在系统访问量增加的时候可以分别升级应用服务器和数据库服务器，这种部署方式是一般小规模网站的典型部署方式。在将应用程序进行性能优化并且使用数据库对象缓存策略的情况下，可以承载较大的访问量，比如2000用户，200个并发，百万级别的数据量。 数据库服务器采用集群方式部署（比如Oracle的一个数据库多个实例的情况）数据库集群方式能承担的负载是比较大的，数据库物理介质为一个磁盘阵列，多个数据库实例以虚拟IP方式向外部应用服务器提供数据库连接服务。这种部署方式 基本上可以满足绝大多数的常见WEB应用，但是还是不能满足大用户量、高负载、数据库读写访问非常频繁的应用。 数据库采用主从部署方式在面向大众用户的博客、论谈、交友、CMS等系统中，有上百万的用户，有上千万的数据量，存在众多的数据库查询操作，也有较多的数据库写操作，并且在多数情况下都是读操作远大于写操作的。在这个时候，假如能将数据库的读写操作分离的话，对于系统来讲是一个很大的提高啦。数据库的主从部署方式就走到我们面前啦。主从复制： 几乎所有的主流数据库都支持复制，这是进行数据库简单扩展的基本手段。下面以Mysql为例来说明，它支持主从复制，配置也并不复杂，只需要开启主服务器上的二进制日志以及在主服务器和从服务器上分别进行简单的配置和授权。Mysql的主从复制是一句主服务器的二进制日志文件进行的，主服务器日志中记录的操作会在从服务器上重放，从而实现复制，所以主服务器必须开启二进制日志，自动记录所有对于主数据库的更新操作，从服务器再定时到主服务器取得二进制日志 文件进行重放则完成了数据的复制。主从复制也用于自动备份。读写分离： 为保证数据库数据的一致性，我们要求所有对于数据库的更新操作都是针对主数据库的，但是读操作是可以针对从数据库来进行。大多数站点的数据库读操作比写操作更加密集，而且查询条件相对复杂，数据库的大部分性能消耗在查询操作上了。主从复制数据是异步完成的，这就导致主从数据库中的数据有一定的延迟，在读写分离的设计中必须要考虑这一点。以博客为例，用户登录后发表了一篇文章，他需要马上看到自己的文章，但是对于其它用户来讲可以允许延迟一段时间（1分钟/5分钟/30分钟），不会造成什么问题。这时对于当前用户就需要读主数据库，对于其他访问量更大的外部用户就可以读从数据库。数据库反向代理： 在读写分离的方式使用主从部署方式的数据库的时候，会遇到一个问题，一个主数据库对应多台从服务器，对于写操作是针对主数据库的，数据库个数是唯一的，但 是对于从服务器的读操作就需要使用适当的算法来分配请求啦，尤其对于多个从服务器的配置不一样的时候甚至需要读操作按照权重来分配。 对于上述问题可以使用数据库方向代理来实现。就像WEB方向代理服务器一样，MYsql Proxy同样可以在SQL语句转发到后端的Mysql服务器之前对它进行修改。 数据库垂直分割主从部署数据库中，当写操作占了主数据库的CPU消耗的50%以上的时候，我们再增加从服务器的意义就不是很大了，因为所有的从服务器的写操作也将占到 CPU消耗的50%以上，一台从服务器提供出来查询的资源非常有限。数据库就需要重新架构了，我们需要采用数据库垂直分区技术啦。 最简单的垂直分区方式是将原来的数据库中独立的业务进行分拆（被分拆出来的部分与其它部分不需要进行Join连接查询操作），比如WEB站点的BLOG和 论坛，是相对独立的，与其它的数据的关联性不是很强，这时可以将原来的数据库拆分为一个BLog库，一个论坛库，以及剩余的表所组成的库。这三个库再各自进行主从数据库方式部署，这样整个数据库的压力就分担啦。另外查询扩展性也是采用数据库分区最主要的原因之一。将一个大的数据库分成多个小的数据库可以提高查询的性能，因为每个数据库分区拥有自己的一小部分数据。假设您想扫描1亿条记录，对一个单一分区的数据库来讲，该扫描操作需要数据库管理器独立扫描一亿条记录，如果您将数据库系统做成50个分区，并将这1 亿条记录平均分配到这50个分区上，那么每个数据库分区的数据库管理器将只扫描200万记录。 数据库水平分割在数据库的垂直分区之后，假如我们的BLOG库又再次无法承担写操作的时候，我们又该怎么办呢？数据库垂直分区这种扩展方式又无能为力了，我们需要的是水 平分区。 水平分区意味着我们可以将同一个数据库表中的记录通过特定的算法进行分离，分别保存在不同的数据库表中，从而可以部署在不同的数据库服务器上。很多的大规模的站点基本上都是主从复制+垂直分区+水平分区这样的架构。水平分区并不依赖什么特定的技术，完全是逻辑层面的规划，需要的是经验和业务的细分。如何分区呢？对于大型的WEB站点来说，必须分区，并且对于分区我们没有选择的余地，对于那些频繁访问导致站点接近崩溃的热点数据，我们必须分区。在对数据分区的时候，我们必须要存在一个分区索引字段，比如USER_ID，它必须和所有的记录都存在关系，是分区数据库中的核心表的主键，在其它表中作 为外键，并且在使用主键的时候，该主键不能是自增长的，必须是业务主键才可以。余数分区： 我们可以将User_ID%10后的值为依据存入到不同的分区数据库中，该算法简单高效，但是在分区数据库个数有变动的时候，整个系统的数据需要重新分布。范围分区： 我们可以将User_ID的范围进行分区，比如1-100000范围为一个分区数据库，100001-200000范围为一个分区数据库，该算法在分区数 据库个数有变动的时候，系统非常有利于扩展，但是容易导致不同分区之间的压力不同，比如老用户所在的分区数据库的压力很大，但是新用户的分区数据库的压力偏小。映射关系分区： 将对分区索引字段的每个可能的结果创建一个分区映射关系，这个映射关系非常庞大，需要将它们写入数据库中。比如当应用程序需要知道User_id为10的 用户的BLOG内容在那个分区时，它必须查询数据库获取答案，当然，我们可以使用缓存来提高性能。 这种方式详细保存了每一个记录的分区对应关系，所以各个分区有非常强的可伸缩性，可以灵活的控制，并且将数据库从一个分区迁移到另一个分区也很简单，也可以使各个分区通过灵活的动态调节来保持压力的分布平衡。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/高并发高负载数据库架构策略！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-sql优化笔记！]]></title>
    <url>%2F2016%2F08%2F16%2FMYSQL-sql%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[分析问题的几个步骤： #####1. 开启慢查询日志这个步骤就是为了记录慢查询的sql，为下个步骤做准备：12345678910//查看慢查询的日志记录是否开启 如上图show variables like &apos;%slow_query_log%&apos;; //设置慢查询开启的两种写法：set global slow_query_log=1; set global slow_query_log=true; //设置慢查询开启的两种写法：set global slow_query_log=0; set global slow_query_log=false; #####2. 用explain 分析sql 语句 1explain select * from crm_ego_members; //分析sql语句 ######table：显示这一行的数据是关于哪张表的 ######type：显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、 indexhe和ALL为 ALL 时，表示要扫描全表，尽量避免 ######possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 ######key： 表示此 SQL 语句是否用到索引，null代表没有！很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 ######key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好 ######ref ： 显示索引的哪一列被使用了，如果可能的话，是一个常数 ######rows：MYSQL认为必须检查的用来返回请求数据的行数 ######Extra： 关于MYSQL如何解析查询的额外信息。坏的例子是Using temporary和Using filesort（文件排序，尽量避免使用），意思MYSQL根本不能使用索引，结果是检索会很慢Extra列返回的描述的意义: Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了 Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序） system 表只有一行：system表。这是const连接类型的特殊情况 const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待 eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用 ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好 range:这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况 index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据） ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免. 注释：如何查看步骤的执行顺序呢？ 如果id相同，从上到下执行。如果id不同id大的先执行。 #####3. 使用profile 来查看sql 的执行周期，看看sql的问题出错在执行的哪个步骤上。 123456789101112//用来查看mysql 前十几条查询 show profiles;//设置profile 功能开启 set profiling=1; set profiling=true; //设置profile 功能关闭 set profiling=0; set profiling=false; show profile for query N; //查看 第 N 条 sql 的执行生命周期 #####4. 修改mysql 数据库配置文件，比如设置查询缓冲区的大小等等。使用慢查询分析 在my.ini中： long_query_time=1 log-slow-queries=d:\mysql5\logs\mysqlslow.log 把超过1秒的记录在慢查询日志中 可以用mysqlsla来分析之。也可以在mysqlreport中，有如 DMS分别分析了select ,update,insert,delete,replace等所占的百份比 4.MYISAM和INNODB的锁定 myisam中，注意是表锁来的，比如在多个UPDATE操作后，再SELECT时，会发现SELECT操作被锁定了，必须等所有UPDATE操作完毕后，再能SELECT innodb的话则不同了，用的是行锁，不存在上面问题。 另外数据到一定量时，sql语句优化效果才会明显！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/MYSQL-sql优化笔记！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcache学习教程！]]></title>
    <url>%2F2016%2F08%2F16%2FMemcache%E6%95%99%E7%A8%8B-!%2F</url>
    <content type="text"><![CDATA[一、Memcache概述Memcache是danga.com的一个开源项目，可以类比于MySQL这样的服务。memcached 是高效、快速的分布式内存对象缓存系统，主要用于加速 WEB 动态应用程序。用自己的话说，memcache是一个服务器端软件，跟apache、mysql一样，也有自己的端口。维护一个存在于内存中的hash表。 二、Memcache工作原理（1）初级首先 memcached 是以守护程序方式运行于一个或多个服务器中，随时接受客户端的连接操作，客户端可以由各种语言编写，目前已知的客户端 API 包括 Perl/PHP/Python/Ruby/Java/C#/C 等等。客户端在与 memcached 服务建立连接之后，接下来的事情就是存取对象了，每个被存取的对象都有一个唯一的标识符 key，存取操作均通过这个 key 进行，保存到 memcached 中的对象实际上是放置内存中的，并不是保存在 cache 文件中的，这也是为什么 memcached 能够如此高效快速的原因。注意，这些对象并不是持久的，服务停止之后，里边的数据就会丢失。 与许多 cache 工具类似，Memcached 的原理并不复杂。它采用了C/S的模式，在 server 端启动服务进程，在启动时可以指定监听的 ip，自己的端口号，所使用的内存大小等几个关键参数。一旦启动，服务就一直处于可用状态。Memcached 的目前版本是通过C实现，采用了单进程，单线程，异步I/O，基于事件 (event_based) 的服务方式.使用 libevent 作为事件通知实现。多个 Server 可以协同工作，但这些 Server 之间是没有任何通讯联系的，每个 Server 只是对自己的数据进行管理。Client 端通过指定 Server 端的 ip 地址(通过域名应该也可以)。需要缓存的对象或数据是以 key-&gt;value 对的形式保存在Server端。key 的值通过 hash 进行转换，根据 hash 值把 value 传递到对应的具体的某个 Server 上。当需要获取对象数据时，也根据 key 进行。首先对 key 进行 hash，通过获得的值可以确定它被保存在了哪台 Server 上，然后再向该 Server 发出请求。Client 端只需要知道保存 hash(key) 的值在哪台服务器上就可以了。 其实说到底，memcache 的工作就是在专门的机器的内存里维护一张巨大的 hash 表，来存储经常被读写的一些数组与文件，从而极大的提高网站的运行效率（当然花钱就是必不可免的事了，听说 MySpace 的每台 Cache 服务器都配备了至少 64G 的内存）。但是也要注意 memcache 不是万能的，毕竟网络方面的不稳定因素还是比较多的，如果不是很大的应用，我建议大家使用一些本地的轻量级的 Cache 库，比如 PHP 的 Cache_Lite 或者 Java 的 FileCache 等，最后希望大家读完这篇能有所收获 ：）（2）高级很多人把它当作和SharedMemory那种形式的存储载体来使用，虽然memcached使用了同样的“Key=&gt;Value”方式组织数据，但是它和共享内存、APC等本地缓存有非常大的区别。Memcached是分布式的，也就是说它不是本地的。它基于网络连接（当然它也可以使用 localhost）方式完成服务，本身它是一个独立于应用的程序或守护进程（Daemon方式）。 Memcached使用libevent库实现网络连接服务，理论上可以处理无限多的连接，但是它和Apache不同，它更多的时候是面向稳定的持续连接的，所以它实际的并发能力是有限制的。在保守情况下memcached的最大同时连接数为200，这和Linux线程能力有关系，这个数值是可以调整的。关于libevent可以参考相关文档。 Memcached内存使用方式也和APC不同。APC是基于共享内存和MMAP的，memcachd有自己的内存分配算法和管理方式，它和共享内存没有关系，也没有共享内存的限制，通常情况下，每个memcached进程可以管理2GB的内存空间，如果需要更多的空间，可以增加进程数。 三、为什么要在Web中使用（memcache解决什么问题）（1）减少数据库压力这个算是比较重要的，所有的数据基本上都是保存在数据库当中的，每次频繁的存取数据库，导致 数据库性能极具下降，无法同时服务更多的用户，比如MySQL，特别频繁的锁表，那么让Memcache来分担数据库的压力吧。我们需要一种改动比较小， 并且能够不会大规模改变前端的方式来进行改变目前的架构。 我考虑的一种简单方法：后端的数据库操作模块，把所有的Select操作提取出来 （update/delete/insert不管），然后把对应的SQL进行相应的hash算法计算得出一个hash数据key（比如MD5或者 SHA），然后把这个key去Memcache中查找数据，如果这个数据不存在，说明还没写入到缓存中，那么从数据库把数据提取出来，一个是数组类格式， 然后把数据在set到Memcache中，key就是这个SQL的hash值，然后相应的设置一个失效时间，比如一个小时，那么一个小时中的数据都是从缓 存中提取的，有效减少数据库的压力。缺点是数据不实时，当数据做了修改以后，无法实时到前端显示，并且还有可能对内存占用比较大，毕竟每次select出 来的数据数量可能比较巨大，这个是需要考虑的因素。 （2）什么场合使用？在很多时候，memcached都被滥用了，这当然少不了对它的抱怨。我经常在论坛上看见有人发贴，类似于“如何提高效率”，回复是“用memcached”，至于怎么用，用在哪里，用来干什么一句没有。memcached不是万能的，它也不是适用在所有场合。 Memcached是“分布式”的内存对象缓存系统，那么就是说，那些不需要“分布”的，不需要共享的，或者干脆规模小到只有一台服务器的应用，memcached不会带来任何好处，相反还会拖慢系统效率，因为网络连接同样需要资源，即使是UNIX本地连接也一样。 在我之前的测试数据中显示，memcached本地读写速度要比直接PHP内存数组慢几十倍，而APC、共享内存方式都和直接数组差不多。可见，如果只是本地级缓存，使用memcached是非常不划算的。 Memcached在很多时候都是作为数据库前端cache使用的。因为它比数据库少了很多SQL解析、磁盘操作等开销，而且它是使用内存来管理数据的，所以它可以提供比直接读取数据库更好的性能，在大型系统中，访问同样的数据是很频繁的，memcached可以大大降低数据库压力，使系统执行效率提升。另外，memcached也经常作为服务器之间数据共享的存储媒介，例如在SSO系统中保存系统单点登陆状态的数据就可以保存在memcached 中，被多个应用共享。 需要注意的是，memcached使用内存管理数据，所以它是易失的，当服务器重启，或者memcached进程中止，数据便会丢失，所以 memcached不能用来持久保存数据。很多人的错误理解，memcached的性能非常好，好到了内存和硬盘的对比程度，其实memcached使用内存并不会得到成百上千的读写速度提高，它的实际瓶颈在于网络连接，它和使用磁盘的数据库系统相比，好处在于它本身非常“轻”，因为没有过多的开销和直接的读写方式，它可以轻松应付非常大的数据交换量，所以经常会出现两条千兆网络带宽都满负荷了，memcached进程本身并不占用多少CPU资源的情况。 四、安装memcache（在服务器端）（1）windows下123cmd进入memcached文件夹：输入memcached.exe -d install安装输入memcached.exe -d start 开启 （2）在linux下 五、memcached服务器的管理（1）Windows下：启动查看端口，是否启动成功 （2）Linux下：运行 memcached 守护程序很简单，只需一个命令行即可，不需要修改任何配置文件（也没有配置文件给你修改 ）： /usr/bin/memcached -d -m 128 -l 192.168.10.1 -p 10101 -u httpd 参数解释：-d 以守护程序（daemon）方式运行 memcached；-m 设置 memcached 可以使用的内存大小，单位为 M；-l 设置监听的 IP 地址，如果是本机的话，通常可以不设置此参数；-p 设置监听的端口，默认为 11211，所以也可以不设置此参数；-u 指定用户，如果当前为 root 的话，需要使用此参数指定用户。 当然，还有其它参数可以用，man memcached 一下就可以看到了。 六、使用memcache（在客户端）不同语言：可以是php/JAVA等首先，建立连接。通过IP和端口。访问apache、mysql也是通过IP和端口。其实，连接成功后，使用：1234567AddSet/replaceGetQuit遍历：本身没提供。State子命令： stat itemsStats cachedump 1 0 附：PHP的Memcache 123//连接$mem = new Memcache;$mem-&gt;connect(&quot;192.168.0.200&quot;, 12000); 1234//保存数据$mem-&gt;set(&apos;key1&apos;, &apos;This is first value&apos;, 0, 60);$val = $mem-&gt;get(&apos;key1&apos;);echo &quot;Get key1 value: &quot; . $val .&quot;&lt;br /&gt;&quot;; 1234//替换数据$mem-&gt;replace(&apos;key1&apos;, &apos;This is replace value&apos;, 0, 60);$val = $mem-&gt;get(&apos;key1&apos;);echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;; 1234567//保存数组$arr = array(&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;, &apos;ddd&apos;);$mem-&gt;set(&apos;key2&apos;, $arr, 0, 60);$val2 = $mem-&gt;get(&apos;key2&apos;);echo &quot;Get key2 value: &quot;;print_r($val2);echo &quot;&lt;br /&gt;&quot;; 1234//删除数据$mem-&gt;delete(&apos;key1&apos;);$val = $mem-&gt;get(&apos;key1&apos;);echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;; 123456//清除所有数据$mem-&gt;flush();$val2 = $mem-&gt;get(&apos;key2&apos;);echo &quot;Get key2 value: &quot;;print_r($val2);echo &quot;&lt;br /&gt;&quot;; 12//关闭连接$mem-&gt;close(); 如果正常的话，浏览器将输出：12345Get key1 value: This is first valueGet key1 value: This is replace valueGet key2 value: Array ( [0] =&gt; aaa [1] =&gt; bbb [2] =&gt; ccc [3] =&gt; ddd )Get key1 value:Get key2 value: 程序代码分析 初始化一个Memcache的对象：$mem = new Memcache; 连接到我们的Memcache服务器端，第一个参数是服务器的IP地址，也可以是主机名，第二个参数是Memcache的开放的端口：1$mem-&gt;connect(&quot;192.168.0.200&quot;, 12000); 保存一个数据到Memcache服务器上，第一个参数是数据的key，用来定位一个数据，第二个参数是需要保存的数据内容，这里是一个字符串，第三个参数是一个标记，一般设置为0或者MEMCACHE_COMPRESSED就行了，第四个参数是数据的有效期，就是说数据在这个时间内是有效的，如果过去这个时间，那么会被Memcache服务器端清除掉这个数据，单位是秒，如果设置为0，则是永远有效，我们这里设置了60，就是一分钟有效时间：1$mem-&gt;set(‘key1‘, ‘This is first value&apos;, 0, 60); 从Memcache服务器端获取一条数据，它只有一个参数，就是需要获取数据的key，我们这里是上一步设置的key1，现在获取这个数据后输出输出：12$val = $mem-&gt;get(&apos;key1′);echo &quot;Get key1 value: &quot; . $val; 现在是使用replace方法来替换掉上面key1的值，replace方法的参数跟set是一样的，不过第一个参数key1是必须是要替换数据内容的key，最后输出了：123$mem-&gt;replace(‘key1′, ‘This is replace value&apos;, 0, 60);$val = $mem-&gt;get(‘key1′);echo &quot;Get key1 value: &quot; . $val; 同样的，Memcache也是可以保存数组的，下面是在Memcache上面保存了一个数组，然后获取回来并输出1234$arr = array(‘aaa&apos;, ‘bbb&apos;, ‘ccc&apos;, ‘ddd&apos;);$mem-&gt;set(‘key2′, $arr, 0, 60);$val2 = $mem-&gt;get(‘key2′);print_r($val2); 现在删除一个数据，使用delte接口，参数就是一个key，然后就能够把Memcache服务器这个key的数据删除，最后输出的时候没有结果123$mem-&gt;delete(‘key1′);$val = $mem-&gt;get(‘key1′);echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br&gt;&quot;; 最后我们把所有的保存在Memcache服务器上的数据都清除，会发现数据都没有了，最后输出key2的数据为空，最后关闭连接12345$mem-&gt;flush();$val2 = $mem-&gt;get(‘key2′);echo &quot;Get key2 value: &quot;;print_r($val2);echo &quot;&lt;br&gt;&quot;; 七、Memcache的安全我们上面的 Memcache服务器端都是直接通过客户端连接后直接操作，没有任何的验证过程，这样如果服务器是直接暴露在互联网上的话是比较危险，轻则数据泄露被其 他无关人员查看，重则服务器被入侵，因为Mecache是以root权限运行的，况且里面可能存在一些我们未知的bug或者是缓冲区溢出的情况，这些都是 我们未知的，所以危险性是可以预见的。为了安全起见，我做两点建议，能够稍微的防止黑客的入侵或者数据的泄露。 内网访问最好把两台服务器之间的访问是内网形态的，一般是Web服务器跟Memcache服务器之间。普遍 的服务器都是有两块网卡，一块指向互联网，一块指向内网，那么就让Web服务器通过内网的网卡来访问Memcache服务器，我们Memcache的服务 器上启动的时候就监听内网的IP地址和端口，内网间的访问能够有效阻止其他非法的访问。 memcached -d -m 1024 -u root -l 192.168.0.200 -p 11211 -c 1024 -P /tmp/memcached.pidMemcache服务器端设置监听通过内网的192.168.0.200的ip的11211端口，占用1024MB内存，并且允许最大1024个并发连接 设置防火墙防火墙是简单有效的方式，如果却是两台服务器都是挂在网的，并且需要通过外网IP来访问Memcache的话，那么可以考虑使用防火墙或者代理程序来过滤非法访问。一般我们在Linux下可以使用iptables或者FreeBSD下的ipfw来指定一些规则防止一些非法的访问，比如我们可以设置只允许我们的Web服务器来访问我们Memcache服务器，同时阻止其他的访问。1234# iptables -F # iptables -P INPUT DROP # iptables -A INPUT -p tcp -s 192.168.0.2 –dport 11211 -j ACCEPT # iptables -A INPUT -p udp -s 192.168.0.2 –dport 11211 -j ACCEPT 上面的iptables规则就是只允许192.168.0.2这台Web服务器对Memcache服务器的访问，能够有效的阻止一些非法访问，相应的也可以增加一些其他的规则来加强安全性，这个可以根据自己的需要来做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 /* Windows下的Memcache安装： [提示错误:failed to install service or service already installed] 解决方法：在系统盘中找到cmd.exe文件，点击右键，以管理员身份运行 3.切换到memcached目录下输入命令,启动memcache服务 &gt;memcached.exe -d start 4.测试memcache是否连接成功 H:/wamp/www/php api/memcache&gt;telnet 127.0.0.1 11211 [提示错误:&apos;telnet&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。] 注：windows7带有telnet，只是默认没有安装而已。 解决方法： 依次打开“开始”→“控制面板”→“打开或关闭Windows功能”，在打开的窗口处，寻找并勾选“Telnet客户端”，然后点击“确定”。顺利安装后，再在运行下输入此命令就OK了。 1.开始–&gt;控制面板–&gt;程序和功能 2.左侧 打开或者关闭windows功能 3.找到Telnet客户端，选择安装 5.输入：stats命令查看基本信息。 memcache连接测试运行成功! 1. 下载memcache的windows稳定版，解压放某个盘下面，比如在c:memcached 2. 在终端（也即cmd命令界面）下输入 ‘c:memcachedmemcached.exe -d install’ 安装 3. 再输入： ‘c:memcachedmemcached.exe -d start’ 启动。NOTE: 以后memcached将作为windows的一个服务每次开机时自动启动。这样服务器端已经安装完毕了。 4.下载php_memcache.dll，请自己查找对应的php版本的文件 不同版本的php 所使用的 php_memcache.dll 的版本不一样 如何使用php程序操作我们的memcached服务 curd. 步骤,准备工作. (1)把 php_memcache.dll 文件拷贝 php的ext 下 (2)修改php.ini文件，加载 php_memcache.dll (该文件就是封装了一堆函数) (3)重新启动apache,使用phpinfo()函数查看启用情况。 6.重新启动Apache，然后查看一下phpinfo，如果有memcache，那么就说明安装成功！ memcached的基本设置： memcached服务器安全防护 1.内网访问，2，设置防火墙 ②如何把session数据放入到memcached服务中. ①在php.ini 文件中 ;把session数据放入memcache session.save_handler = memcache ;这里指定放到哪个memcached服务器 session.save_path = &quot;tcp://127.0.0.1:11211&quot; */ //创建一个mem对象实例 // $mem=new Memcache(); //$mem=new Memcache; // //$mem-&gt;addServer(&apos;127.0.0.1&apos;,11211); // //$mem-&gt;addServer(&apos;127.0.0.1&apos;,11222); // $mem-&gt;connect(&quot;127.0.0.1&quot;,11211)or die(&quot;connect failed&quot;); // echo $mem-&gt;set(&apos;name&apos;,123456,MEMCACHE_COMPRESSED,time()+31*3600*24)?&quot;add success!&quot;:&quot;add failed!&quot;;//添加 // $mem-&gt;replace(&apos;name&apos;,&apos;abcdef&apos;);//修改 // echo $mem-&gt;get(&apos;name&apos;); die; // // echo $mem-&gt;delete(&apos;name&apos;)?&apos;ok&apos;:&apos;no&apos;;//删除 // $mem-&gt;flush();//删除 //连接Memcache $mem = new Memcache; $mem-&gt;connect(&quot;localhost&quot;, 11211) or die(&quot;链接失败！&quot;);//保存数据 $mem-&gt;set(&apos;key1&apos;, &apos;This is first value&apos;, 0, 60); $val = $mem-&gt;get(&apos;key1&apos;); echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;;//替换数据 $mem-&gt;replace(&apos;key1&apos;, &apos;This is replace value&apos;, 0, 60); $val = $mem-&gt;get(&apos;key1&apos;); echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;;//保存数组 $arr = array(&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;, &apos;ddd&apos;); $mem-&gt;set(&apos;key2&apos;, $arr, 0, 60); $val2 = $mem-&gt;get(&apos;key2&apos;); echo &quot;Get key2 value: &quot;; print_r($val2); echo &quot;&lt;br /&gt;&quot;;//删除数据 $mem-&gt;delete(&apos;key1&apos;); $val = $mem-&gt;get(&apos;key1&apos;); echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;;//清除所有数据 $mem-&gt;flush(); $val2 = $mem-&gt;get(&apos;key2&apos;); echo &quot;Get key2 value: &quot;; print_r($val2); echo &quot;&lt;br /&gt;&quot;;//关闭连接 $mem-&gt;close(); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Memcache教程-!/]]></content>
      <categories>
        <category>Memcache笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据两点经纬度计算距离！]]></title>
    <url>%2F2016%2F08%2F16%2F%E6%A0%B9%E6%8D%AE%E4%B8%A4%E7%82%B9%E7%BB%8F%E7%BA%AC%E5%BA%A6%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%EF%BC%81%2F</url>
    <content type="text"><![CDATA[这些经纬线是怎样定出来的呢？地球是在不停地绕地轴旋转（地轴是一根通过地球南北两极和地球中心的假想线），在地球中腰画一个与地轴垂直的大圆圈，使圈上的每一点都和南北两极的距离相等，这个圆圈就叫作“赤道”。在赤道的南北两边，画出许多和赤道平行的圆圈，就是“纬圈”；构成这些圆圈的线段，叫做纬线。我们把赤道定为纬度零度，向南向北各为90度，在赤道以南的叫南纬，在赤道以北的叫北纬。北极就是北纬90度，南极就是南纬90度。纬度的高低也标志着气候的冷热，如赤道和低纬度地地区无冬，两极和高纬度地区无夏，中纬度地区四季分明。其次，从北极点到南极点，可以画出许多南北方向的与地球赤道垂直的大圆圈，这叫作“经圈”；构成这些圆圈的线段，就叫经线。公元1884平面坐标图年，国际上规定以通过英国伦敦近郊的格林尼治天文台的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”。在它东面的为东经，共180度；在它西面的为西经，共180度。因为地球是圆的，所以东经180度和西经180度的经线是同一条经线。各国公定180度经线为“国际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离。 每一经度和纬度还可以再细分为60分，每一分再分为60秒以及秒的小数。利用经纬线，我们就可以确定地球上每一个地方的具体位置，并且把它在地图或地球仪上表示出来。例如问北京的经纬度是多少？我们很容易从地图上查出来是东经116度24分，北纬39度54分。在大海中航行的船只，只要把所在地的经度测出来，就可以确定船在海洋中的位置和前进方向。 纬度共有90度。赤道为0度，向两极排列，圈子越小，度数越大。横线是纬度，竖线是经度。当然可以计算，四元二次方程。经度和纬度都是一种角度。经度是个两面角，是两个经线平面的夹角。因所有经线都是一样长，为了度量经度选取一个起点面，经1884年国际会议协商，决定以通过英国伦敦近郊、泰晤士河南岸的格林尼治皇家天文台（旧址）的一台主要子午仪十字丝的那条经线为起始经线，称为本初子午线。本初子午线平面是起点面，终点面是本地经线平面。某一点的经度，就是该点所在的经线平面与本初子午线平面间的夹角。在赤道上度量，自本初子午线平面作为起点面，分别往东往西度量，往东量值称为东经度，往西量值称为西经度。由此可见，一地的经度是该地对于本初子午线的方向和角距离。本初子午线是0°经度，东经度的最大值为180°，西经度的最大值为180°，东、西经180°经线是同一根经线，因此不分东经或西经，而统称180°经线。 纬度是个线面角。起点面是赤道平面，线是本地的地面法线。所谓法线，即垂直于参考扁球体表面的线。某地的纬度就是该地的法线与赤道平面之间的夹角。纬度在本地经线上度量，由赤道向南、北度量，向北量值称为北纬度，向南量值称为南纬度。由此可见，一地的纬度是该地对于赤道的方向和角距离。赤道是0°纬线，北纬度的最大值为90°，即北极点；南纬度的最大值为90°，即南极点。经纬度互换 度(DDD)：E 108.90593度 N 34.21630度 如何将度(DDD):： 108.90593度换算成度分秒(DMS)东经E 108度54分22.2秒?转换方法是将108.90593整数位不变取108(度),用0.9059360=54.3558,取整数位54(分),0.355860=21.348再取整数位21(秒),故转化为108度54分21秒. 同样将度分秒(DMS):东经E 108度54分22.2秒 换算成度(DDD)的方法如下:108度54分22.2秒=108+(54/60)+(22.2/3600)=108.90616度 因为计算时小数位保留的原因，导致正反计算存在一定误差，但误差影响不是很大。1秒的误差就是几米的样子。GPS车友可以用上述方法换算成自己需要的单位坐标。 经纬度换算成米 纬度分为60分，每一分再分为60秒以及秒的小数。 纬度线投射在图上看似水平的平行线，但实际上是不同半径的圆。有相同特定纬度的所有位置都在同一个纬线上。赤道的纬度为0°，将行星平分为南半球和北半球。纬度是指某点与地球球心的连线和地球赤道面所成的线面角，其数值在0至90度之间。位于赤道以北的点的纬度叫北纬，记为N，位于赤道以南的点的纬度称南纬，记为S。纬度数值在0至30度之间的地区称为低纬地区，纬度数值在30至60度之间的地区称为中纬地区，纬度数值在60至90度之间的地区称为高纬地区。赤道、南回归线、北回归线、南极圈和北极圈是特殊的纬线。纬度1秒的长度地球的子午线总长度大约40008km。平均：纬度1度 = 大约111km纬度1分 = 大约1.85km纬度1秒 = 大约30.9m 根据地球上任意两点的经纬度计算两点间的距离 地球是一个近乎标准的椭球体，它的赤道半径为6378.140千米，极半径为 6356.755千米，平均半径6371.004千米。如果我们假设地球是一个完美的球体，那么它的半径就是地球的平均半径，记为R。如果以0度经线为基 准，那么根据地球表面任意两点的经纬度就可以计算出这两点间的地表距离（这里忽略地球表面地形对计算带来的误差，仅仅是理论上的估算值）。设第一点A的经 纬度为(LonA, LatA)，第二点B的经纬度为(LonB, LatB)，按照0度经线的基准，东经取经度的正值(Longitude)，西经取经度负值(-Longitude)，北纬取90-纬度值(90- Latitude)，南纬取90+纬度值(90+Latitude)，则经过上述处理过后的两点被计为(MLonA, MLatA)和(MLonB, MLatB)。那么根据三角推导，可以得到计算两点距离的如下公式：123C = sin(MLatA)*sin(MLatB)*cos(MLonA-MLonB) + cos(MLatA)*cos(MLatB)Distance = R*Arccos(C)*Pi/180 这里，R和Distance单位是相同，如果是采用6371.004千米作为半径，那么Distance就是千米为单位，如果要使用其他单位，比如mile，还需要做单位换算，1千米=0.621371192mile 如果仅对经度作正负的处理，而不对纬度作90-Latitude(假设都是北半球，南半球只有澳洲具有应用意义)的处理，那么公式将是：123C = sin(LatA)*sin(LatB) + cos(LatA)*cos(LatB)*cos(MLonA-MLonB)Distance = R*Arccos(C)*Pi/180 以上通过简单的三角变换就可以推出。 如果三角函数的输入和输出都采用弧度值，那么公式还可以写作：123C = sin(LatA*Pi/180)*sin(LatB*Pi/180) + cos(LatA*Pi/180)*cos(LatB*Pi/180)*cos((MLonA-MLonB)*Pi/180)Distance = R*Arccos(C)*Pi/180 也就是：1234C = sin(LatA/57.2958)*sin(LatB/57.2958) + cos(LatA/57.2958)*cos(LatB/57.2958)*cos((MLonA-MLonB)/57.2958)Distance = R*Arccos(C) = 6371.004*Arccos(C) kilometer = 0.621371192*6371.004*Arccos(C) mile = 3958.758349716768*Arccos(C) mile 在实际应用当中，一般是通过一个个体的邮政编码来查找该邮政编码对应的地区中心的经纬度，然 后再根据这些经纬度来计算彼此的距离，从而估算出某些群体之间的大致距离范围(比如酒店旅客的分布范围-各个旅客的邮政编码对应的经纬度和酒店的经纬度所 计算的距离范围-等等)，所以，通过邮政编码查询经纬度这样一个数据库是一个很有用的资源。附：C#代码： 12345678910111213141516171819private const double EARTH_RADIUS = 6378.137;//地球半径private static double rad(double d)&#123; return d * Math.PI / 180.0;&#125; public static double GetDistance(double lat1, double lng1, double lat2, double lng2)&#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2);double s = 2 * Math.Asin(Math.Sqrt(Math.Pow(Math.Sin(a/2),2) + Math.Cos(radLat1)*Math.Cos(radLat2)*Math.Pow(Math.Sin(b/2),2))); s = s * EARTH_RADIUS; s = Math.Round(s * 10000) / 10000; return s;&#125; 最近用到了geohash（参考《geohash：用字符串实现附近地点搜索》）来实现附近搜索的功能，在《微信、陌陌架构方案分析》文中提供了一个php的geohash类直接能对经纬地址编码成字符串, 而其中包含一个getDistance方法获取两点间的距离，但在sphinx中使用过滤附近地标的方法SetGeoAnchor发现返回的距离值有误，遂google出以下方法，经测试可用。。 1234567891011121314151617181920212223/*** @desc 根据两点间的经纬度计算距离* @param float $lat 纬度值* @param float $lng 经度值*/ /** * @desc 根据两点间的经纬度计算距离 * @param float $lat 纬度值 * @param float $lng 经度值 * @return $result 单位为千米（km） */ public function getDistance($lat1, $lng1, $lat2, $lng2)&#123; $earthRadius = 6367000; //approximate radius of earth in meters // Convert these degrees to radians to work with the formula $lat1 = ($lat1 * pi() ) / 180; $lng1 = ($lng1 * pi() ) / 180; $lat2 = ($lat2 * pi() ) / 180; $lng2 = ($lng2 * pi() ) / 180; // Using the Haversine formula http://en.wikipedia.org/wiki/Haversine_formula calculate the distance $calcLongitude = $lng2 - $lng1; $calcLatitude = $lat2 - $lat1; $stepOne = pow(sin($calcLatitude / 2), 2) + cos($lat1) * cos($lat2) * pow(sin($calcLongitude / 2), 2); $stepTwo = 2 * asin(min(1, sqrt($stepOne))); $calculatedDistance = $earthRadius * $stepTwo; return round($calculatedDistance); &#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/根据两点经纬度计算距离！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php操作redis笔记！]]></title>
    <url>%2F2016%2F08%2F16%2Fphp%E6%93%8D%E4%BD%9CRedis%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 //验证是否安装OK:打开dos窗口-&gt;输入redis-server 在打开一个dos窗口--&gt;输入redis-cli 显示：127.0.0.1:6379&gt;则成功！ $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, &apos;6379&apos;) || die(&quot;连接失败！&quot;); $redis-&gt;auth(&quot;admin&quot;); //授权 //******************************string类型********************************************************** //String 是最简单的类型，一个Key对应一个Value，String类型是二进制安全的。Redis的String可以包含任何数据，比如jpg图片或者序列化的对象 //$redis-&gt;set(&apos;test&apos;, 200); //赋值 //$redis-&gt;mset(array(&apos;key0&apos; =&gt; &apos;value0&apos;, &apos;key1&apos; =&gt; &apos;value1&apos;));//批量赋值 //$redis-&gt;mget(array(&apos;key0&apos;, &apos;key1&apos;, &apos;key2&apos;));//批量获取值 //$redis-&gt;setnx(&apos;key&apos;,value);//设置key对应的值为string类型的value,如果key已经存在，返回0,nx是not exist的意思 //$redis-&gt;msetnx(array(&apos;key0&apos; =&gt; &apos;value0&apos;, &apos;key1&apos; =&gt; &apos;value1&apos;));//全部成功返回1，否则失败一个也返回0 //$redis-&gt;getset(&quot;key&quot;,&apos;newvalue&apos;);//getset设置key的值，并返回key的旧值 //$redis-&gt;setex(&apos;key&apos;,10,&apos;value10&apos;);//带生存时间的写入值单位s //$redis-&gt;setrange(&apos;key&apos;,0,&apos;hello&apos;);//设置子字符串替换，key，开始位置，替换值 //$redis-&gt;getrange(&quot;key&quot;,0,2);//getrange获取子字符串，getrange key start end //$redis-&gt;ttl(&apos;key&apos;);//获取key的生存时间,没设置的为-1 //$redis-&gt;keys(&quot;*a*&quot;);//获取所有key，也可获取具体key，模糊匹配key //$redis-&gt;get(&quot;test&quot;); //根据key获取value //$redis-&gt;getMultiple(array(&apos;key1&apos;, &apos;key2&apos;, &apos;key3&apos;)); //$exits = $redis-&gt;exists(&apos;test&apos;); //判断key是否存在。存在 true 不存在 false //echo $exists?$res2:&quot;null&quot;; // echo $res1?$res2:&quot;null&quot;;die; //$redis-&gt;delete(&apos;key1&apos;, &apos;key2&apos;); //删除,可删除多个 //$redis-&gt;delete(array(&apos;key3&apos;, &apos;key4&apos;, &apos;key5&apos;));//删除,可删除多个 //$redis-&gt;delete( $redis-&gt;keys(&quot;*&quot;));//传数组，删除所有key //$redis-&gt;incr(&quot;key&quot;,1);//自增，默认值1 //$redis-&gt;incrBy(&apos;key&apos;,10);//必须给定参数值 //$redis-&gt;decr(&quot;key&quot;,10);//自减，默认值1 //$redis-&gt;decrBy(&apos;key&apos;,10);//必须给定参数值 //$redis-&gt;append(&quot;key&quot;,&quot;appendvalue&quot;);//给指定的key的字符串追加value,返回新字符串的长度 //$redis-&gt;strlen(&apos;key&apos;);//获取指定key的字符串长度 //******************************string类型********************************************************** //******************************hash类型********************************************************** // Redis hash是一个string类型的field和value的映射表。它的添加删除都是0(1) // hash特别适合用于存储对象。相对于将对象的每个字段存成单个string类型。 //将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。 // $redis-&gt;flushall();die;//清空所有数据库 // $redis-&gt;flushdb();die;//清空当前数据库 //$redis-&gt;hset(&quot;test&quot;,&quot;username&quot;,&quot;admin&quot;);//单个设置 //$redis-&gt;hget(&quot;test&quot;,&quot;username&quot;);//单个获取 //$redis-&gt;hsetnx(&quot;test&quot;,&quot;username&quot;,&quot;admin@qq.com&quot;);//设置hash field 为指定的值value,如果feild已经存在，返回0,nx是not exist的意思 //$redis-&gt;hmset(&quot;testabc&quot;,array(&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2,&quot;c&quot;=&gt;3,&apos;d&apos;=&gt;4));//批量设置 //$redis-&gt;hmget(&quot;testabc&quot;,array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));//批量获取 //$redis-&gt;hincrBy(&quot;test&quot;,&quot;password&quot;,&quot;123456&quot;);//设置hash field 添加key和value //$redis-&gt;hexists(&quot;test&quot;,&quot;usernames&quot;);//测试hash field 存在1，不存在0 //$redis-&gt;hlen(&quot;test&quot;); //返回hash 里所有的 field 的数量 //$redis-&gt;hdel(&quot;test&quot;,&quot;key&quot;);//删除指定hash的field //$redis-&gt;hkeys(&quot;test&quot;); //返回hash 所有 field //$redis-&gt;hvals(&quot;test&quot;);//返回hash 所有 field values //$redis-&gt;hgetall(&quot;test&quot;);//获取hash中全部的field和value //******************************hash类型********************************************************** //******************************list链表********************************************************** //輚先进后出；队列先进先出； //List 是一个链表结构，主要功能是push,pop,获取一个范围的所有值等等，操作中key理解为链表的名字。 //Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push,pop操作从链表的头部或者尾部添加删除元素，这样LIST既可以作为栈，又可以作为队列。 //$redis-&gt;lrange(&quot;list&quot;,0,-1);//取链表list 从0位开始取到最后位置；0代表头 -1代表尾 //$redis-&gt;lpush(&quot;list&quot;,&quot;1&quot;); //在key对应的list的头部添加字符串元素 //$redis-&gt;rpush(&quot;list&quot;,&quot;test&quot;); //在key对应的list的尾部添加字符串元素 //$redis-&gt;lpop(&quot;list&quot;);//在key对应的list的头部删除字符串元素，并返回删除字符 //$redis-&gt;rpop(&quot;list&quot;);//在key对应的list的尾部删除字符串元素，并返回删除字符 // echo $redis-&gt;lrem(&quot;list&quot;,2,&apos;key&apos;);//在list中删除N个和value相同的元素(n&lt;0从尾删除,n=0全部删除),返回的值为删除的个数 //$redis-&gt;lset(&quot;list&quot;,-1,&quot;啊&quot;);//设置list中指定下标的元素值 lset(list,位置，值)，位置可以从头或者从尾 //$redis-&gt;lindex(&quot;list&quot;,0);//返回list中index位置的元素 //$redis-&gt;llen(&quot;list&quot;);//返回list的长度 //$redis-&gt;ltrim(&quot;list&quot;,0,1);//保留指定key的值的范围内的数据 0为头 -1为尾 //$redis-&gt;linsert(&quot;list&quot;);//******** //$redis-&gt;rpoplpush(&quot;list&quot;,&quot;listt&quot;);//从第一个LIST的尾部移除元素并添加到第二个LIST的头部 //******************************list链表********************************************************** //******************************set集合********************************************************** // Set是集合，它是string类型的无序集合。set是通过hash table实现的，添加，删除和查找的复杂程度都是0(1) // 对集合我们可以取并集，交集，差集。通过这些操作我们可以实现SNS中的好友推荐和blog的tag功能 //$redis-&gt;sadd(&quot;col&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//向集合中添加元素 //$redis-&gt;smembers(&quot;col&quot;);//集合元素列表 //$redis-&gt;srem(&quot;col&quot;,&apos;d&apos;);//集合移除元素 //$redis-&gt;spop(&quot;col&quot;);//随机删除集合元素并返回删除的元素。删除最后一个元素时，则集合也被删除 //$redis-&gt;sdiff(&quot;set1&quot;,&quot;set2&quot;);//取多个集合的差集，谁在前面已谁为标准（差集就是前面第一个集合有而后面所有集合都没有） //$redis-&gt;sdiffstore(&quot;dif&quot;,&quot;set1&quot;,&quot;set2&quot;);//返回多个集合的差集，存在第三个集合里面 //$redis-&gt;sinter(&quot;set&quot;,&quot;set1&quot;,&apos;set2&apos;);//交集（所有集合都有的元素） //$res = $redis-&gt;sinterstore(&quot;inter&quot;,&quot;set&quot;,&quot;set1&quot;);///取多个集合的交集,存在第三个集合里面 //$redis-&gt;sunion(&quot;set&quot;,&quot;set1&quot;,&apos;set2&apos;);//并集（所有集合合并去重的元素） //$redis-&gt;sunionstore(&quot;union&quot;,&quot;set&quot;,&quot;set1&quot;);///取多个集合的并集,存在第三个集合里面 //$redis-&gt;smove(&quot;set1&quot;,&quot;set2&quot;,&quot;value&quot;);///第一个集合元素剪切到第二个集合里面。 //$redis-&gt;scard(&quot;set&quot;);//返回集合中元素的个数 //$redis-&gt;sismember(&quot;set&quot;,&quot;value&quot;);//判断某个元素是否为集合的元素 //$redis-&gt;srandmember(&quot;set&quot;);//随机返回集合内的一个元素，不会删除元素 // $redis-&gt;keys(&quot;*&quot;); //返回所有key// $redis-&gt;keys(&quot;*t&quot;); //返回所有s开头的key// $res = $redis-&gt;keys(&quot;*&quot;);// foreach ($res as $k =&gt; $v) &#123;// echo $v.&quot;=&gt;&quot;.$redis-&gt;get($v).&quot;&lt;br&gt;&quot;;// &#125;// $redis-&gt;exists(&quot;set&quot;); //判断该key是否存在// $redis-&gt;del(&quot;inter&quot;); //删除该key // $redis-&gt;expire(&quot;set2&quot;,100); //设置key 过期时间10s// $redis-&gt;ttl(&quot;set3&quot;);//查看过期剩余时间s //$redis-&gt;select(&quot;1&quot;);// 选择数据库 //$redis-&gt;set(&quot;name&quot;,&quot;test&quot;);// 设置key=&gt;value //$redis-&gt;get(&quot;name&quot;);// 根据key获取value //$redis-&gt;move(&quot;get&quot;,1);// 把key移到另一个数据库 //$redis-&gt;persist(&quot;set2&quot;);// 移除过期时间 //$redis-&gt;randomkey();//随机返回一个key //$redis-&gt;rename(&quot;names&quot;,&quot;newname&quot;);//重命名key //$redis-&gt;type(&quot;zset&quot;);//获取key类型 //$redis-&gt;dbsize();//获取数据库key个数 //$redis-&gt;info();//获取redis服务信息 //$redis-&gt;echo(&quot;hello，world&quot;);//输出函数 //******************************set集合********************************************************** //redis有五大数据类型 //字符串 string //hash 表 //链表结构 list //set 集合(无序) //zset 有序集合 //string来存储用户的最大id,用来id的自增 //hash 表来存储用户的详细信息 //list链表结构来存储用户的id号 // $uid = $redis-&gt;incr(&quot;blog:id&quot;); //自增长// $res = $redis-&gt;hmset(&apos;blog:user:&apos; . $uid, array(&apos;id&apos; =&gt; $uid, &apos;username&apos; =&gt; &apos;admin&apos;.time() . time(), &apos;password&apos; =&gt; md5(time()))); //hash表插入一条记录// $redis-&gt;rpush(&quot;blog:uid&quot;, $uid);// // // $res = $redis-&gt;hgetall(&quot;blog:user:&quot;.$uid);// $redis-&gt;del(&quot;blog:user:&quot;.$uid);//删除用户// $redis-&gt;lrem(&quot;blog:uid&quot;,$uid);//删除链表中的id // print_R($res);die; // $count = $redis-&gt;lsize(&quot;blog:uid&quot;); //list类型count总数 // $page_size = 3;// $page_num = !empty($_GET[&apos;page&apos;]) ? $_GET[&apos;page&apos;] : 1;// $page_count = ceil($count / $page_size);// $ids = $redis-&gt;lrange(&quot;blog:uid&quot;, ($page_num - 1) * $page_size, (($page_num - 1) * $page_size + $page_size - 1));//// foreach ($ids as $v) &#123;//// $ress[] = $redis-&gt;hgetall(&quot;blog:user:&quot; . $v); //获取记录 // &#125;// echo&quot;&lt;pre&gt;&quot;;// print_R($ress); // echo&apos;&lt;script&gt;setTimeout(&quot;window.location.reload()&quot;,1000); //指定1秒刷新一次&lt;/script&gt;&apos;; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/php操作Redis笔记！/]]></content>
      <categories>
        <category>Redis笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统二次架构实现！]]></title>
    <url>%2F2016%2F08%2F16%2F%E7%B3%BB%E7%BB%9F%E4%BA%8C%E6%AC%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[新系统文档说明报告人：Robot 时间：2014-09-11由于现有系统越来越难以满足日益变更的需求，经研究讨论，决定对系统进行二架构，针对二期架构中用到的一些技术方案及架构实现，本人翻阅查找资料，做出了如下总结，并且结合公司当前的业务需求对每项方案附上自己的一些个人意见，下面开始介绍： 1、分表方案(水平，垂直)背景说明：海量数据下，提高访问性能分表方案：方案一：hash取模分表说明：预先估计会出现大数据量并且访问频繁的表，将其分为N个表，这样的表我们事先在数据库建好，具体建多少张，视情况而定，数据表建好以后，然后根据SKUID判断该条记录存储在哪张表中，表名我们可以用取模、其他hash算法等方式获得优点：直接得出目标表名称，效率高缺点：需要预先固定一个表数量，扩展性稍差，当确定一个规则，选择了一个hash算法后，重新想更改一个hash算法，会造成数据混乱，同一条数据存储在多张表中方案二：按区间范围分表说明：按每个表固定记录行数拆分,每张表存储指定数量的数据。一张表的数据行数到了指定数量，就自动保存到新的表里优点：数据表的数量可控缺点：确定一个数量后，只能在这个数量数量上操作，如重新定义数量，则同一条数据可能存在多张数据表中，数据混乱方案三：按日期时间分表说明：对于那种根据时间增长较快的数据可以按时间拆分，根据业务实际情况按天、按月、按年等进行拆分，数据有较强的时效性，比如发送消息记录等，这种数据用户很少查询几个月的数据，如就可以按月分表缺点：分表方式有一定的局限性方案四：利用merge存储引擎分表说明：适合事先未考虑大数据，当数据量达到一定程度，出现数据查询慢的情况，这个时候要把大数据表分开是比较麻烦的优点：扩展性好，程序代码改动不是很大缺点：只能在相同结构的 MyISAM 表上使用，无法享受到 MyISAM 的全部功能，例如无法在 MERGE 类型上执行 FULLTEXT 搜索，它需要使用更多的文件描述符,读取索引更慢方案五：做mysql集群说明：为一个数据库减轻负担,减少SQL队列的SQL量优点：扩展性好，没有分表后的复杂操作缺点：单个表的数据量没变，硬件开销大 个人建议：建议选择方案二，因为方案二数据表的数量可控，只要数据达到一定的存储数量，就自动保存新的表里，相比于方案一而言，扩展性更强，条件允许可以配合使用方案五 2、NOSQL背景说明：关系型数据库在数据大到一定数量时，高并发时，出现瓶颈，使用nosqlNOSQL数据库：Redis、MongoDB、CouchDB、Riak、Membase、Neo4j、Cassandra、HBase等详细说明： 重点介绍Redis、MongoDB两种nosql数据库1、性能每秒处理的事物（TPS）数量方面，redis非常高，优于mongodb2、可操作性redis数据类型丰富，较少的IO，mongodb丰富的数据表达、索引，支持更丰富的查询语言，最类似于关系型数据库（mysql、oracle等）3、可靠性redis依赖快照进行持久化,AOF增强可靠性；,强可靠性的同时，影响访问性能,mongodb从1.8版本后，采用binlog方式（MySQL同样采用该方式）支持持久化，增加可靠性，mongodb由于redis4、一致性redis支持事物，比较弱，仅能保证事物中的操作按顺序执行，mongodb则不支持，redis由于mongodb 个人建议：建议使用redis，因为做数据分析（新项目可以使用）时，数据变化很快，读写操作相当频繁，而redis的TPS是非常高的，mongodb相对弱，因此建议使用redis 3、Sphinx简介说明：Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文检索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。功能说明：手册配置http://www.coreseek.cn/docs/coreseek_3.2-sphinx_0.9.9.html使用场景：商品搜索（注：当前开发项目）个人建议：1、现阶段由于商品数据较少，不适合做增量索引更新，因为如果现在做增量索引更新的话，到后期新增的数据是越来越大的，导致增量更新的数据很大，而原始数据较小，因此我们可以采用实时索引搜索的方式，即每次数据更新后，都重新建立索引2、待到数据量达到一定程度的时候（具体待定），这个时候原始数据比较大了，显然继续采用实时索引，每次数据更新都重建索引，代价太大了，这个时候我们就可以使用主索引+增量索引的方式，即给定一个原始数据，建立一个索引，而为新数据设置另外一个索引，这样就可以快速创建索引，因为增量数据时比较小的，查询的时候我们将主索引与增量索引合并，这样子是比重新建索引要快的 4、服务器架构架构方案：主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力，然后配合缓存、页面静态化、负载均衡(DNS轮询，CDN架构)、图片服务器分离提升访问性能，提高负载能力详细说明：1、主从复制、读写分离：定义一台或多台主服务器，然后在各自的下面配好各自的从服务器，写入数据的时候，只写主服务器，然后主服务器做好数据同步，同步数据到从服务器，读取的时候，只到从服务器中去数据2、页面静态化：对一些基本不怎么更新的页面，或者更新数据量很小(不频繁更改)，且数据不是很重要的页面，我们可以定时静态化（比如商城中的帮助、新闻页面）3、图片服务器分离：图片的读取是比较耗资源的，因此建议分离，但是图片分离后，因此衍生出上传、同步问题，上传可以通过写一个ftp的上传程序实现，如果是多台服务器的话，如果文件有写入、删除操作，实时同步图片，单台服务器就不需要如此了4、memcache缓存：A、建议使用memcache缓存，memcache的读写性能优异，高并发时尤为突出，但是不能永久存储，且有内存限制，最坏的结果可能就是缓存数据丢失B、memcache集群数据同步：Memcached作为集中式缓存服务端，其本身是单实例的并没有分布式功能，各个Memcached不会互相通信以共享信息，为了防止当其中的一台节点宕机而造成数据丢失（单点现象），我们可以采用Magent缓存代理，缓存代理服务器可以连接多台Memcached机器可以将每台Memcached机器进行数据同步。这样的架构比较完善了，如果其中一台缓存代理服务器down机，系统依然可以继续工作，如果其中一台Memcached机器down掉，数据不会丢失并且可以保证数据的完整性。 以上是服务器架构的个人建议 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/系统二次架构实现！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-curl_post获取不到返回结果问题！]]></title>
    <url>%2F2016%2F08%2F16%2Fphp-curl_post%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%97%AE%E9%A2%98%EF%BC%81%2F</url>
    <content type="text"><![CDATA[####post数据到远程服务器，获取返回数据。通过代码时而有数据，时而无。print_R（）返回为空，用var_dump（）打印出来是string(0) “” ,用FireFox的Httprequester工具，请求结果正确！最后找到问题所在，用的封装curl_postData（）函数有问题。从 http://php.net/manual/zh/function.curl-exec.php 上获取代码，结果就ok了！这个坑踩的冤！！ 1234567891011121314151617181920212223242526272829 /** * Send a POST requst using cURL * @param string $url to request * @param array $post values to send * @param array $options for cURL * @return string */ function curl_post($url, array $post = NULL, array $options = array()) &#123; $defaults = array( CURLOPT_POST =&gt; 1, CURLOPT_HEADER =&gt; 0, CURLOPT_URL =&gt; $url, CURLOPT_FRESH_CONNECT =&gt; 1, CURLOPT_RETURNTRANSFER =&gt; 1, CURLOPT_FORBID_REUSE =&gt; 1, CURLOPT_TIMEOUT =&gt; 4, CURLOPT_POSTFIELDS =&gt; http_build_query($post) ); $ch = curl_init(); curl_setopt_array($ch, ($options + $defaults)); if( ! $result = curl_exec($ch)) &#123; trigger_error(curl_error($ch)); &#125; curl_close($ch); return $result; &#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/php-curl_post获取不到返回结果问题！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php操作MongoDB笔记！]]></title>
    <url>%2F2016%2F08%2F16%2FPHP%E6%93%8D%E4%BD%9CMongoDB%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//连接mongodb数据库$conn = new MongoClient();//选择数据库和文档集合$db = $conn-&gt;mydb; #选择mydb数据库 $db = $conn-&gt;selectDB(“mydb”); #选择mydb数据库 第二种写法$collection = $db-&gt;test; #选择集合(选择’表’)$db-&gt;selectCollection(‘column’); #选择集合(选择’表’)第二种写法$collection = $conn-&gt;local-&gt;User;#更简洁的写法，一步到位#插入一条记录$res = $collection-&gt;insert(array(&quot;id&quot;=&gt;1,&quot;username&quot;=&gt;&quot;admin&quot;,&quot;age&quot;=&gt;18,&quot;email&quot;=&gt;&quot;admin@qq.com&quot;));#根据条件更新数据$res = $collection-&gt;update(array(&quot;username&quot;=&gt;&quot;admin&quot;),array(&quot;$set&quot;=&gt;array(&quot;age&quot;=&gt;25)));#根据条件删除数据$res = $collection-&gt;remove(array(&quot;username&quot;=&gt;&quot;test&quot;));#查询一条记录$res = $collection-&gt;findOne(array(&quot;username&quot;=&gt;&quot;admin&quot;));#查询 $res = $collection-&gt;find();#根据正则查询符合条件数据$res = $collection-&gt;find(array(&quot;username&quot;=&gt;new MongoRegex(&quot;/admin/i&quot;)));//db.User.find(&#123;&quot;username&quot;:/admin/i&#125;) #原生态模糊查询（/XXX/i 正则忽略大小写）#统计数量$res = $collection-&gt;count();#带条件的统计$res = $collection-&gt;count(array(&quot;username&quot;=&gt;new MongoRegex(&quot;/admin/i&quot;)，&apos;age&apos;=&gt;array(&apos;$gt&apos;=&gt;21,&apos;$lt&apos;=&gt;80)));#带条件的统计另一种写法$res = $collection-&gt;find(array(&quot;username&quot;=&gt;new MongoRegex(&quot;/admin/i&quot;)，&apos;age&apos;=&gt;array(&apos;$gt&apos;=&gt;21,&apos;$lt&apos;=&gt;80)))-&gt;count(); #注:$gt为大于、$gte为大于等于、$lt为小于、$lte为小于等于、$ne为不等于、$exists不存在 #分页取数据$count = $collection-&gt;find()-&gt;limit(10)-&gt;skip(10)-&gt;count(true);//#获得实际返回的结果数 （count()或count(0)或count(false)返回全部数据，count(1)或count(true)返回分页数据）//true显示列，false隐藏列 sort排序：-1=desc 1=asc$res = $collection-&gt;find(array(&apos;age&apos; =&gt; array(&apos;$gt&apos; =&gt; 23, &apos;$lt&apos; =&gt; 93)))-&gt;fields(array(&quot;age&quot; =&gt; true, &quot;_id&quot; =&gt; false))-&gt;sort(array(&apos;age&apos; =&gt; -1));/** 创建索引 $collection-&gt;ensureIndex(array(&apos;age&apos; =&gt; 1,&apos;type&apos;=&gt;-1)); #1表示降序 -1表示升序$collection-&gt;ensureIndex(array(&apos;age&apos; =&gt; 1,&apos;type&apos;=&gt;-1),array(&apos;background&apos;=&gt;true)); #索引的创建放在后台运行(默认是同步运行)$collection-&gt;ensureIndex(array(&apos;age&apos; =&gt; 1,&apos;type&apos;=&gt;-1),array(&apos;unique&apos;=&gt;true)); #该索引是唯一的*/******************************************mongodb复制远程数据库和表start****************************************************************** $con1 = new Mongo(&quot;mongodb://192.168.1.243:7788&quot;); // 连接到服务器 $con2 = new Mongo(&quot;mongodb://127.0.0.1:27017&quot;); // 连接到本地 $db1 = $con1-&gt;ak_sys; $db2 = $con2-&gt;ak_sys; $res1 = $db1-&gt;feedback-&gt;find(); foreach ($res1 as $k =&gt; $v) &#123; //echo&quot;&lt;pre&gt;&quot;;print_R($v); $res2 = $db2-&gt;feedback-&gt;insert($v);#简单插入 echo $res2[&apos;ok&apos;]? &apos;success&apos; : &apos;failed&apos;; echo &quot;&lt;br/&gt;&quot;; &#125;******************************************mongodb复制远程数据库和表end************************************************************************************************************where条件可以用js函数方式start****************************************************************** $where[&apos;$where&apos;] = &quot; function()&#123; var pos_code = this.pos_code; var count= this.count; if(pos_code ==&apos;d&apos; &amp;&amp; count==0)&#123; return true; &#125; &#125;&quot;; $res = $db2-&gt;feedback-&gt;find($where);*******************************************where条件可以用js函数方式end******************************************************************日期转换时间戳，再用mongoDate函数：new MongoDate(strtotime(date(&quot;Y-m-d H:i:s&quot;))); demo： $start = new MongoDate(strtotime(date(&quot;2011-02-15 00:00:00&quot;))); $end = new MongoDate(strtotime(date(&quot;2017-12-15 23:59:59&quot;))); 查询分组统计 $where[&apos;$match&apos;] = array( &apos;click_time&apos; =&gt; array(&apos;$gt&apos; =&gt; $start, &apos;$lte&apos; =&gt; $end)); //管道效应：group中的click_time是where传过来的 $group[&apos;$group&apos;] = array( &apos;_id&apos; =&gt; array( &apos;year&apos; =&gt; array(&apos;$year&apos; =&gt; &apos;$click_time&apos;), &apos;month&apos; =&gt; array(&apos;$month&apos; =&gt; &apos;$click_time&apos;), &apos;day&apos; =&gt; array(&apos;$dayOfMonth&apos; =&gt; &apos;$click_time&apos;) ), &apos;total&apos; =&gt; array(&apos;$sum&apos; =&gt; 1) ); $res = $db2-&gt;test-&gt;aggregate($where, $group); // echo count($res[&apos;result&apos;]);//获取分组后的总数量 // echo&quot;&lt;pre&gt;&quot;;print_R($res); echo $db2-&gt;test-&gt;find(array(&apos;click_time&apos;=&gt;array(&apos;$gte&apos; =&gt; $start, &apos;$lte&apos; =&gt; $end)))-&gt;count(); $res = $db2-&gt;test-&gt;find(array(&apos;click_time&apos; =&gt; array(&apos;$gt&apos; =&gt; $start, &apos;$lte&apos; =&gt; $end)));// foreach ($res[&apos;result&apos;] as $k =&gt; $v) &#123;// $v[&apos;click_time&apos;] = date(&apos;Y-m-d H:i:s&apos;, $v[&apos;click_time&apos;]-&gt;sec);// $v[&apos;create_time&apos;] = date(&apos;Y-m-d H:i:s&apos;, $v[&apos;create_time&apos;]-&gt;sec);// $v[&apos;_id&apos;] = $v[&apos;_id&apos;]-&gt;&#123;&apos;$id&apos;&#125;; //取mongoid字符串// echo&quot;&lt;pre&gt;&quot;;// print_R($v);// &#125;where模糊查询分组排序分页 $op = array( array( &apos;$match&apos; =&gt; array( &apos;click_time&apos; =&gt; array( &apos;$gte&apos; =&gt; $start, &apos;$lte&apos; =&gt; $end ), &apos;pos_code&apos; =&gt; new MongoRegex(&apos;/^dd$/&apos;),//正则匹配pos_code含有dd字符的 &apos;remark&apos; =&gt;&apos;&apos;, //等于空 &apos;title&apos; =&gt; array(&apos;$ne&apos;=&gt;null),//不等于空 )), array( &apos;$group&apos; =&gt; array( &apos;_id&apos; =&gt; array( &apos;dev_id&apos; =&gt; &apos;$dev_id&apos;, &apos;pos_code&apos; =&gt; &apos;$pos_code&apos;, &apos;status&apos; =&gt; &apos;$status&apos;, &apos;title&apos;=&gt;&apos;$title&apos;, &apos;year&apos; =&gt; array(&apos;$year&apos; =&gt; &apos;$click_time&apos;), &apos;month&apos; =&gt; array(&apos;$month&apos; =&gt; &apos;$click_time&apos;), &apos;day&apos; =&gt; array(&apos;$dayOfMonth&apos; =&gt; &apos;$click_time&apos;) ) ) ), array(&apos;$sort&apos; =&gt; array(&apos;click_time&apos; =&gt; -1)), array(&apos;$skip&apos; =&gt; 0), array(&apos;$limit&apos; =&gt; 100), ); $res3 = $db2-&gt;test-&gt;aggregate($op); echo&quot;&lt;pre&gt;&quot;; print_R($res3); die; //$result = $db2-&gt;test-&gt;update(array(&apos;img_url&apos;=&gt;&apos; &apos;),array(&apos;$set&apos;=&gt;array(&quot;pos_code&quot;=&gt;time())));//更新文档 // echo $result ? &apos;success&apos; : &apos;failed&apos;;echo &quot;&lt;br&gt;&quot;;原生态mongodb操作方法： MONGODB:数据库(db)-&gt;集合(table)-&gt;文档(row) D:\mongodb\bin&gt;mongod.exe --dbpath &quot;d:\set up\mongodb\data&quot; //设置mongodb数据路径： D:\mongodb\bin&gt;mongo.exe//启动mongodb &gt;use mydb//创建数据库 返回数据库名称&gt;db mydb//查看数据库信息&gt;show dbs//查看数据库（创建的数据库mydb 列表中是不存在的。要显示的数据库，需要把它插入至少一个文件。） db.movie.insert(&#123;&quot;name&quot;:&quot;tutorials point&quot;&#125;) db.movie.save(&#123;&quot;name&quot;:&quot;tutorials point&quot;&#125;)//保存数据 &gt;use mydb &gt;db.dropDatabase()//删除数据库 &gt;use test //创建集合&#123; 当插入一些文件 MongoDB 自动创建的集合。&#125; &gt;db.createCollection(&quot;mycollection&quot;) &gt;show collections//查看创建集合 &gt;db.集合名称.drop()//删除集合 &gt;db.集合名称.find()//查询集合 &gt;db.hello.find().pretty()//格式化返回集合数据 &gt;db.hello.find(&#123;key1:value1, key2:value2&#125;).pretty()//根据条件查询 AND &gt;db.hello.find(&#123;$or:[&#123;key1:value1&#125;,&#123;key2:value2&#125;]&#125;).pretty()//根据条件查询 OR &gt;db.hello.find(&quot;age&quot;: &#123;$gt:10&#125;, $or: [&#123;&quot;name&quot;: &quot;li&quot;&#125;, &#123;&quot;title&quot;: &quot;book&quot;&#125;] &#125;).pretty()//AND 和 OR //where age &gt;10 and(name=li or title =book ) //可以使用操作符完成更复杂的操作，常用操作符有：$lt , $lte , $gt , $gte ( &lt; , &lt;= , &gt; , &gt;= ), $ne ( &lt;&gt; ) ,$in , $nin , $or , $not, $mod (取模), $exists, $where //db.hello.find( &#123;&quot;age&quot; : &#123; “$lt” : 20 &#125; &#125; ) &gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA)//更新文档值(MongoDB默认将只更新单一的文件，来更新多个你需要设置参数置&apos;multi&apos; 为true) &gt;db.hello.update(&#123;&apos;name&apos;:&apos;lis&apos;&#125;,&#123;$set:&#123;&apos;name&apos;:&apos;dragoners.li&apos;,&apos;age&apos;:23&#125;&#125;) &gt;db.hello.remove(&#123;&apos;name&apos;:&apos;abc&apos;&#125;)//删除记录 &gt;db.hello.remove(&#123;&apos;name&apos;:&apos;abc&apos;&#125;,1)//删除一条记录 &gt;db.hello.remove(&#123;&#125;)//全部删除相当于mysql的truncate &gt;db.hello.find(&#123;&#125;,&#123;&quot;name&quot;:&apos;abc&apos;,_id:0&#125;)//_id：0把_id设置为0.返回。类似mysql的视图。 &gt;db.hello.find().limit(3)//类似mysql的limit(0,3)从0开始取3条记录。（参数不写或写0时返回全部） &gt;db.hello.find().limit(3).skip(2)//类似mysql的limit 限制记录条件，skip忽略前N条记录 //Sort : 排序 -1（降序） 1（升序）； //Count: 记录数 //getIndexes() 获取索引信息// dropIndexes() : 删除所有索引//dropIndex( name )删除某个索引 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/PHP操作MongoDB笔记！/]]></content>
      <categories>
        <category>MongoDB笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpMyAdmin安装图解教程!]]></title>
    <url>%2F2016%2F08%2F16%2FphpMyAdmin%E5%AE%89%E8%A3%85%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B!%2F</url>
    <content type="text"><![CDATA[先下载一份最新版的phpMyAdmin MYSQL管理器 解压后得到一个phpMyAdmin的目录（可以改名） 把文件夹放到网站根目录 找到目录里的config.inc.php文件，打开 找到 $cfg[‘PmaAbsoluteUri’] 修改你将上传到空间的phpMyAdmin的网址 如：$cfg[‘PmaAbsoluteUri’] = ‘http:/localhost/phpmyadmin/‘; 还有下面的 $cfg[‘Servers’][$i][‘host’] = ‘localhost’;（通常用默认，也有例外） $cfg[‘Servers’][$i][‘auth_type’] = ‘config’; // Authentication method (config, http or cookie based)? 在自己的机子里调试用config，如果在网上用cookie。 $cfg[‘Servers’][$i][‘user’] = ‘root’; // MySQL user（用户名，自己机里用root，在网上设你的ftp用户名） $cfg[‘Servers’][$i][‘password’] = ‘’; // MySQL password (only needed 自己机里不用设 $cfg[‘Servers’][$i][‘only_db’] = ‘’; // If set to a db-name, only（你只有一个数据就设置一下） 还有设 $cfg[‘DefaultLang’] = ‘zh’; 设置完毕可以上传到网上了。 浏览http://localhost/phpmyadmin/ 当然你设置不同就用那个网址。 如果设置了cookie（看上面）就会有以下的登陆窗口 登陆后或没有设置cookie就可以进入phpmyadmin的主页面 在左边选择一个表（如cdb_members），可以看到以下 右边的窗口拉下，看到 注意红色圈着的，就是增加字段 你可以一次增加多个字段，也可以选择增加的字段在哪个字段的后面等 如默认的增加一个字段，点击开始，看到 按需要填写 你也可以在选择数据或表后，点击 SQL 进入如图 运行mysql语句来增加或操作mysql。 下面讲备份 选择数据后，点击输出如图 选择要备份的表（可以先选择第一个，然后按着shift键按最后一个，就可以选择从第一个到最后一个的表，或按alt选随意一个） 如图 然后点击开始。 其他的功能大家可以熟悉一下。中文界面应该很容易明白的 注：$cfg[‘blowfish_secret’] = ‘’; 本机的话不需要设置，但是网络的话需要设置成cookie： $cfg[‘blowfish_secret’] = ‘cookie’; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/phpMyAdmin安装图解教程!/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows安装多个mysql做读写分离测试！]]></title>
    <url>%2F2016%2F08%2F16%2FWindows%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AAMYSQL%E5%81%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B5%8B%E8%AF%95%EF%BC%81%2F</url>
    <content type="text"><![CDATA[mysql5.6.35下载地址：https://dev.mysql.com/downloads/file/?id=467063一开始下载的是5.7版本解压版的，搞了很久mysql服务开不起来，网上也没找到有效的解决办法。退回5.6安装一次点亮！步骤如下：一.下载解压重命名，拷贝多份用端口号区分，在虚拟机win7 C盘下做实验： 二.my-default.ini拷贝一份改名my.ini，打开修改basedir（mysql安装目录）和datadir（数据目录）和port（端口号）： 三. 然后以管理员身份打开dos，进入mysql_3307的bin目录，输入mysqld –install mysql_3307安装mysql_3307服务！显示：Service successfully installed.然后输入net start mysql_3307 命令启动。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Windows安装多个MYSQL做读写分离测试！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis环境配置安装注意安装步骤及说明事项。]]></title>
    <url>%2F2016%2F08%2F16%2FRedis%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%E5%8F%8A%E8%AF%B4%E6%98%8E%E4%BA%8B%E9%A1%B9%E3%80%82%2F</url>
    <content type="text"><![CDATA[Wiondows下安装redis步骤：1.使用phpinfo()函数查看PHP的版本信息，这会决定扩展文件版本 2.根据PHP版本号，编译器版本号和CPU架构，选择php_redis-2.2.5-5.5-ts-vc11-x86.zip和php_igbinary-1.2.1-5.5-ts-vc11-x86.zip下载地址：http://windows.php.net/downloads/pecl/snaps/redis/2.2.5/http://windows.php.net/downloads/pecl/releases/igbinary/1.2.1/ 3.解压缩后，将php_redis.dll和php_redis.pdb拷贝至php的ext目录下 4.修改php.ini，(PS：此php.ini文件是在Apache目录）在该文件中加入：; php_redisextension=php_igbinary.dllextension=php_redis.dll注意：extension=php_igbinary.dll一定要放在extension=php_redis.dll的前面，否则此扩展不会生效 5.重启Apache后，使用phpinfo查看扩展是否成功安装 新建一个test.php页面12345$redis=new Redis();$redis-&gt;connect(&apos;192.168.1.11&apos;,6379);$redis-&gt;auth(&apos;123456&apos;);$redis-&gt;set(&apos;test&apos;,&apos;helloworld&apos;);echo $redis-&gt;get(&apos;test&apos;); 什么是RedisRedis是Remote Dictionary Server(远程数据服务)的缩写由意大利人 antirez(Salvatore Sanfilippo) 开发的一款 内存高速缓存数据库该软件使用C语言编写,它的数据模型为 key-value它支持丰富的数据结构，比如 String list hash set sorted set。可持久化，保证了数据安全。 缓存：有两种类型 数据缓存、页面缓存(smarty)使用缓存减轻数据库的负载。在开发网站的时候如果有一些数据在短时间之内不会发生变化，而它们还要被频繁访问，为了提高用户的请求速度/降低网站的负载，就把这些数据放到一个读取速度更快的介质上，该行为就称作对该数据的缓存动作。该介质可以是文件、数据库、内存，内存经常用于数据缓存。 页面缓存经常用在CMS内存管理系统里边数据缓存经常会用在页面的具体数据里边 redis和memcache比较 Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持master-slave(主—从)模式应用。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis单个value的最大限制是1GB， memcached只能保存1MB的数据 一．编译安装Redis安装redis-2.6.14.tar.gzshell# cd /home/jinnan/tarshell# tar zxvf redis-2.6.14.tar.gzshell# cd redis-2.6.14shell# make shell# cd src在该目录会看到以下文件 redis-benchmark 压力测试 redis-check-aof 检查redis持久化命令文件的完整性redis-check-dump 检查redis持久化数据文件的完整性redis-cli redis在linux上的客户端redis-sentinel 做集群用的redis-server linux上的服务端 将redis源码目录下的 src目录里的 redis-cli和 redis-server 拷贝到工作目录里.同时将源码根目录下的redis.conf 也拷贝到工作目录里 shell# mkdir /usr/local/redisshell# cp redis-cli redis-server /usr/local/redisshell# cp ../redis.conf /usr/local/redis 至此在linux上编译安装redis服务端和客户端已经大功告成启动redis服务器:shell# cd /usr/local/redisshell# vi ./redis.conf把参数daemonize no 改为 daemonize yesshell# ./redis-server redis.conf 二. redis配置文件说明/usr/local/redis/redis.conf1 daemonize no默认情况下，redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为yes2 pidfile /var/run/redis.pid当Redis 在后台运行的时候，Redis 默认会把pid 文件放在/var/run/redis.pid，你可以配置到其他地址。当运行多个redis 服务时，需要指定不同的pid 文件和端口3 port监听端口，默认为63794 #bind 127.0.0.1指定Redis 只接收来自于该IP 地址的请求，如果不进行设置，那么将处理所有请求，在生产环境中为了安全最好设置该项。默认注释掉，不开启5 timeout 0设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接6 tcp-keepalive 0指定TCP连接是否为长连接,”侦探”信号有server端维护。默认为0.表示禁用7 loglevel noticelog 等级分为4 级，debug,verbose, notice, 和warning。生产环境下一般开启notice8 logfile stdout配置log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上，也可以修改为日志文件对应的目录地址9 databases 16设置数据库的个数，可以使用SELECT 命令来切换数据库。默认使用的数据库是0号库。默认16个库10save 900 1save 300 10save 60 10000保存数据快照的频率，即将数据持久化到dump.rdb文件中的频度。用来描述”在多少秒期间至少多少个变更操作”触发snapshot数据保存动作默认设置，意思是：if(在60 秒之内有10000 个keys 发生变化时){进行镜像备份}else if(在300 秒之内有10 个keys 发生了变化){进行镜像备份}else if(在900 秒之内有1 个keys 发生了变化){进行镜像备份}更多配置参考：http://blog.csdn.net/neubuffer/article/details/17003909三．php_redis安装配置phpredis中文手册：http://www.cnblogs.com/ikodota/archive/2012/03/05/php_redis_cn.html 下载 phpredis 扩展包上传到linux指定目录(/home/jinnan/rdtar) 进入phpredis源码目录并执行php的bin目录下的一个工具叫 phpize shell# cd /home/jinnan/tar shell# tar zxvf phpredis.tar.gzshell# cd phpredisshell# /usr/local/php/bin/phpize ????以上这个指令必须在phpredis解压包目录/home/jinnan/tar/phpredis(根据个人情况设置)执行 安装autoconf-2.62.tar.gzshell# cd /home/jinnan/tarshell# tar zxvf autoconf-2.62.tar.gzshell# cd autoconf-2.62shell# ./configure &amp;&amp; make &amp;&amp; make install 配置并编译安装phpredis shell#./configure –with-php-config=/usr/local/php/bin/php-config shell# make &amp;&amp; make install 给php.ini设置redis扩展打开php.ini配置文件设置以下代码shell# vi /usr/local/php/lib/php.ini 重启apache shell# /usr/local/http2/bin/apachectl restart 至此，使用php操作redis 所用到的 phpredis扩展包 已经编译安装并配置完毕。 查看php是否有引入redis扩展 php使用redis示例代码 浏览器看效果： 如果不清楚php-redis扩展内部到底有什么方法可以利用反射 官方网址：http://redis.io/redis 中文资料站: http://www.redis.cn/redis 命令手册： http://www.redisdoc.com/en/latest/index.htmlphp操作redis：http://blog.sina.com.cn/s/blog_3dbab2840100uo5l.html 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Redis环境配置安装注意安装步骤及说明事项。/]]></content>
      <categories>
        <category>Redis笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS贪吃蛇代码!]]></title>
    <url>%2F2016%2F08%2F16%2FJS%E8%B4%AA%E5%90%83%E8%9B%87%E4%BB%A3%E7%A0%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[贪吃蛇图片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;新建网页&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; //① 绘制操作界面 function Map()&#123; var w = 800; var h = 400; this.showmap = function()&#123; //利用dom技术创建div元素并设置css样式 //并把div追加到body里边 var mian = document.createElement(&apos;div&apos;); mian.style.width = w+&quot;px&quot;; mian.style.height = h+&quot;px&quot;; //mian.style.backgroundColor = &quot;pink&quot;; //背景方块图片 mian.style.backgroundImage = &quot;url(12.jpg)&quot;; document.body.appendChild(mian); &#125; &#125; //② 绘制食物 function Food()&#123; var len = 20; //食物边长 //声明食物权值坐标为公开的成员 this.xFood = 0; this.yFood = 0; this.pian = null; //用于保存食物的成员对象 this.showfood = function()&#123; if(this.pian===null)&#123; //利用dom创建一个div，绘制绿色的css背景颜色 //宽度和高度都是20 //最后div被追加给body this.pian = document.createElement(&apos;div&apos;); this.pian.style.width = this.pian.style.height = len+&quot;px&quot;; this.pian.style.backgroundColor = &quot;green&quot;; //给div设置绝对定位 this.pian.style.position = &quot;absolute&quot;; document.body.appendChild(this.pian); &#125; //食物摆放有“步进值20”防止放到线上 //食物在地图的位置是变的，原因是其有“权值” //x轴权值的范围：0-39(Math.floor(Math.random()*40)) //y轴权值的范围：0-19(Math.floor(Math.random()*20)) //left和top对决定定位元素进行位置设定的两个样式 //食物坐标=步进值 * 权值; this.xFood = Math.floor(Math.random()*40); this.yFood = Math.floor(Math.random()*20); this.pian.style.left = this.xFood*len+&quot;px&quot;; this.pian.style.top = this.yFood*len+&quot;px&quot;; &#125; &#125; //③ 绘制小蛇 function Snake()&#123; var len = 20; //每个蛇节的边长 //蛇节：[x坐标，y坐标，颜色，div元素节点对象] this.snakebody = [[0,1,&apos;green&apos;,null],[1,1,&apos;green&apos;,null],[2,1,&apos;green&apos;,null],[3,1,&apos;red&apos;,null]]; //蛇头默认移动方向(右) this.redirect = &quot;right&quot;; //绘制 this.showsnake = function()&#123; //遍历每个蛇节并进行具体设置 for(var i=0; i&lt;this.snakebody.length; i++)&#123; //创建每个蛇节div之前先判断，不要重复创建 if(this.snakebody[i][3]===null)&#123; this.snakebody[i][3] = document.createElement(&apos;div&apos;); this.snakebody[i][3].style.height = this.snakebody[i][3].style.width = len+&quot;px&quot;; this.snakebody[i][3].style.backgroundColor = this.snakebody[i][2]; //绝对定位 this.snakebody[i][3].style.position = &quot;absolute&quot;; document.body.appendChild(this.snakebody[i][3]); &#125; //设置坐标=权值坐标 * 步进值; this.snakebody[i][3].style.left = this.snakebody[i][0] * len+&quot;px&quot;; this.snakebody[i][3].style.top = this.snakebody[i][1] * len+&quot;px&quot;; &#125; &#125; //移动小蛇 this.movesnake = function()&#123; //当前蛇节新坐标 等于下个蛇节的 旧坐标 for(var i=0; i&lt;this.snakebody.length-1; i++)&#123; this.snakebody[i][0] = this.snakebody[i+1][0]; this.snakebody[i][1] = this.snakebody[i+1][1]; &#125; //蛇头移动 if(this.redirect == &apos;right&apos;) this.snakebody[this.snakebody.length-1][0]++; //x轴坐标++ else if (this.redirect == &apos;left&apos;) this.snakebody[this.snakebody.length-1][0]--; //x轴坐标-- else if (this.redirect == &apos;top&apos;) this.snakebody[this.snakebody.length-1][1]--; //y轴坐标-- else if (this.redirect == &apos;down&apos;) this.snakebody[this.snakebody.length-1][1]++; //y轴坐标++ //蛇头碰到食物（蛇头坐标 与 食物坐标 对比） var xSnake = this.snakebody[this.snakebody.length-1][0]; var ySnake = this.snakebody[this.snakebody.length-1][1]; //food.xFood food.yFood分别是食物的x/y轴坐标 if(xSnake==food.xFood &amp;&amp; ySnake==food.yFood)&#123; //增加蛇节 //增加新蛇节，该蛇节的坐标等于&quot;蛇尾巴节&quot;旧的坐标 var newjie = [this.snakebody[0][0],this.snakebody[0][1],&apos;green&apos;,null]; this.snakebody.unshift(newjie); //生成一个新食物 food.showfood(); &#125; //规定小蛇在地图范围移动 if(xSnake&gt;39 || xSnake&lt;0 || ySnake&gt;19 || ySnake&lt;0)&#123; alert(&apos;game over&apos;); clearInterval(mytime); return false; &#125; //蛇头吃到自己的判断 for(var k=0; k&lt;this.snakebody.length-1; k++)&#123; //蛇头坐标 是否 等于任何一个蛇节的坐标 if(xSnake==this.snakebody[k][0] &amp;&amp; ySnake==this.snakebody[k][1])&#123; alert(&apos;kill you by yourself game over!&apos;); clearInterval(mytime); return false; &#125; &#125; //根据新坐标重新绘制小蛇 this.showsnake(); &#125; &#125; window.onload = function()&#123; //操作界面 var map = new Map(); map.showmap(); //绘制食物 food = new Food(); food.showfood(); //绘制小蛇 snake = new Snake(); snake.showsnake(); //移动小蛇,并且不要停止 mytime = setInterval(&quot;snake.movesnake()&quot;,200); //snake.movesnake(); //给body设置键盘事件，通过&quot;事件对象&quot;感知被触发的键子信息 document.onkeyup = function(evt)&#123; var num = evt.keyCode; switch(num)&#123; case 37: snake.redirect = &quot;left&quot;; break; case 38: snake.redirect = &quot;top&quot;; break; case 39: snake.redirect = &quot;right&quot;; break; case 40: snake.redirect = &quot;down&quot;; break; &#125; &#125; &#125; &lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123;margin:0;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/JS贪吃蛇代码！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP响应代码详细介绍！]]></title>
    <url>%2F2016%2F08%2F16%2FHTTP%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%81%2F</url>
    <content type="text"><![CDATA[响应码由三位十进制数字组成，它们出现在由HTTP服务器发送的响应的第一行。 响应码分五种类型，由它们的第一位数字表示：123451.1xx：信息，请求收到，继续处理2.2xx：成功，行为被成功地接受、理解和采纳3.3xx：重定向，为了完成请求，必须进一步执行的动作4.4xx：客户端错误，请求包含语法错误或者请求无法实现5.5xx：服务器错误，服务器不能实现一种明显无效的请求 http代码含义：12345678910111213141516171819202122232425262728293031323334353637383940&quot;100&quot; : Continue &quot;101&quot; : witching Protocols &quot;200&quot; : OK &quot;201&quot; : Created &quot;202&quot; : Accepted &quot;203&quot; : Non-Authoritative Information &quot;204&quot; : No Content &quot;205&quot; : Reset Content &quot;206&quot; : Partial Content &quot;300&quot; : Multiple Choices &quot;301&quot; : Moved Permanently &quot;302&quot; : Found &quot;303&quot; : See Other &quot;304&quot; : Not Modified &quot;305&quot; : Use Proxy &quot;307&quot; : Temporary Redirect &quot;400&quot; : Bad Request &quot;401&quot; : Unauthorized &quot;402&quot; : Payment Required &quot;403&quot; : Forbidden &quot;404&quot; : Not Found &quot;405&quot; : Method Not Allowed &quot;406&quot; : Not Acceptable &quot;407&quot; : Proxy Authentication Required &quot;408&quot; : Request Time-out &quot;409&quot; : Conflict &quot;410&quot; : Gone &quot;411&quot; : Length Required &quot;412&quot; : Precondition Failed &quot;413&quot; : Request Entity Too Large &quot;414&quot; : Request-URI Too Large &quot;415&quot; : Unsupported Media Type &quot;416&quot; : Requested range not satisfiable &quot;417&quot; : Expectation Failed &quot;500&quot; : Internal Server Error &quot;501&quot; : Not Implemented &quot;502&quot; : Bad Gateway &quot;503&quot; : Service Unavailable &quot;504&quot; : Gateway Time-out &quot;505&quot; : HTTP Version not supported 12345678910111213141516171819202122232425262728293031323334353637383940100 继续101 分组交换协200 OK201 被创建202 被采纳203 非授权信息204 无内容205 重置内容206 部分内容300 多选项301 永久地传送302 找到303 参见其他304 未改动305 使用代理307 暂时重定向400 错误请求401 未授权402 要求付费403 禁止404 未找到文件405 不允许的方法406 不被采纳407 要求代理授权408 请求超时409 冲突410 过期的411 要求的长度412 前提不成立413 请求实例太大414 请求URI太大415 不支持的媒体类型416 无法满足的请求范围417 失败的预期500 内部服务器错误501 未被使用502 网关错误503 不可用的服务504 网关超时505 HTTP版本未被支持 123456789101112131415161718192021222324252627282930313233343536373839404142HTTP 400 - 请求无效 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败HTTP 403 - 禁止访问 HTTP 403 - 对 Internet 服务管理器 (HTML) 的访问仅限于 Localhost HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.8 - 禁止访问：禁止站点访问 HTTP 403.9 - 禁止访问：连接的用户过多 HTTP 403.10 - 禁止访问：配置无效 HTTP 403.11 - 禁止访问：密码更改 HTTP 403.12 - 禁止访问：映射器拒绝访问 HTTP 403.13 - 禁止访问：客户证书已被吊销 HTTP 403.15 - 禁止访问：客户访问许可过多 HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 HTTP 404.1 - 无法找到 Web 站点 HTTP 404 - 无法找到文件 HTTP 405 - 资源被禁止 HTTP 406 - 无法接受 HTTP 407 - 要求代理身份验证 HTTP 410 - 永远不可用 HTTP 412 - 先决条件失败 HTTP 414 - 请求 - URI 太长 HTTP 500 - 内部服务器错误 HTTP 500.100 - 内部服务器错误 - ASP 错误 HTTP 500-11 服务器关闭 HTTP 500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求 global.asa Error 501 - 未实现 HTTP 502 - 网关错误 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/HTTP响应代码详细介绍！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-apache下虚拟主机配置方法！]]></title>
    <url>%2F2016%2F08%2F16%2FLinux-Apache%E4%B8%8B%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%EF%BC%81%2F</url>
    <content type="text"><![CDATA[linux apache下虚拟主机配置方法 假设IP是192.168.1.183，有两个域名指向该IP，分别是21.cc,22.cc, 修改/etc/httpd/conf/httpd.conf，在文件的最后加入： ServerName 192.168.1.183 NameVirtualHost 192.168.1.183 ServerName 21.cc DocumentRoot /var/www/21.cc Options Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;VirtualHost 192.168.1.183&gt; ServerName 22.cc DocumentRoot /var/www/22.cc &lt;Directory &quot;/var/www/22.cc&quot;&gt; Options Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 然后在/var/www/21.cc和/var/www/22.cc下创建不同的index.php,在浏览器里输入http://21.cc和http://22.cc即可看到效果了 ! 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Linux-Apache下虚拟主机配置方法！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Apache</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-5种数据类型学习笔记！-]]></title>
    <url>%2F2016%2F08%2F16%2FRedis-5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81-%2F</url>
    <content type="text"><![CDATA[123456 redis 有5种数据格式！redis有16个数据库(0-15)!切换数据库：select 15(切换第15个数据库) 清空数据库：flushall set key : 1 values ( : 表示作用域 )//输入ping 返回 pong 1.string类型：个人理解：就是简单的key-&gt;value123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138 SET key value 设置指定 key 的值 set name lucy //okGET key获取指定 key 的值 get name //lucy GETRANGE key start end返回 key 中字符串值的子字符 getrange name 0 2 //lucGETSET key value//获取 key 的旧值返回，设置key 的新值 value //key 若不存在返回nilset name lucy //okgetset name lily //lucy MSET key1 val1 key2 val 2 ...同时设置一个或多个 key-value 对。mset name lucy age 18 class 3 //okMGET key1 [key2..]获取所有(一个或多个)给定 key 的值。 mget name age class //lucy 18 3 SETEX key seconds value 为 key 赋值 value ，并设置过期时间（以秒为单位）PSETEX key milliseconds value这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间 setex name 60 lucy //为name 赋值lucy，过期时间60s，//可以用ttl name 查看剩余过期时间psetex name 600 lucySETNX key value只有在 key 不存在时设置 key 的值。 set name lucy setnx name lily //（integer) 0 失败set names lily //（integer) 1 成功 STRLEN key返回 key 所储存的字符串值的长度。strlen name //(integer) 4SUBSTR key start end截取 key 从 start 开始 截取 到 endsubstr name 0 1 // lu MSETNX key value [key value ...]同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。msetnx key1 val1 key2 val2 INCR key将 key 中储存的数字值增一 set n 10 incr n //11 INCRBY key increment将 key 所储存的值加上给定的增量值（increment） set n 10incrby n 2 //12 DECR key将 key 中储存的数字值减一。 set n 10decr n // 9DECRBY key decrementkey 所储存的值减去给定的减量值（decrement） 。 set n 10decrby n 2 //8APPEND key valueAPPEND 命令将 value 追加到字符串 key 原值末尾append name hello //name 不存在返回 helloset name lucy append name hello // lucyhello del key 删除key //del 成功 (integer) 1 ，失败(integer) 0del name 符合给定模式的 key 列表 (Array) keys abc* //获取 以abc 开头的 keykeys *abc //获取 以abc 结尾的 keykeys * //获取该数据库所有 key //如果为空 返回(empy list or set)判断key 是否存在exists key // 成功 (integer) 1 ，失败(integer) 0exists name判断key 类型type key // 返回 类型type name修改 key 名称rename key k //成功返回okrename name titlerandomkey随机返回一个keyrandomkey 创建一个 key 并赋值：set key val为 key 设置过期时间：expire key 60(秒) 查看剩余过期时间：ttl key 过期后 再 get key 则 返回 (nil) 2.list类型：个人理解：一个双向队列，要么头进尾出，要么尾进头出。123456789101112131415161718192021222324lpush list string//在list 头部压入字符串元素rpush list string//在list 尾部压入字符串元素 // 当 key 存在但不是列表类型时，返回一个错误。llen list // 返回 list 长度，不存在返回0lrange list start end//返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 //其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 //你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。lrange list 0 -1 //取list全部lrem list count string//从list 头部开始 删除 count 个 stringlpop list //弹出最头部 的元素，删除rpop list //弹出最尾部 的元素，删除 3.hash类型：个人理解： hash 类似mysql的一行记录，一行记录中， table有多个field，每个field对应一个value；12345678910111213141516171819202122232425262728293031323334353637383940hset table field1 value1 //设置 field1 值 为 value1//成功 返回 （integer) 1 ,失败 返回（integer) 0 //如果field1 已存在 ，则替换 ，但返回 （integer) 0hget table filed1 //获取 field1hgetall table //获取table所有fieldhdel table field1 //删除 filed1 //成功 返回 （integer) 1 ,失败 返回（integer) 0 hexists table field1//field1 是否存在//成功 返回 （integer) 1 ,失败 返回（integer) 0 hincrby table field n//给 field 自增长 n（可以为负数）hkeys table//获取 table 所有 fieldhlen table//哈希表中字段的数量。 当 key 不存在时，返回 0 。hmset table field1 value1 field2 value2 field3 value3 ...//批量设置hmget table field1 field2 field3 field4 ...//批量获取hsetnx table field value//为field 设置 value ，如果 field已存在，则 失败，返回 （integer） 0 4.set类型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748sadd set value1 value2 value3 ...//将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。 //假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。 //当集合 key 不是集合类型时，返回一个错误。//集合元素不能重复，否则添加失败scard set//集合的数量。 当集合 key 不存在时，返回 0 。smembers set//查看 set 所有元素sdiff set1 set2 setn...//在set1 集合里，但不在set2 集合里。求差集，不存在的集合 key 将视为空集。sdiffstore set set1 set2 setn...//在set1 集合里，但不在set2 集合里。差集存储set 集合sinter set1 set2 setn...//求交集， 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。sinterstore set set1 set2 setn...//求set1，set2 ，setn的交集。交集存储set 集合sunion set1 set2 setn...//求set1 ，set2 ，setn的并集sunionstore set set1 set2 setn...//求set1，set2 ，setn的并集。交集存储set 并集sismember set value//判断 value 是否是 set 集合的元素，是返回 1，否 返回 0smove set1 set2 value//把set1集合的value 移到 set2 集合。smove是原子性操作，成功返回 1，失败返回 0spop set //移除并返回set 集合中的一个随机元素。srandmember set//随机返回set 集合中的一个元素 srem set value1 value2 valuen//从集合 set 中 移除 value元素，可以移除多个，返回移除成功的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN// 命令用于将一个或多个成员元素及其分数值加入到有序集当中。//如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。//分数值可以是整数值或双精度浮点数。//如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。//当 key 存在但不是有序集类型时，返回一个错误。 ZCARD KEY_NAME//用于计算集合中元素的数量。ZCOUNT key min max//用于计算有序集合中指定分数区间的成员数量。ZINCRBY key increment member//对有序集合中指定成员的分数加上增量 increment//可以通过传递一个负数值 increment ，让分数减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。//当 key 不存在，或分数不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。//当 key 不是有序集类型时，返回一个错误。//分数值可以是整数值或双精度浮点数。ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]//计算给定的一个或多个有序集的交集，中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。//默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。ZLEXCOUNT KEY MIN MAX//在计算有序集合中指定字典区间内成员数量。ZRANGE key start stop [WITHSCORES]//返回有序集中，指定区间内的成员。//其中成员的位置按分数值递增(从小到大)来排序。//具有相同分数值的成员按字典序(lexicographical order )来排列。//如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。//下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。//你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。ZRANK key member//返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。ZRANK key member//用于移除有序集中的一个或多个成员，不存在的成员将被忽略。//当 key 存在但不是有序集类型时，返回一个错误。 ZSCORE key member//返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil 。 ZSCORE key member//返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil 。ZSCAN key cursor [MATCH pattern] [COUNT count]//用于迭代有序集合中的元素（包括元素成员和元素分值） ``` 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Redis-5种数据类型学习笔记！-/]]></content>
      <categories>
        <category>Redis笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-ubuntu-lamp安装配置环境phpmyadmin-！]]></title>
    <url>%2F2016%2F08%2F16%2FLinux-ubuntu-lamp%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83phpmyadmin-%EF%BC%81%2F</url>
    <content type="text"><![CDATA[PHP开发和服务器运行环境首选LAMP组合，即Linux+Apache+Mysql+Php/Perl/Python，能最优化服务器性能。如何在本地电脑Ubuntu 中安装和配置LAMP环境搭建？Ubuntu9.10本身就是基于Linux内核，所以Linux是现成的了。使用Ubuntu LAMP Server软件包可以很简单地实现Linux下Apache，Mysql和Php的统一安装和配置，也不再需要一个一个来安装配置了。 Ubuntu环境下如何安装LAMP组件？ 使用Ubuntu界面管理器：系统-&gt;系统管理-&gt;新立得软件包管理器-&gt;编辑-&gt;使用任务标记分组软件包-&gt;LAMP Server(勾选)-&gt;确定-&gt;返回到上一个窗口点击应用(或System-&gt;Administration-&gt;Synaptic Package Manager-&gt;Edit-&gt;Mark packages by Task-&gt;LAMP Server-&gt;OK)。然后系统会自动下载安装lamp环境软件包，几分钟就下载搞定。安装过程中会要求设置Mysql root帐号的密码，设置好了记住。另外当Ubuntu系统升级时lamp环境组件也会同时更新到最新版本。 安装完毕测试：打开Firefox浏览器在地址栏输入127.0.0.1，显示It works!表明Apache服务器已经开始工作了，LAMP安装也就这样完成了。 ubuntu LAMP 安装 环境配置Linux ubuntu LAMP 安装配置环境-It Works 当然不使用Gnome，使用终端命令也很简单：直接一条命令：apt-get install apache2 mysql-server mysql-client php5 php5-gd php5-mysql 设置Ubuntu文件执行读写权限 LAMP组建安装好之后，PHP网络服务器根目录默认设置是在：/var/www。由于Linux系统的安全性原则，改 目录下的文件读写权限是只允许root用户操作的，所以我们不能在www文件夹中新建php文件，也不能修改和删除，必须要先修改/var/www目录的读写权限。在界面管理器中通过右键属性不能修改文件权限，得执行root终端命令：sudo chmod 777 /var/www。然后就可以写入html或php文件了。如果对777表示的文件权限不是很清楚，可以到这篇文章中看看：文件权限666是什么意思。 如何安装phpmyadmin-Mysql 数据库管理 使用界面管理器：系统-&gt;系统管理-&gt;新立得软件包管理器-&gt;搜索 phpmyadmin-&gt;右键标记安装。或直接使用一条命令：sudo apt-get install phpmyadmin 安装开始。 phpmyadmin设置：在安装过程中会要求选择Web server：apache2或lighttpd，选择apache2，按tab键然后确定。然后会要求输入设置的Mysql数据库密码连接密码 Password of the database’s administrative user。然后将phpmyadmin与apache2建立连接，以我的为例：www目录在/var/www，phpmyadmin在/usr/share/phpmyadmin目录，所以就用命令：sudo ln -s /usr/share/phpmyadmin /var/www 建立连接。 phpmyadmin测试：在浏览器地址栏中打开http://localhost/phpmyadmin。 Ubuntu LAMP 如何配置Apache 启用 mod_rewrite 模块终端命令：sudo a2enmod rewrite重启Apache服务器：sudo /etc/init.d/apache2 restart Apache重启后我们可以测试一下，在/var/www目录下新建文件test.php，写入代码： &lt;?php phpinfo(); ?&gt; 保存，在地址栏输入http://127.0.0.1/test.php ;或 http://localhost/test.php ，如果正确出现了php 配置信息则表明LAMP Apache已经正常工作了(记得重启Apache服务器后再测试)。 2.设置Apache支持.htm .html .phpsudo gedit /etc/apache2/apache2.conf或sudo gedit /etc/apache2/mods-enabled/php5.conf在打开的文件中加上AddType application/x-httpd-php .php .htm .html 即可。 LAMP配置之Mysql测试 上面php,Apache 都已经测试过了，下面我们再测试一下Mysql 数据库是否已经正确启用。 在/var/www目录下新建 mysql_test.php：&lt;?php$link = mysql_connect(“localhost”,”root”,”020511”);if (!$link){die(‘Could not connect: ‘ . mysql_error());}else echo “Mysql已经正确配置”;mysql_close($link);?&gt;保存退出，在地址栏输入http://127.0.0.1/mysql_test.php，显示”Mysql 已经正确配置”则表示OK了，如果不行，重启Apache服务器后再试一下。 解决Firefox浏览器显示中文乱码等问题 上面在FireFox浏览器中打开mysql_test.php或phpmyadmin测试时，如果出现了中文乱码，则是默认语言设置问题，解决方法如下： 打开apache配置文件： udo gedit /etc/apache2/apache2.conf，在最后面加上：AddDefaultCharset UTF-8，如果还是乱码的，再将UTF-8改用gb2312。重启Apache：sudo /etc/init.d/apache2 restart 再刷新mysql_test.php 中文乱码没有了。 如果要人工启动mysql：mysql -u root -p，根据提示输入密码。如果重启Apache时出现： Restarting web server apache2apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerNameapache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerName 则还是修改apache配置文件：sudo gedit /etc/apache2/apache2.conf，在文件最后设置：ServerName 127.0.0.1 LAMP组件经常使用的几个终端命令 重启 apache：sudo /etc/init.d/apache2 restart 重启mysql：sudo /etc/init.d/mysql restart 配置 php.ini：sudo gedit /etc/php5/apache2/php.ini 配置 apache2.conf：sudo gedit /etc/apache2/apache2.conf 配置 my.cnf：sudo gedit /etc/mysql/my.cnf PHP CGI ：sudo /var/www/cgi-bin/ Ubuntu PHP 编辑器 最后LAMP配置就完成了，在Ubuntu下进行简单的php代码编辑，用Gedit就可以了。Gedit支持HTML，PHP，Javascsript等近几十种语言的代码高亮功能。如果是PHP项目开发，建议使用PHP IDE编辑器，比如Zend Studio，Eclipse。据说文本编辑VIM也很不错。 PS：如果是Windows XP 下要搭建LAMP 环境，建议大家试试xampp快速安装配置法，使用也很方便快捷，点击前面的超级链接或Google一下就知道怎么用了。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/08/16/Linux-ubuntu-lamp安装配置环境phpmyadmin-！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下gitHub笔记!]]></title>
    <url>%2F2016%2F07%2F05%2FWindows%E4%B8%8BgitHub%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[https://github.com/ 注册账号登陆！https://desktop.github.com/ 软件下载地址！https://www.git-scm.com/download/win Windows下载Git地址！ ###GitHub： #####安装完成后，桌面鼠标右击，菜单会出现如下图： #####新建项目文件夹进入后鼠标右击，选 Git Bash Here ！进入命令行，输入如下两行命令配置用户名和邮箱。 12345678910111213141516//获取配置列表git config --list//配置用户名git config --global user.name &apos;DiorsCoder&apos;//配置邮箱git config --global user.email &apos;865196792@qq.com&apos;//创建项目目录并进入mkdir dirNamecd dirName//git控制git init #####使用Git添加文件到暂存区，可以使用linux命令也可以windows界面操作！12345678910111213141516171819202122232425//创建，编辑，查看文件内容touch fileNamevim fileNamecat fileName//查看状态git status//添加 &amp; 修改：先添加或修改本地文件，再提交到 Git 暂存区 ,最后提交！ git add fileName git commit -m ‘备注’ git push//删除文件步骤：rm fileName git rm fileNamegit commit -m ‘备注’git push//删除文件夹步骤：rm -rf dirNamegit rm -rf dirNamegit commit（文件写入备注）git push 一.添加文件到暂存区： 二.提交文件到版本库 从 GitHub 上 复制仓库地址，在本地 使用命令：git clone https://github.com/GitHub账户/项目名.git ，把项目克隆至本地。 1234567891011121314//查看所有分支 git branch -a//切换分支git checkout 分支名称//合并其它分支代码git merge 其它分支名称//查看日志git log//更新仓库最新代码至本地git pull 登录GitHub新建仓库：账户名.github.io，新建html文件：index.html。例如：DiorsCoder.github.io 然后浏览器输入访问：https://账户名.github.io例如：https://diorscoder.github.io 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/05/Windows下gitHub笔记！/]]></content>
      <categories>
        <category>gitHub</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>gitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下搭建SVN笔记!]]></title>
    <url>%2F2016%2F07%2F05%2FCentOS%E4%B8%8B%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%EF%BC%81%2F</url>
    <content type="text"><![CDATA[安装步骤如下：1、yum install subversion2、输入rpm -ql subversion查看安装位置，如下图： 我们知道svn在bin目录下生成了几个二进制文件。输入 svn –help可以查看svn的使用方法，如下图。 3、创建svn版本库目录mkdir -p /var/svn/svnrepos 4、创建版本库svnadmin create /var/svn/svnrepos执行了这个命令之后会在/var/svn/svnrepos目录下生成如下这些文件 5、进入conf目录（该svn版本库配置文件）authz文件是权限控制文件passwd是帐号密码文件svnserve.conf SVN服务配置文件 6、设置帐号密码vi passwd在[users]块中添加用户和密码，格式：帐号=密码，如dan=dan 7、设置权限vi authz在末尾添加如下代码：[/]dan=rww=r意思是版本库的根目录dan对其有读写权限，w只有读权限。 8、修改svnserve.conf文件vi svnserve.conf打开下面的几个注释：anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/svnrepos # 认证空间名，版本库所在目录修改authz文件添加：[svnrepos:/]admin = rw 9、启动svn版本库svnserve -d -r /var/svn/svnrepos10、在windows上测试新建一个测试文件夹，在该文件夹下右键选择 SVN checkout如下图(要事先安装TortoiseSVN)：填写SVN的地址，如下图： 输入密码，如下图： 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/05/CentOS下搭建SVN服务！/]]></content>
      <categories>
        <category>SVN笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海马玩模拟器安装与卸载本地apk的方法!]]></title>
    <url>%2F2016%2F07%2F02%2F%E6%B5%B7%E9%A9%AC%E7%8E%A9%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%E6%9C%AC%E5%9C%B0APK%E7%9A%84%E6%96%B9%E6%B3%95!%2F</url>
    <content type="text"><![CDATA[###安装的三种方法： #####第一种最简单的方法就是直接拖拽本地apk到海马玩模拟器当中。 #####第二种方法就是在电脑中右键单击apk文件，然后选择打开方式，在打开方式中选择海马玩模拟器。 #####第三种方法就是点击模拟器的设置按钮，然后选择其他设置。选择apk安装。如下图： ###卸载方法：鼠标长按要卸载的apk，直至出现卸载对话框点击卸载。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/海马玩模拟器安装与卸载本地APK的方法!/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米蓝牙耳机连不上iphone，以及连接电脑方法！]]></title>
    <url>%2F2016%2F07%2F02%2F%E5%B0%8F%E7%B1%B3%E8%93%9D%E7%89%99%E8%80%B3%E6%9C%BA%E8%BF%9E%E4%B8%8D%E4%B8%8Aiphone%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E6%96%B9%E6%B3%95%EF%BC%81%2F</url>
    <content type="text"><![CDATA[iphone 手机，系统蓝牙搜不到设备，小米蓝牙耳机重置后再打开，即可搜索到设备。小米蓝牙耳机关机：开机状态下，长按至红灯亮起为关机！小米蓝牙耳机重置为出厂设置：充电状态下，长按至红蓝灯交替闪3次即为重置！小米蓝牙耳机充电指示灯说明：充电中LED一直亮红灯，充满电，LED一直亮蓝灯，充电时间一般为两个小时左右 ！ 小米蓝牙耳机连接笔记本！步骤一：开启电脑蓝牙！步骤二：转到设置进行配对！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/小米蓝牙耳机连不上iphone，以及连接电脑方法！/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下搭建SVN服务笔记!]]></title>
    <url>%2F2016%2F07%2F02%2FWindows%E4%B8%8B%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[服务端下载地址：https://www.visualsvn.com/server/download/客户端下载地址：https://tortoisesvn.net/downloads.html客户端汉化，在 https://tortoisesvn.net/downloads.html 页面下找到如下图：下载完成如图： 安装之后设置中文语言： 汉化成功图： 服务端，安装的时候可以设置软件安装位置和版本库的位置，还有端口号设置： 然后创建版本库，用户，用户组：复制版本库的url：https://WIN-48O5LCPE3AM/svn/test/ 在客户端进行checkout： 看到checkout文件夹上面有绿色√号则可以进行add，commit，update等操作了！ 步骤：① 右键——&gt; SVN—-&gt;Add(本地的.svn对该文件形成管理)② 右键——&gt; Commit(本次的文件提交给svn仓库) 文件颜色标志① 蓝色加号：本地的.svn对该文件有形成管理② 绿色对号：本地文件、.svn管理的版本文件、仓库文件 三者一致③ 红色叹号：本地文件 与 .svn和仓库文件 不一致(用户自己修改了该文件)④ 黄色叹号：表示该文件正处于冲突状态 大家同时修改同一文件时候，update提示文件有冲突： （同一设备可以服务端和客户端共存！一个服务端对应多个客户端，也可以一个客户端对应多个服务端！） 新建 post-commit.bat 文件，写入如下代码：12345SET SVN = &quot;D:\WorkPlace\VisualSVN\bin\svn.exe&quot;SET DIR = &quot;D:\WorkSpace\svn\shop&quot;SVN update %DIR% shop为测试服务器项目目录；shop_1为本地项目目录；正常情况下，shop_1提交svn更新后，shop会同步更新！但是却报错，后续研究！。。。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/Windows下搭建SVN服务笔记！/]]></content>
      <categories>
        <category>SVN笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows共享文件给虚拟机！]]></title>
    <url>%2F2016%2F07%2F02%2FWindows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%81%2F</url>
    <content type="text"><![CDATA[windows10下装了虚拟机，有linux，还一个windows7。 win10宿主机文件可以直接拖到win7虚拟机内，如下图： 一.如果上述方法行不通可以试试共享文件夹的方式。此种方法不仅可以共享给自己的虚拟机，局域网windows用户也可以。宿主机选择共享的文件夹，点属性，在菜单选共享-&gt;停止共享-&gt;更改共享权限，选Everone，可以给只读权限，或其他权限。然后点共享完成。在其他计算机（局域网内），或者自己的虚拟机里。win+R输入共享主机的ip地址：\\ IP地址（例如：\\192.168.1.202）或直接浏览器输入。可能会提示要输入共享主机的账户和密码。可以在控制面板-&gt;网络和internet-&gt;网络和共享中心-&gt;高级共享设置里关闭密码保护共享。如果还是不能访问，则需要打开windows防火墙设置，网络发现，文件盒打印机共享后面专用和公用都打勾： 我是在自己的虚拟机内操作的。步骤如下图： 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/Windows共享文件给虚拟机！/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android移动端与PHP服务端对称加密解密的实现-！]]></title>
    <url>%2F2016%2F07%2F02%2FAndroid%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8EPHP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%9A%84%E5%AE%9E%E7%8E%B0-%EF%BC%81%2F</url>
    <content type="text"><![CDATA[12345678910class ApiCrypter&#123; private $iv = &apos;fdsfds85435nfdfs&apos;; #与JAVA实现类中的设置必须一致 private $key = &apos;89432hjfsd891787&apos;; #与JAVA实现类中的设置必须一致 public function __construct() &#123; &#125; 12345678910111213141516171819public function encrypt($str) &#123; $str = $this-&gt;pkcs5_pad($str); $iv = $this-&gt;iv; $td = mcrypt_module_open(&apos;rijndael-128&apos;, &apos;&apos;, &apos;cbc&apos;, $iv); mcrypt_generic_init($td, $this-&gt;key, $iv); $encrypted = mcrypt_generic($td, $str); mcrypt_generic_deinit($td); mcrypt_module_close($td); return bin2hex($encrypted);&#125; 123456789101112131415161718192021public function decrypt($code) &#123; $code = $this-&gt;hex2bin($code); $iv = $this-&gt;iv; $td = mcrypt_module_open(&apos;rijndael-128&apos;, &apos;&apos;, &apos;cbc&apos;, $iv); mcrypt_generic_init($td, $this-&gt;key, $iv); $decrypted = mdecrypt_generic($td, $code); mcrypt_generic_deinit($td); mcrypt_module_close($td); $ut = utf8_encode(trim($decrypted)); return $this-&gt;pkcs5_unpad($ut);&#125; 1234567891011121314protected function hex2bin($hexdata) &#123; $bindata = &apos;&apos;; for ($i = 0; $i &lt; strlen($hexdata); $i += 2) &#123; $bindata .= chr(hexdec(substr($hexdata, $i, 2))); &#125; return $bindata;&#125; 123456789protected function pkcs5_pad ($text) &#123; $blocksize = 16; $pad = $blocksize - (strlen($text) % $blocksize); return $text . str_repeat(chr($pad), $pad);&#125; 123456789101112131415161718192021 protected function pkcs5_unpad($text) &#123; $pad = ord($text&#123;strlen($text)-1&#125;); if ($pad &gt; strlen($text)) &#123; return false; &#125; if (strspn($text, chr($pad), strlen($text) - $pad) != $pad) &#123; return false; &#125; return substr($text, 0, -1 * $pad); &#125;&#125; 123456789101112package com.cwilldev.crypt;import java.security.NoSuchAlgorithmException;import javax.crypto.Cipher;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec; 123456789101112public class ApiCrypter &#123; private String iv = &quot;fdsfds85435nfdfs&quot;; //根据实际需要更改 private String secretkey = &quot;89432hjfsd891787&quot;; //根据实际需要更改 private IvParameterSpec ivspec; private SecretKeySpec keyspec; private Cipher cipher; 123456789101112131415161718192021222324public ApiCrypter()&#123; ivspec = new IvParameterSpec(iv.getBytes()); keyspec = new SecretKeySpec(secretkey.getBytes(), &quot;AES&quot;); try &#123; cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125;&#125; 1234567891011121314151617181920212223242526272829public byte[] encrypt(String text) throws Exception&#123; if(text == null || text.length() == 0) &#123; throw new Exception(&quot;Empty string&quot;); &#125; byte[] encrypted = null; try &#123; cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec); encrypted = cipher.doFinal(text.getBytes(&quot;UTF-8&quot;)); &#125; catch (Exception e) &#123; throw new Exception(&quot;[encrypt] &quot; + e.getMessage()); &#125; return encrypted;&#125; 123456789101112131415161718192021222324252627282930public byte[] decrypt(String code) throws Exception&#123; if(code == null || code.length() == 0) &#123; throw new Exception(&quot;Empty string&quot;); &#125; byte[] decrypted = null; try &#123; cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec); decrypted = cipher.doFinal(hexToBytes(code)); &#125; catch (Exception e) &#123; throw new Exception(&quot;[decrypt] &quot; + e.getMessage()); &#125; return decrypted;&#125; 123456789101112131415161718192021222324252627282930313233public static String bytesToHex(byte[] data)&#123; if (data==null) &#123; return null; &#125; int len = data.length; String str = &quot;&quot;; for (int i=0; i&lt;len; i++) &#123; if ((data[i]&amp;0xFF)&lt;16) &#123; str = str + &quot;0&quot; + java.lang.Integer.toHexString(data[i]&amp;0xFF); &#125; else &#123; str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF); &#125; &#125; return str;&#125; 12345678910111213141516171819202122232425262728293031323334 public static byte[] hexToBytes(String str) &#123; if (str==null) &#123; return null; &#125; else if (str.length() &lt; 2) &#123; return null; &#125; else &#123; int len = str.length() / 2; byte[] buffer = new byte[len]; for (int i=0; i&lt;len; i++) &#123; buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16); &#125; return buffer; &#125; &#125;&#125; $original_text = &apos;test&apos;; $mdes = new ApiCrypterUtil(); //加密 $encrypt_text = $mdes-&gt;encrypt($original_text); $this-&gt;log($encrypt_text, LOG_DEBUG); //解密 $this-&gt;log($mdes-&gt;decrypt($encrypt_text), LOG_DEBUG); //加密: ApiCrypter apiCrypter = new ApiCrypter(); String originalText = &quot;test&quot;; String encryptedText = ApiCrypter.bytesToHex(apiCrypter.encrypt(jsonParams.toString())); //解密: String res = new String(apiCrypter.decrypt(encryptedText), &quot;UTF-8&quot;); String decryptedText = URLDecoder.decode(res, &quot;UTF-8&quot;); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/Android移动端与PHP服务端对称加密解密的实现-！/]]></content>
      <categories>
        <category>Android和IOS相关</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows无法完成安装。若要在此计算机上安装windows,请重新启动安装。]]></title>
    <url>%2F2016%2F07%2F02%2FWindows%E6%97%A0%E6%B3%95%E5%AE%8C%E6%88%90%E5%AE%89%E8%A3%85%E3%80%82%E8%8B%A5%E8%A6%81%E5%9C%A8%E6%AD%A4%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85Windows%2C%E8%AF%B7%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E5%AE%89%E8%A3%85%E3%80%82%2F</url>
    <content type="text"><![CDATA[123456用U大师装Win7系统，系统解压放到isos目录。格式化C盘，选择isos目录下sources下的install.wim，下面两个目录选择C盘，安装到最后提示：windows无法完成安装。若要在此计算机上安装windows,请重新启动安装。一直重复这个步骤！ 换Win10系统也是一样，百度找了半天解决方法，最后用下面方法解决了，成功安装了Win10！用分区助手格式化C盘后，把C盘设置成活动分区！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/Windows无法完成安装。若要在此计算机上安装Windows,请重新启动安装。/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows-dos命令删除服务！创建私密文件夹！解决端口占用等等问题！]]></title>
    <url>%2F2016%2F07%2F02%2FWindow-DOS%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E6%9C%8D%E5%8A%A1%EF%BC%81%E5%88%9B%E5%BB%BA%E7%A7%81%E5%AF%86%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%81%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E7%AD%89%E7%AD%89%E9%97%AE%E9%A2%98%EF%BC%81%2F</url>
    <content type="text"><![CDATA[12345#查询端口进程ID杀掉。命令：taskkill /pid PID /f #其中 /f 表示强制关闭该进程 12#在命令行模式下输入sc查看命令：sc 123456CMD 调出服务：services.msc 查看服务语法：sc create | delete | config | start | stop | 服务名[参数]（具体百度。。。）demo：删除服务-&gt; sc delete mongodbnet （start | stop） mongodb 开启|关闭服务 123456#创建普通方式不能删除的文件夹：md E:\001..\#进入文件夹：start E:\001..\#删除文件夹：rd：E:\001..\（只能删除空目录！） 用sc create—-创建一个服务（增加到注册表中） 如下:在命令行模式下执行： sc create TestService binpath= “c:/in estapp.exe” displayname= “TestService” depend= Tcpip start= auto注意这里的格式，“=”后面是必须空一格的，否则会出现错误。 在提示建立成功后，可以直接输入“net start TestService” 来启动服务，或者可以直接在“管理工具”的“服务”中直接启动。 C:/Documents and Settings/Administrator&gt;sc create描述: 在注册表和服务数据库中创建服务项。 用法: sc create [service name] [binPath= ] …选项: 注意: 选项名称包括等号。type= (默认 = own) start= (默认 = demand) error= (默认 = normal) binPath= group= tag= depend= &lt;依存关系(以 / (斜杠) 分隔)&gt; obj= (默认 = LocalSystem) DisplayName= &lt;显示名称&gt; password= &lt;密码&gt; 用管理员身份打开了一个命令行程序，输入 sc 加上参数就可以了，使用办法很简单： sc delete “服务名”(如果服务名中间有空格，就需要前后加引号) 如针对上面的： sc delete KSD2Service sc 命令的详解，参看本文下方，Windows7之家/Vista之家已经帮您整理。 方法二：直接进行注册表编辑(不推荐) 打开注册表编辑器，找到下面的键值： HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services一般服务会以相同的名字在这里显示一个主健，直接删除相关的键值便可。四、特殊情况 1、如果服务显示的是rundll32.exe，并且这个文件是位于system32目录下，那么就不能删除这个rundll32.exe文件，它是Windows系统的文件。这时只要清除相关的服务就可以了。 2、如果一个服务删除了马上又自动建立了，说明后台有进程在监视、保护。需要先在进程管理器中杀掉相应的进程，或者启动后按F8，到Win7/Vista安全模式下删除。 ////// 附录：SC 命令行程序 参数详解 /////// 描述: SC 是用于与服务控制管理器和服务进行通信的命令行程序。 用法: sc [command] [service name] … 选项 的格式为 “\ServerName” 键入 “sc [command]” 可以获得有关命令的进一步帮助 命令: query———–查询服务的状态， 或枚举服务类型的状态。 queryex———查询服务的扩展状态， 或枚举服务类型的状态。 start———–启动服务。 pause———–向服务发送 PAUSE 控制请求。 interrogate—–向服务发送 INTERROGATE 控制请求。 continue——–向服务发送 CONTINUE 控制请求。 stop————向服务发送 STOP 请求。 config———-更改服务的配置(永久)。 description—–更改服务的描述。 failure———更改服务失败时执行的操作。 failureflag—–更改服务的失败操作标志。 sidtype———更改服务的服务 SID 类型。 privs———–更改服务的所需权限。 qc————–查询服务的配置信息。 qdescription—-查询服务的描述。 qfailure——–查询失败时服务执行的操作。 qfailureflag—-查询服务的失败操作标志。 qsidtype——–查询服务的服务 SID 类型。 qprivs———-查询服务的所需权限。 qtriggerinfo—-查询服务的触发器参数。 qpreferrednode–查询首选的服务 NUMA 节点。 delete———-(从注册表)删除服务。 create———-创建服务(将其添加到注册表)。 control———向服务发送控制。 sdshow———-显示服务的安全描述符。 sdset———–设置服务的安全描述符。 showsid———显示相应于假定名称的 SID 字符串。 triggerinfo—–配置服务的触发器参数。 preferrednode—设置首选的服务 NUMA 节点。 GetDisplayName–获取服务的 DisplayName GetKeyName——获取服务的 ServiceKeyName。 EnumDepend——枚举服务的依存关系。 下列命令不要求服务名称: sc boot————(ok bad) 指示是否将上一次启动保存为 最近一次已知的正确启动配置 Lock————锁定服务数据库 QueryLock——-查询 SCManager 数据库的 LockStatus 示例: sc start MyService QUERY 和 QUERYEX 选项: 如果查询命令带服务名称，将返回 该服务的状态。其他选项不适合这种 情况。如果查询命令不带参数或 带下列选项之一，将枚举此服务。 type= 要枚举的服务的类型(driver, service, all) 默认 = service) state= 要枚举的服务的状态 (inactive, all) (默认 = active) bufsize= 枚举缓冲区的大小(以字节计) (默认 = 4096) ri= 开始枚举的恢复索引号 (默认 = 0) group= 要枚举的服务组 (默认 = all groups) 语法示例 sc query - 枚举活动服务和驱动程序的状态 sc query eventlog - 显示 eventlog 服务的状态 sc queryex eventlog - 显示 eventlog 服务的扩展状态 sc query type= driver - 仅枚举活动驱动程序 sc query type= service - 仅枚举 Win32 服务 sc query state= all - 枚举所有服务和驱动程序 sc query bufsize= 50 - 枚举缓冲区为 50 字节 sc query ri= 14 - 枚举时恢复索引 = 14 sc queryex group= “” - 枚举不在组内的活动服务 sc query type= interact - 枚举所有不活动服务 sc query type= driver group= NDIS - 枚举所有 NDIS 驱动程序``` 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/Window-DOS命令删除服务！创建私密文件夹！解决端口占用等等问题！/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意文件隐藏在一张图片！]]></title>
    <url>%2F2016%2F07%2F02%2F%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E5%9C%A8%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1：准备一张图片，比如 a.jpg。准备目标文件，比如a.txt。我们要实现把a.txt隐藏在图片里面。2：把要隐藏的文件 a.txt 用 WinRAR 压缩。生成 a.rar 压缩包3：打开命令行提示符：点击“开始→运行”，输入“cmd”。4：我们假设中两个文件都存放在“ D:”下。输入命令：copy /b D:a.jpg + D:a.rar D:a.jpg5：ok，试试打开生成的图片 a.jpg，没错吧，的的确确是原来的图片。6：怎样打开那个 txt 文件？打开 WinRAR ，点击“文件→打开（快捷键 Ctrl + O ）”，然后选择文件类型为“所有文件”，找到 a.jpg ，选择打开看看，是不是有个 txt 文件？这种方法适用于所有文件,由于很多博客空间还没有支持附件上传的功能,这是上传文件的一个好方法呢! 命令格式：copy /b 文件1+文件2+……文件N 合并后的文件名命令讲解：使用”+”将多个相同或不同格式的文件合并为一个文件。小提示：1.在尾部隐藏了文本数据的图片文件，在使用了其他文件编辑器并保存后，隐藏的文本数据有可能丢失。2.MP3文件在使用此方法连接后，就可以实现连续播放。3.合成图片/歌曲这样的二进制文件必须使用/b参数（b代表Binaty,二进制），否则将会失败；另一个合并参数是/a(ASCII,文本文件），只能用于纯文本的合并。两参数不能同时使用，二进制方式可以合并文本文件和二进制文件，而文本方式用于纯文本的合并。、4.当进行软盘复制时，可在命令中加入”/v”参数，这样可以减少因操作介质的问题而导致的数据写入失败。 C:>copy /a 1.txt+rar.txt 3.txt1.txtrar.txt已复制 1 个文件。 C:>copy /b 1.jpg+1.txt 3.jpg1.jpg1.txt已复制 1 个文件。 copy /?将一份或多份文件复制到另一个位置。 COPY [/D] [/V] [/N] [/Y | /-Y] [/Z] [/A | /B ] source [/A | /B] [+ source [/A | /B] [+ …]] [destination [/A | /B]] source 指定要复制的文件。 /A 表示一个 ASCII 文本文件。 /B 表示一个二进位文件。 /D 允许解密要创建的目标文件 destination 为新文件指定目录和/或文件名。 /V 验证新文件写入是否正确。 /N 复制带有非 8dot3 名称的文件时， 尽可能使用短文件名。 /Y 不使用确认是否要改写现有目标文件 的提示。 /-Y 使用确认是否要改写现有目标文件 的提示。 /Z 用可重新启动模式复制已联网的文件。 命令行开关 /Y 可以在 COPYCMD 环境变量中预先设定。这可能会被命令行上的 /-Y 替代。除非 COPY命令是在一个批文件脚本中执行的，默认值应为在改写时进行提示。 要附加文件，请为目标指定一个文件，为源指定数个文件(用通配符或 file1+file2+file3 格式)。 经测试，发现因为txt默认的是ANSI编码，单纯的字符文件，没有文件头，所以合并txt即可看作合并文本！ 因为测试的不多，用txt和doc测试了下，默认使用/a模式。测试中的差别是/a在最后多插入了一个十六进制的“1A”！暂时没发现其他差别！ 而其他编码的txt是编码标记+文字编码的模式，合并的话，如果是相同编码，会正常显示，但是编码标记重复了，不确定其他工具是否正常显示，不一样的编码合并就是以下情况！123???123?123??123? 5 6 刚才查到con不能做文件名，真的耶！但可以做后缀名！con.txt和con都不行，con1和1.con可以！在ext下也不行，估计只是操作系统原因，不知道linux系统行不！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/任意文件隐藏在一张图片！/]]></content>
      <categories>
        <category>Windows相关</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android、IOS、PHP之间对称AES加密解密!]]></title>
    <url>%2F2016%2F07%2F02%2FAndroid%E3%80%81IOS%E3%80%81PHP%E4%B9%8B%E9%97%B4%E5%AF%B9%E7%A7%B0AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86!%2F</url>
    <content type="text"><![CDATA[###php:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899$aes = new aes;echo $aes-&gt;aes128cbcEncrypt(&quot;11122222&quot;);echo &quot;\n&quot;;echo $aes-&gt;aes128cbcEncrypt(&quot;中文aes演示&quot;);echo &quot;\n&quot;;class aes&#123; const KEY=&quot;625202f9149e061d&quot;; const IV =&quot;5efd3f6060e20330&quot;; /** * pkcs7补码 * @param string $string 明文 * @param int $blocksize Blocksize , 以 byte 为单位 * @return String */ private function addPkcs7Padding($string, $blocksize = 32) &#123; $len = strlen($string); //取得字符串长度 $pad = $blocksize - ($len % $blocksize); //取得补码的长度 $string .= str_repeat(chr($pad), $pad); //用ASCII码为补码长度的字符， 补足最后一段 return $string; &#125; /** * 加密然后base64转码 * * @param String 明文 * @param 加密的初始向量（IV的长度必须和Blocksize一样， 且加密和解密一定要用相同的IV） * @param $key 密钥 */ function aes256cbcEncrypt($str, $iv, $key ) &#123; return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $this-&gt;addPkcs7Padding($str) , MCRYPT_MODE_CBC, $iv)); &#125; /** * 除去pkcs7 padding * * @param String 解密后的结果 * * @return String */ private function stripPkcs7Padding($string)&#123; $slast = ord(substr($string, -1)); $slastc = chr($slast); $pcheck = substr($string, -$slast); if(preg_match(&quot;/$slastc&#123;&quot;.$slast.&quot;&#125;/&quot;, $string))&#123; $string = substr($string, 0, strlen($string)-$slast); return $string; &#125; else &#123; return false; &#125; &#125; /** * 解密 * * @param String $encryptedText 二进制的密文 * @param String $iv 加密时候的IV * @param String $key 密钥 * @return String */ function aes256cbcDecrypt($encryptedText, $iv, $key) &#123; $encryptedText =base64_decode($encryptedText); return $this-&gt;stripPkcs7Padding(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $encryptedText, MCRYPT_MODE_CBC, $iv)); &#125; function aes128cbcDecrypt($encryptedText, $iv=self::IV, $key=self::KEY) &#123; $encryptedText =base64_decode($encryptedText); return $this-&gt;stripPkcs7Padding(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $encryptedText, MCRYPT_MODE_CBC, $iv)); &#125; function hexToStr($hex)//十六进制转字符串 &#123; $string=&quot;&quot;; for($i=0;$i&lt;strlen($hex)-1;$i+=2) $string.=chr(hexdec($hex[$i].$hex[$i+1])); return $string; &#125; function strToHex($string)//字符串转十六进制 &#123; $hex=&quot;&quot;; $tmp=&quot;&quot;; for($i=0;$i&lt;strlen($string);$i++) &#123; $tmp = dechex(ord($string[$i])); $hex.= strlen($tmp) == 1 ? &quot;0&quot;.$tmp : $tmp; &#125; $hex=strtoupper($hex); return $hex; &#125; function aes128cbcHexDecrypt($encryptedText, $iv=self::IV, $key=self::KEY) &#123; $str = $this-&gt;hexToStr($encryptedText); return $this-&gt;stripPkcs7Padding(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $str, MCRYPT_MODE_CBC, $iv)); &#125; function aes128cbcEncrypt($str, $iv=self::IV, $key=self::KEY ) &#123; // $this-&gt;addPkcs7Padding($str,16) $base = (mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key,$this-&gt;addPkcs7Padding($str,16) , MCRYPT_MODE_CBC, $iv)); return $this-&gt;strToHex($base); &#125;&#125; ###IOS:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //对数据进行解密 NSData* result = [data aes256_decrypt:key]; if (result &amp;&amp; result.length &gt; 0) &#123; return [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding]; &#125; return nil;&#125;@end@implementation NSData (AES256)- (NSData *)aes256_encrypt:(NSString *)key //加密&#123; char keyPtr[kCCKeySizeAES256+1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSUInteger dataLength = [self length]; size_t bufferSize = dataLength + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding , keyPtr, kCCBlockSizeAES128, [AES_IV UTF8String], [self bytes], dataLength, buffer, bufferSize, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; &#125; free(buffer); return nil;&#125;- (NSData *)aes256_decrypt:(NSString *)key //解密&#123; char keyPtr[kCCKeySizeAES256+1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSUInteger dataLength = [self length]; size_t bufferSize = dataLength + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); size_t numBytesDecrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding , keyPtr, kCCBlockSizeAES128, [AES_IV UTF8String], [self bytes], dataLength, buffer, bufferSize, &amp;numBytesDecrypted); if (cryptStatus == kCCSuccess) &#123; return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted]; &#125; free(buffer); return nil;&#125;@end ###android:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package com.example.aes;import java.io.UnsupportedEncodingException;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * AES加密解密算法 */public class AesEncryptionUtil &#123; /** 算法/模式/填充 **/ private static final String CipherMode = &quot;AES/CBC/PKCS5Padding&quot;; /** 创建密钥 **/ private static SecretKeySpec createKey(String key) &#123; byte[] data = null; if (key == null) &#123; key = &quot;&quot;; &#125; StringBuffer sb = new StringBuffer(16); sb.append(key); while (sb.length() &lt; 16) &#123; sb.append(&quot;0&quot;); &#125; if (sb.length() &gt; 16) &#123; sb.setLength(16); &#125; try &#123; data = sb.toString().getBytes(&quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return new SecretKeySpec(data, &quot;AES&quot;); &#125; private static IvParameterSpec createIV(String password) &#123; byte[] data = null; if (password == null) &#123; password = &quot;&quot;; &#125; StringBuffer sb = new StringBuffer(16); sb.append(password); while (sb.length() &lt; 16) &#123; sb.append(&quot;0&quot;); &#125; if (sb.length() &gt; 16) &#123; sb.setLength(16); &#125; try &#123; data = sb.toString().getBytes(&quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return new IvParameterSpec(data); &#125; /** 加密字节数据 **/ public static byte[] encrypt(byte[] content, String password, String iv) &#123; try &#123; SecretKeySpec key = createKey(password); Cipher cipher = Cipher.getInstance(CipherMode); cipher.init(Cipher.ENCRYPT_MODE, key, createIV(iv)); byte[] result = cipher.doFinal(content); return result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** 加密(结果为16进制字符串) **/ public static String encrypt(String content, String password, String iv) &#123; byte[] data = null; try &#123; data = content.getBytes(&quot;UTF-8&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; data = encrypt(data, password, iv); String result = byte2hex(data); return result; &#125; /** 解密字节数组 **/ public static byte[] decrypt(byte[] content, String password, String iv) &#123; try &#123; SecretKeySpec key = createKey(password); Cipher cipher = Cipher.getInstance(CipherMode); cipher.init(Cipher.DECRYPT_MODE, key, createIV(iv)); byte[] result = cipher.doFinal(content); return result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** 解密(输出结果为字符串) **/ public static String decrypt(String content, String password, String iv) &#123; byte[] data = null; try &#123; data = hex2byte(content); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; data = decrypt(data, password, iv); if (data == null) return null; String result = null; try &#123; result = new String(data, &quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return result; &#125; /** 字节数组转成16进制字符串 **/ public static String byte2hex(byte[] b) &#123; // 一个字节的数， StringBuffer sb = new StringBuffer(b.length * 2); String tmp = &quot;&quot;; for (int n = 0; n &lt; b.length; n++) &#123; // 整数转成十六进制表示 tmp = (java.lang.Integer.toHexString(b[n] &amp; 0XFF)); if (tmp.length() == 1) &#123; sb.append(&quot;0&quot;); &#125; sb.append(tmp); &#125; return sb.toString().toUpperCase(); // 转成大写 &#125; /** 将hex字符串转换成字节数组 **/ private static byte[] hex2byte(String inputString) &#123; if (inputString == null || inputString.length() &lt; 2) &#123; return new byte[0]; &#125; inputString = inputString.toLowerCase(); int l = inputString.length() / 2; byte[] result = new byte[l]; for (int i = 0; i &lt; l; ++i) &#123; String tmp = inputString.substring(2 * i, 2 * i + 2); result[i] = (byte) (Integer.parseInt(tmp, 16) &amp; 0xFF); &#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/07/02/Android、IOS、PHP之间对称AES加密解密!/]]></content>
      <categories>
        <category>Android和IOS相关</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-索引笔记！]]></title>
    <url>%2F2016%2F06%2F12%2Fmysql-%E7%B4%A2%E5%BC%95%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[###mysql的索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引. #####单列索引:一个索引只包含一个列,一个表可以有多个单列索引. #####组合索引:一个组合索引包含两个或两个以上的列, ####表结构如下：1234567user CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(25) COLLATE utf8_unicode_ci NOT NULL, `password` varchar(32) COLLATE utf8_unicode_ci NOT NULL, `email` varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&apos;测试用户信息表&apos;; ###一、单列索引（只有一个字段） #####增加索引： 123456789101112131415161718192021222324252627282930313233343536 1. 主键索引 ：（建立的规则是 int优于varchar，一般在建表的时候创建，一个表只能有一个主键）//语法如下：alter table 表名 add primary key 索引名(字段名); //demo如下：alter table user add primary key id(id); primary主键，如果插入值有重复会报类似错误：Duplicate entry &apos;4&apos; for key &apos;PRIMARY&apos;2. 唯一索引 ：（字段值可以为NULL，但必须唯一）//语法如下：create unique index 索引名 on 表名(字段名);//第一种写法alter table 表名 add unique index 索引名(字段名); //第二种写法//demo如下：create unique index index_username on user(username);alter table user add unique index index_username(username); unique唯一，如果插入值有重复会报类似错误：Duplicate entry &apos;username&apos; for key &apos;index_username&apos;3. 普通索引 ：//语法如下：create index 索引名 on 表名(字段名);//第一种写法alter table 表名 add index 索引名(字段名); //第二种写法//demo如下：create index index_username on user(username);alter table user add index index_username(username); 4. 全文索引：（InnoDB不支持，MyISAM支持性能比较好，一般在 CHAR、VARCHAR 或 TEXT 列上创建。）//语法如下： alter table 表名 add fulltext （索引名：不填默认字段名）(字段名); //demo如下： alter table user add fulltext （test）（`desc`）; #####二、组合索引：（多个字段）12345//语法如下：create index 索引名 on 表名(字段名，字段名，... ); //demo如下：create index index_u_e_m on user(username,email,token); #####查看索引： 1234//语法如下：show index from 表名;//demo如下：show index from user; #####删除索引： 12345//语法如下：alter table `库名`.`表名` drop index `索引名`;//demo如下：alter table `1234567890`.`user` drop index `index_email`; //第一种写法drop index index_email ON `user` ; //第二种写法 like 模糊查询使用索引 demo：12explain select * from user where username like &apos;a%&apos;;explain select * from user where username like &apos;%a&apos;; like ‘a%’ 会用到 索引： like语句的 如果你对字段建立了一个索引.当查询的时候的语句是 lick ‘%ABC%’ 那么这个索引讲不会起到作用.而lick ‘ABC%’ 那么将可以用到索引！ 索引不会包含NULL列,如果列中包含NULL值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ‘ ‘字符串！ 不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描！ 当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/mysql-索引笔记！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows安装composer笔记！]]></title>
    <url>%2F2016%2F06%2F12%2Fwindows%E5%AE%89%E8%A3%85composer%E7%AC%94%E8%AE%B0%EF%BC%81-%2F</url>
    <content type="text"><![CDATA[Composer下載地址：https://getcomposer.org/是否通过代理（proxy），取消勾选！安装完成使用命令 composer 或 composer -v 检测安装成功与否！ composer的安装位置和协议秘钥位置：安装位置： 秘钥位置： 将“Packagist镜像地址”更改为国内镜像，在命令行中输入：1composer config -g repo.packagist composer https://packagist.phpcomposer.com 接下来我们在工作环境下cmoposer目录，在命令行中输入：1composer require monolog/monolog 生成如下文件： composer 的常用命令composer install依据当前目录下的 composer.lock（锁文件） 或 composer.json 文件所定义的依赖关系，安装依赖包。install 命令会先检查锁文件是否存在，如果存在，它将下载 composer.lock 文件中指定的版本，而忽略 composer.json 文件中的定义。 composer update如果你想更新你的依赖版本或者说你修改了 composer.json 中的依赖关系，想让 composer 按照 composer.json 文件中的定义执行更新操作，就用 composer update 命令。 composer selfupdate更新 composer 本身，请经常执行 composer selfupdate 以保持 Composer 一直是最新版本。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/windows安装composer笔记！-/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows通过JS调用打印机接口打印订单信息！]]></title>
    <url>%2F2016%2F06%2F12%2Fwindows%E9%80%9A%E8%BF%87JS%E8%B0%83%E7%94%A8%E6%89%93%E5%8D%B0%E6%9C%BA%E6%8E%A5%E5%8F%A3%E6%89%93%E5%8D%B0%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%EF%BC%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html id=&quot;all&quot;&gt;&lt;head&gt; &lt;META http-equiv=Content-Type content=&quot;text/html; charset=utf-8&quot;&gt; &lt;LINK href=&quot;__TMPL__css/admin.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;__TMPL__new/css/common.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;__TMPL__script/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;&lt;/title&gt; &lt;style media=&quot;print&quot;&gt; .Noprint&#123;display:none;&#125;&lt;!-- 用本样式在打印时隐藏非打印项目 --&gt; .PageNext&#123;page-break-after: always;&#125;&lt;!--控制分页 --&gt; &lt;/style&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;!-- #print_border&#123;width:1300px;height:700px;border:0px solid #ccc;margin:20px 50px;overflow:auto&#125; #print-context&#123;width:100%;&#125; #print-button&#123;width:100%;height:40px;margin-bottom:0px;text-align:center;padding-top:10px;&#125; #print-button input[type=&apos;button&apos;]&#123;width:100px;height:30px;font-size:16px;&#125; #print-context .tit&#123;width:100%;height:30px;line-height:30px;background:#ccc;font-size:16px;text-align:center;letter-spacing:8px;font-weight:900;&#125; .orderinfo&#123;width:100%;&#125; .orderinfo tr&#123;height:40px;&#125; .orderinfo tr td.ord-tit&#123;width:15%;text-align:right;border-bottom:1px solid #ccc;letter-spacing:4px;&#125; .orderinfo tr td.ord-text&#123;width:34.5%;border-bottom:1px solid #ccc;padding-left:0.5%;&#125; .gs&#123;margin-top:40px;&#125; .goodsinfo&#123;width:100%;text-align:center;margin-top:10px;&#125; .goodsinfo tr&#123;height:30px;&#125; --&gt; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //调用打印机接口，打印当前指定网页 function prints() &#123; var newstr = document.getElementById(&apos;print-context&apos;).innerHTML; var oldstr = document.body.innerHTML; document.body.innerHTML = &quot;&lt;div id=&apos;print-context&apos;&gt;&quot; + newstr + &quot;&lt;/div&gt;&quot;; window.print(); document.body.innerHTML = oldstr; return false; &#125; $(function() &#123; //隔行变色 $(&quot;#proinfo tr:even&quot;).css(&quot;background-color&quot;, &quot;#F6FAFD&quot;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--startprint--&gt; &lt;div id=&quot;print_border&quot;&gt; &lt;div id=&quot;print-context&quot;&gt; &lt;div class=&quot;tit&quot; style=&quot;background-color: rgb(247, 250, 252);&quot;&gt;订单信息&lt;/div&gt; &lt;table class=&quot;orderinfo&quot; cellspacing=0 cellpadding=0 &gt; &lt;tr&gt; &lt;td class=&quot;ord-tit&quot;&gt;订单号:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.orderid&#125;&gt;&lt;/td&gt; &lt;td class=&quot;ord-tit&quot;&gt; &lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;ord-tit&quot;&gt;收货人:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.rejname&#125;&gt;&lt;/td&gt; &lt;td class=&quot;ord-tit&quot;&gt;电子邮件:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.email&#125;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;ord-tit&quot;&gt;地址:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.shen&#125;&gt;|&lt;&#123;$d_order.shi&#125;&gt;|&lt;&#123;$d_order.qu&#125;&gt;|&lt;&#123;$d_order.more&#125;&gt;&lt;/td&gt; &lt;td class=&quot;ord-tit&quot;&gt;邮编:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.youbian&#125;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;ord-tit&quot;&gt;电话:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.tel&#125;&gt;&lt;/td&gt; &lt;td class=&quot;ord-tit&quot;&gt;手机:&lt;/td&gt; &lt;td class=&quot;ord-text&quot;&gt;&lt;&#123;$d_order.mob&#125;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 商品信息 --&gt; &lt;div class=&quot;tit gs&quot; style=&quot;background-color: rgb(247, 250, 252);&quot;&gt;商品信息&lt;/div&gt; &lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; align=&quot;center&quot;&gt; &lt;tbody&gt; &lt;tr height=&quot;12&quot; &gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table class=&quot;all_table&quot; width=&quot;100%&quot; border=&quot;0&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;1&quot; bgcolor=&quot;#E3EFFB&quot; id=&quot;proinfo&quot;&gt; &lt;tr class=&quot;table_tr_bor&quot; style=&quot;background-color: rgb(247, 250, 252);&quot;&gt; &lt;td width=&quot;21%&quot; height=&quot;32&quot; align=&quot;center&quot;&gt;商品名称&lt;/td&gt; &lt;td width=&quot;8%&quot; align=&quot;center&quot;&gt;供应商商品编号&lt;/td&gt; &lt;td width=&quot;5%&quot; align=&quot;center&quot;&gt;价格&lt;/td&gt; &lt;td width=&quot;5%&quot; align=&quot;center&quot;&gt;数量&lt;/td&gt; &lt;td width=&quot;10%&quot; align=&quot;center&quot;&gt;属性&lt;/td&gt; &lt;td width=&quot;5%&quot; background=&quot;__TMPL__images/adminbghen.jpg&quot;&gt;&lt;div align=&quot;center&quot;&gt;小计&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;volist name=&quot;pros&quot; id=&quot;vo&quot;&gt; &lt;tr bgcolor=&quot;#FFFFFF&quot;&gt; &lt;!-- &lt;td width=&quot;5%&quot; bgcolor=&quot;#FFFFFF&quot;&gt; &lt;/td&gt; --&gt; &lt;td width=&quot;21%&quot; align=&quot;center&quot;&gt; &lt;img src=&quot;http://mall.3d414.com/Tpl/default/upload/&lt;&#123;$vo.img&#125;&gt;&quot;&gt; &lt;p&gt;订单编号：&lt;&#123;$vo.c_ordernum&#125;&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://www.3d414.com/home/detail/index/id/&lt;&#123;$vo.proid&#125;&gt;&quot; target=&quot;_blank&quot;&gt;&lt;&#123;$vo.title&#125;&gt;&lt;/a&gt;&lt;/p&gt; &lt;br /&gt; &lt;/td&gt; &lt;td width=&quot;8%&quot; align=&quot;center&quot;&gt;&lt;&#123;$vo.jmnumb&#125;&gt;&lt;/td&gt; &lt;td width=&quot;5%&quot; align=&quot;center&quot;&gt;&lt;&#123;$vo.price&#125;&gt;&lt;/td&gt; &lt;td width=&quot;5%&quot; align=&quot;center&quot;&gt;&lt;&#123;$vo.num&#125;&gt;&lt;/td&gt; &lt;td width=&quot;10%&quot; align=&quot;center&quot;&gt;颜色:&lt;&#123;$vo.ys&#125;&gt; 尺码:&lt;&#123;$vo.cm&#125;&gt;&lt;/td&gt; &lt;td width=&quot;5%&quot; align=&quot;center&quot;&gt;&lt;&#123;$vo.spprice&#125;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/volist&gt; &lt;/table&gt; &lt;/div&gt; &lt;!--print-btn-start--&gt; &lt;div id=&quot;print-button&quot; class=&quot;Noprint&quot;&gt; &lt;input class=&quot;input_btn_ btn_normal&quot; type=&quot;button&quot; value=&quot;打 印&quot; onclick=&quot;prints();&quot;/&gt; &lt;/div&gt; &lt;!--print-btn-end--&gt; &lt;/div&gt; &lt;!--endprint--&gt;&lt;/body&gt;&lt;/html&gt; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/windows通过JS调用打印机接口打印订单信息！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JavaScript</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-写文章创建文件自动打开编辑器！]]></title>
    <url>%2F2016%2F06%2F12%2Fhexo-%E5%86%99%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%81%2F</url>
    <content type="text"><![CDATA[#####hexo gitHub地址：https://github.com/hexojs/hexo #####hexo 文档：https://hexo.io/zh-cn/api/events.html备份Hexo博客源文件参考Blog！：https://notes.wanghao.work/2015-04-06-%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html https://notes.wanghao.work/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html正常情况下通过 hexo new “文件名” 创建文章。就会在在 Hexo 的根目录的 source 文件夹下的 _posts 目录下自动帮你创建相应的 md 文件。 1hexo new &quot; hexo 添加文章时自动打开编辑 ! &quot; 如果_post文件夹下文章很多的时候，找起来就会很不方便。https://github.com/hexojs/hexo.Hexo作者也给出来解决办法： ou can try to listen to the new event. For example:123456789var spawn = require(&apos;child_process&apos;).exec;// Hexo 2.xhexo.on(&apos;new&apos;, function(path)&#123; exec(&apos;vi&apos;, [path]);&#125;);// Hexo 3hexo.on(&apos;new&apos;, function(data)&#123; exec(&apos;vi&apos;, [data.path]);&#125;); 在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。如果没有这个scripts目录，则新建一个。scripts目录新建的 js 脚本文件可以任意取名。windows平台的Hexo用户操作如下： auto_open.js 内容如下：12345678910var spawn = require(&apos;child_process&apos;).exec;// Hexo 2.x 用户复制这段//hexo.on(&apos;new&apos;, function(path)&#123;// spawn(&apos;start &quot;markdown编辑器绝对路径.exe&quot; &apos; + path);//&#125;);//D:\WorkPlace\MarkdownPad\MarkdownPad2.exe 是MakdownPad编辑器在我本地的路径！// Hexo 3 用户复制这段hexo.on(&apos;new&apos;, function(data)&#123; spawn(&apos;start &quot;D:\WorkPlace\MarkdownPad\MarkdownPad2.exe&quot; &apos; + data.path);&#125;); Mac平台Hexo用户操作如下（未测试）：123456789var exec = require(&apos;child_process&apos;).exec;// Hexo 2.x 用户复制这段// hexo.on(&apos;new&apos;, function(path)&#123;// exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + path);//&#125;);// Hexo 3 用户复制这段hexo.on(&apos;new&apos;, function(data)&#123; exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + data.path);&#125;); 然后再创建文件输入命令之后就会自动打开MarkdownPad编辑器来编辑了。1hexo new &quot;auto open editor test&quot; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/hexo-写文章创建文件自动打开编辑器！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL学习笔记！]]></title>
    <url>%2F2016%2F06%2F12%2FMYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[123数据类型-整数类型tinyint(1), smallint(2), mediumint(3),int(4), bigint(8)。括号中表示该类型所占空间的长度（字节数）整数类型通用设定形式： 类型名[(M)] [unsigned] [zerofill]。 12345678数据类型-小数类型单精度浮点型：float，范围大约是-3.4E+38到-1.1E-38、0和1.1E-38到3.4E+38双精度浮点型：double，范围大约是-1.7E+308到-2.2E-308、0和2.2E-308到 1.7E+308。 real是double的别名。定点型：decimal，也可以写成：dec，numeric，fixed（当然后3者尽量不用）。decimal类型整数最大65位，小数最大30位（均以10进制计） 12345678910数据类型-字符类型定长字符串char：不足设定值，则右侧自动填空格；最大255个字符，有编码问题变长字符串varchar：最大65532个字节，实际还得考虑一行的其他字段所占的长度，因为一行的最大长度是65534个字节，有编码问题定长二进制字符串binary：类似char，只是按“字节”存字符数据，最大255个字节，无编码问题变长二进制字符串varbinary：类似varchar，只是按“字节”存字符数据，最大65532个字节，无编码问题 12345678文本列类型text：用于存储普通文本，不受行的最大长度的限制，同类还有：tinytext, mediuntext, longtext二进制列类型blob：用于存储二进制字节内容，不受行的最大长度的限制，同类的还有：tinyblob, mediumblob, longblob枚举类型enum：enum(&apos;value1&apos;, &apos;value2&apos;, ... )set类型set(&apos;value1&apos;, &apos;value2&apos;, ...) 123456789date类型： 支持的范围为&apos;1000-01-01&apos;到&apos;9999-12-31&apos;time类型： 支持的范围是&apos;-838:59:59&apos;到&apos;838:59:59&apos;datetime类型：支持的范围是&apos;1000-01-01 00:00:00&apos;到&apos;9999-12-31 23:59:59&apos;timestamp类型：时间戳，就是表示“当前时刻”，用于INSERT或UPDATE操作时自动获得当前时间year类型： 四位字符串，范围为&apos;1901&apos;到&apos;2155&apos; 1234567891011mysql编程-内置函数数值函数：abs(x), //x代表一个数字，下同。ceiling(x),floor(x), pi(), pow(x,y), rand()：select * from table order by rand() limit 10; //随机从表中取10条记录round(x), sqrt(x); 123456789101112131415161718192021222324252627282930313233343536373839字符串函数: (以下x表示一个数字，str表示一个字符串)ascii(str)：返回str的ascii码 bin(x)：获取数字x的二进制字符串形式cast(exp as char): 将exp转换为char类型char(x1,x2, ...): 返回若干个数字对应的字符串char_length(str): 返回字符数，length(x)返回字节数concat(str1,str2,...): 连接字符串，任何字符串和null进行连接的结果都将是null concat_ws(sep,str1,str2,....) 連接字符串，用sep分割。group_concat(str1,str2,...) 连接字符串，任何字符串和null进行连接的结果都将是null format(x, d): 将数字x格式化为“##,###,###.###”的字符形式，并保留d位 instr(str, substr): 取得str中第一次出现substr的位置（位置从1开始算起） lcase(str)lower(str)：小写ucase(str)upper(str)：大写left(str, x): 取得s左边 x 个字符right(str,x)：取得右边 x 个字符lpad(str,len,padstr): 用字符串 padstr 对 str 最左边填充，直到长度为 len 个字符长度rpad(str, len, padstr):用字符串 padstr 对 str 最右边填充，直到长度为 len 个字符长度ltrim(str):左边去空格rtrim(str)右边去空格trim(str)两边去空格repeat(str, count): 返回重复str字符count次。replace(str,a,b):字符串 str中 查找所有 a 字符，替换成 b 字符。insert(str,x,y,instr):将str，从x位置开始，y长的字符串替换为字符串 instr ；案例： select inset(&apos;abcdefg&apos;,4,4,&apos;1234&apos;) 结果：abc1234reverse(str):反转字符strcmp(str1, str2): 比较字符串s1和s2的ASCII码值的大小。如果s1比s2下，那么返回-1；如果s1和s2相等，那么返回0；如果s1和s2大，那么返回1mid(str, x, y): 截取字符串str，从 x 位置开始，取 y 个substring(str,x,y):截取字符串str，从x位置开始( x 为正从左开始，x 为负从右开始)，取y（四舍五入取整数）个substring_index(str,x,y); 用 x 拆分字符串 str ，取 y （y为正从左，为负从右开始）个拆分的值 123456789时间日期函数: (以下t, t1, t2均表示一个时间/日期数据)addtime(t1,t2)：将时间t2加到时间t1上curdate(), current_date();curtime(), current_time();date(t): 取得t的日期部分(即年月日）day(t):取得t的日期数（1-31）dayname(t): 取得星期名(英文单词）dayofweek(t): 取得星期数（1-7）datediff(t1, t2): 取得t1和t2相差的天数，t1大则为正数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849时间日期函数: (以下t, t1, t2均表示一个时间/日期数据)FROM_UNIXTIME(time,&apos;%Y-%m-%d %H:%i:%s&apos;) : 如果数据库 time 字段存的是int型，要转换成date 或者 datetime 或者 time类型select *,FROM_UNIXTIME(create_time,&apos;%Y-%m-%d %H:%i:%s&apos;) add_time from user；date_add(t, interval 数字n 单位u): 将时间t加上n个单位u（比如3个day，5个hour），实际上如果n为负数，就是减去。常用单位有：year, month, day, hour, minute, second, weekdate_format(t, &apos;格式字符f&apos;)：格式字符f常用有：%Y, %y,%m, $d, %H, %h, %i, %sextract(时间项u from t）：从t中取得时间的某项值，比如年份数，月份数；时间项u的常用词有：year, month, day, hour, minute, second, weeklocaltime(): 同now();maketime(时，分，秒）：month(t)：取得月份数（1-12）year(t)：取得年份数CURDATE或CURRENT_DATE 返回当前的日期CURTIME或CURRENT_TIME 返回当前的时间DATE_ADD(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);DATE_FORMAT(date,fmt) 依照指定的fmt格式格式化日期date值DATE_SUB(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH);DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7)DAYOFMONTH(date) 返回date是一个月的第几天(1~31)DAYOFYEAR(date) 返回date是一年的第几天(1~366)DAYNAME(date) 返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳tsHOUR(time) 返回time的小时值(0~23)MINUTE(time) 返回time的分钟值(0~59)MONTH(date) 返回date的月份值(1~12)MONTHNAME(date) 返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);NOW 返回当前的日期和时间QUARTER(date) 返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);WEEK(date) 返回日期date为一年中第几周(0~53)YEAR(date) 返回日期date的年份(1000~9999) 123456聚合函数：（以下col表示一列，通常就是字段名）avg(col)：取得一列的平均值count(col)：取得一列的非null值的个数min(col)：取得一列的最小值；max(col)：取得一列的最大值；sum(col)：取得一列的总和 1234567其他函数md5(str): md5加密函数password(str): 加密函数sha1(str): 加密函数user(), current_user();database();version(); 12345678910111213141516171819//创建函数：create function getPingfanghe(x float, y float)returns floatbegin #此函数体范围内，就是所谓的“编程环境” set @result = x*x + y*y; #“定义”会话变量并赋值 return @result;end;create function getPingfanghe2(x float, y float)returns floatbegin #此函数体范围内，就是所谓的“编程环境” #此范围就可以使用普通变量，已经各种流程控制结构 declare result float default 0; #定义普通变量并设定初值 set result = x*x + y*y; return result;end; 123456//创建过程：//此存储过程意图用于传入两个数据并将该两个数据插入表enum_test中。create procedure pro1 (n int, xuanxiang varchar(20) )begin insert into enum_test (id, xuanxiang)values(n, xuanxiang);end; 1234567//再来写一个具有out作用的存储过程：create procedure getXiebian( z1 float, z2 float, out xiebian float)begin set @pingfanghe = getPingfanghe(z1, z2);#调用函数去计算平方和 set xiebian = pow(@pingfanghe, 0.5);end;//该存储过程调用的时候，第3个参数必须是一个变量 1234567//写一个存储过程中使用select：create procedure gettables()begin select * from enum_test; select * from set_test; select * from tab5;end; 123456789101112//定义一个触发器，让该触发器可以在tab5插入数据的时候，//自动将其实不部分数据插入另一个表中以供“外方合作单位”使用。//tab5的字段为：id, f1, f2, f4, id2;//要插入的另一个表的字段为：id, f1, f2create trigger getSubData after insert on tab5 for each row begin #set @id = new.id; #new在触发器中是特定关键字， #代表“刚刚插入的数据行”，这里代表其中的该行数据的id值 #set @v1 = new.f1; #新插入数据的f1字段的值 #set @v2 = new.f2; #新插入数据的f1字段的值 insert into tab5_sub (f1, f2)values(new.f1,new.f2);end; mysql 关联查询join的两种写法1234567891011//第一种SELECT u.id,u.username from db_admin_user u inner join db_admin_role_user j on u.id=j.user_id inner join db_admin_role r on j.role_id=r.id where u.id&lt;10//第二种SELECT u.id,u.username from db_admin_user u inner join(db_admin_role_user j ,db_admin_role r) on (u.id=j.user_id and j.role_id=r.id) where u.id&lt;10 什么是事务通常，在此之前，我们说，一条语句使用一个分号（;）来结束，并得到执行。那么我们说，这个“一次性执行”的过程，可以称为“一个事务”。简单来说，“一条ｓｑｌ语句，就是一个事务”。则：数据库（自然包括mysql数据库）中的事务，是指，可以将“多条语句”的执行，当作“一条语句”来看到的一种内部机制。即：“事务”是一种可以保证“多条语句一次性执行完成”或“一条都不执行”的机制。 事务的特点原子性：一个事务中的所有语句，应该做到：要么全做，要么一个都不做；一致性：让数据保持逻辑上的“合理性”，比如：一个商品出库时，既要让商品库中的该商品数量减1，又要让对应用户的购物车中的该商品加1；隔离性：如果多个事务同时并发执行，但每个事务就像各自独立执行一样。持久性：一个事务执行成功，则对数据来说应该是一个明确的硬盘数据更改（而不仅仅是内存中的变化）。事务模式：事务模式：就是让每条执行语句是否当作“一个事务”来看到的设定项。 mysql默认安装好之后，其事务模式是：一条语句当作一个事务。比如：原来数据：执行插入：结果： 我们可以将其修改为：事务需要“认可”模式：set autocommit = 0; //false，关闭该模式，即此时不再是一条语句一个事务了。//结果是：必须使用commit语句才能够生效。 然后插入：刷新：可见，没有变化。然后再执行commit：再刷新； 注意：autocommit的设置值，只是影响通常情况下都每条语句的默认行为（自动提交还是等着commit提交） 不管autocommit的值是什么（１，０），我们也仍然可以使用事务的完整流程模式来实现事务，如下：事务的基本实现流程：１，声明事务开始：ｓｔａｒｔ ｔｒａｎｓａｃｔｉｏｎ；2， 设定多条要执行的具体语句，比如：insert， update， delete, select。。。其实就是执行，只是这些执行的语句，并不“生效”——其只是内存状态下的执行，而不是物理状态的执行。3，判断是否需要执行该些语句：if( 判断是否有错误）{//执行——才针对执行了物理性改变——即生效。commit;}eslse{//回滚——不执行任何语句。rollback;}判断是否有错误通常分这两种环境：１，如果是cmd中，直接观察是否出错。 2，如果是php程序中，那就需要使用 mysql_error()函数来判断是否有错。 下来来使用事务完整转账这件事情（假设为cmd模式）：start transaction; #第一步：update cunkuan set 存款=存款-4000 where id=2； #第一步做完，突然断电了？ #第二步：update cunkuan set 存款=存款+4000 where id=1；则如果这两条语句都没有错误，就可以：commit;但，如果其中发生了错误，则可以：rollback； mysql编程基本语法形式语句块模式： 在mysql编程中，begin….end;基本代替了原来编程语句中的{…}语法。但又有所区别：一个bigin…end;块，可以给定一个“标识符”，并且可以使用leave语句来“退出”该语句块。基本流程控制语句：ｉｆ语句： ｃａｓｅ语句：（类似ｐｈｐ中的ｓｗｉｔｃｈ） ｗｈｉｌｅ循环语句： ｍｙｓｑｌ中的变量变量它有一定的使用场景限制（其实包括前面的流程控制语句也这样）：在通常的执行各种create，insert，delete，update，select等语句的“环境”中，并不使用常规变量，也不能使用流程控制语句。其实，这些语句只能在编程环境中用——通常的增删改查，可以称为命令环境。编程环境：存储函数中，存储过程中，触发器中。普通变量的声明语法：declare 变量名 变量类型 [default 初始值]变量的赋值语法：set 变量名 = 变量值mysql还有一种变量形式，可以称为“会话变量”会话变量的形式为： @变量名；会话变量无需单独声明，而是直接赋值就可以，类似php会话变量的赋值： set 变量名 = 值；会话变量可以在普通命令行环境中或编程环境中使用。语法1：set 变量名 = 表达式；#此语法中的变量必须先使用declare声明 语法2：set @变量名 = 表达式； #此方式可以无需declare语法声明，而是直接赋值，类似php定义变量并赋值。语法3：select @变量名 := 表达式；#此语句会给该变量赋值，同时还会作为一个select语句输出“结果集”。语法4：select 表达式 into @变量名；#此语句虽然看起来是select语句，但其实并不输出“结果集”，而只是给变量赋值。 当然，也可以进行运算： 稍微总结一下：有两种环境；常规mysql命令环境，可以执行：增删改查。。。编程环境：其实就是在特定的语句语法内部：存储过程内，存储函数内，触发器内。两种变量：普通变量：不带＠符，直接写名字，必须先声明，后使用（赋值之类），只能用于编程环境会话变量：带＠符，无需声明，直接使用（先赋值），可以用于２种环境。流程控制语句： 只能用于编程环境存储函数定义形式： 调用形式：跟系统函数的调用形式一样，直接使用名字，并带括号，以及根据需要带实参。比如：select 3, now(), f1(); //f1为自定义的存储函数。select 3, now(), f2(3, ‘abc’, @v1); //带3个实参，其中@v1是一个前面赋值了的变量。 举例：先得改变语句结束符： 删除：drop function [if exists] 存储函数名； 存储过程存储过程就是一个没有返回值数据值的“函数”。虽然存储过程不返回单个数据值，但可以“返回”结果集——这里的返回起始就是select语句的正常结果表现。 定义形式： 其中，in，out，inout用于修饰一个形参的“数据流向”：in：只作为外部输入数据，调用环境传入存储过程内部，默认值。out：只作为输出数据，即存储过程传出到调用环境。inout：具有双重。存储过程调用形式：call 存储过程名（实参1，实参2，…..）； 举例： 注：实际，在php中，其实是这样：$sql = “call pro1(8, ‘dd’) ”；mysql_query( $sql ); 删除：drop procedure [if exists] 存储过程名；触发器什么叫触发器：就是mysql中的一种“一触即发”的机器（机制）。其实只是预先定义好的一段代码。该段代码无需人工调用，而是会在‘预计’好的某个情形下自动执行。通常就这几个情形：对某个数据表的增（或删或改）之前（或之后）。 //每个表可见只有6种情形。 触发器内部也跟存储过程或存储函数一样，属于“编程环境”。 定义形式：create trigger 触发器名字 before（或after） insert（或update或delete） on 表名 for each rowbegin要执行的代码，语句块，编程环境，但这里也不能使用select语句。end； 在触发器内部，其中有两个关键字具有特定含义和数据获取作用：new：代表新插入的一条数据，在insert事件的时候有效。old：代表旧的一条数据，在update或delete的时候有效。 3个编程总结：共同点：可以使用普通变量；可以使用流程控制结构；他们其实都是“一段代码”而已，存储在数据库中。存储函数：需要返回一个数据值；不能有select语句；调用时直接当作一个“数据”来使用，即可以用于select或别的各种数据操作语句中。存储过程：不能返回数据可以有select语句；形参可以设定为数据的进出方向：in， out， inout调用是使用call语句。触发器：不能返回数据；也不能有select语句；也没有参数，也不能调用，而是在触发的情况下自动调用（执行）。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/MYSQL学习笔记！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP跳转微网站授权自动登录PHP实现思路笔记！]]></title>
    <url>%2F2016%2F06%2F12%2FAPP%E8%B7%B3%E8%BD%AC%E5%BE%AE%E7%BD%91%E7%AB%99%E6%8E%88%E6%9D%83%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95PHP%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[####需求：直播APP要登录微商城，传 AES 加密的用户名和密码至服务端，服务端进行一系列验证，正确会返回微商城首页 URL，点进去实现免登陆。 ####踩坑：直接把登录信息放入 COOKIE 中，IOS根据返回的URL地址可以实现自动登录，但Android有问题，不能实现自动登录。 ####解决方法：把用户名和密码加密，放在 登录成功 返回的 URL 中，在微商城基类中做个判断，GET接收用户名和密码，解密进行一系列处理，然后把登录信息放入 COOKIE 或 SESSION 中，实现免登陆！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/APP跳转微网站授权自动登录PHP实现思路笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-流程控制语句-笔记！]]></title>
    <url>%2F2016%2F06%2F12%2Fmysql-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[###case when:1234567891011121314151617181920212223//mysql 中的 case when 用法select title, case disabled when &apos;0&apos; then &apos;隐藏&apos; when &apos;1&apos; then &apos;显示&apos; else &apos;未知&apos; end &apos;状态&apos; from db_article; //case when 两种写法等效（then后的select 语句要加上括号） select case pid when 1 then( select title from db_admin_node where id =1) when 2 then( select title from db_admin_node where id =2) when 3 then( select title from db_admin_node where id =3) else &apos; 其它&apos;end test,id,title,pid from db_admin_nodeselect case when pid=1 then( select title from db_admin_node where id =1) when pid=2 then( select title from db_admin_node where id =2) when pid=3 then( select title from db_admin_node where id =3) else &apos;其它&apos;end test,id,title,pid from db_admin_node 1234567select id,username,email,is_super,status ,case when username=&apos;admin&apos; then &apos;超级管理员&apos; when email=&apos;root@qq.com&apos; then &apos;系统管理员&apos; when is_super = 2 then &apos;测试管理员&apos; when status =&apos;0 &apos;then &apos;失效管理员&apos;else &apos;其它管理员&apos; end &apos;管理员类型&apos; from db_admin_user case null when 表达式 then 执行结果 end 字段别名 from 数据表#####如果这种情况，如果表达式为布尔false，则结果为null，如果表达式为布尔true，则执行结果1select case when 1&gt;0 then &apos;test&apos; end test from db_admin_user; IF(a,b,c)#####如果 a 是TRUE (不为 0 或 NULL)，则 IF()的返回值为b; 否则返回值则为 c, 类似php的 三目运算！123456//简单写法：select *,if(sex=1,&apos;男&apos;,&apos;女&apos;) sex from user;//多层嵌套写法：select *,if(sex=0,&apos;女&apos;,if(sex=1,&apos;男&apos;,&apos;保密&apos;)) sex from user; ###IFNULL(a,b) #####如果 a 不为 NULL（没有 0），则 IFNULL() 的返回值为 a; 否则其返回值为 b。 ifnull(a,b)这个函数一般用来替换null值!12 select *,ifnull(email,&apos;你还没设置邮箱&apos;) e_mail from user;//如果 email 字段为NULL，则用后面设置的值替换 ###NULLIF(a,b)1select nullif(arg1,arg2) ; //如果 arg1 = arg2 返回 NULL，否則 返回 arg1 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/mysql-流程控制语句-笔记！/]]></content>
      <categories>
        <category>MYSQL笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机访问电脑本地php项目！]]></title>
    <url>%2F2016%2F06%2F12%2F%E6%89%8B%E6%9C%BA%E8%AE%BF%E9%97%AE%E7%94%B5%E8%84%91%E6%9C%AC%E5%9C%B0php%E9%A1%B9%E7%9B%AE%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1.Windows+R 快捷键调出DOS， CMD命令输入： IPCONFIG 获取IPv4地址： 以192.168开头的每个IPv4地址可以绑定一个网站目录电脑端来访问。手机和电脑必须同一局域网!获取手机局域网ip地址（以iphone手机为例，打开设置，点击无线局域网，再点击手机连接的WIFI，就可以看到类似192.168.1.131开头的局域网ip地址！）选择和手机IP地址在同一波段的192.168.1开头的IPv4：192.168.1.133配置虚拟主机！ HOST配置： 最好关闭Windwos防火墙，然后浏览器输入192.168.1.133 ，cms.cm ， www.cms.cm ，不出意外的话，电脑端均可访问此项目。有可能手机端只能用IP地址：192.168.1.133 访问 ！ 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/06/12/手机访问电脑本地php项目！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你飞上天际，我沉入海底!]]></title>
    <url>%2F2016%2F05%2F20%2F%E4%BD%A0%E9%A3%9E%E4%B8%8A%E5%A4%A9%E9%99%85%EF%BC%8C%E6%88%91%E6%B2%89%E5%85%A5%E6%B5%B7%E5%BA%95%EF%BC%81~%2F</url>
    <content type="text"><![CDATA[不记得原因，她说她要买一辆新车，我说陪你去吧，她没有拒绝，于是我们上了桥——集中的自行车卖场在汉口。她问我：“走过长江大桥吗？” 我很惊讶：“没有，走过二桥，你不会……” 她说她想走着试试。我看了看眼前的的这坐庞然大物，我们至少要走2。5公里才能到江那边的第一个车站，在这之前，我们很可能已经跪倒在桥上某个奇形怪状的水泥镂空栏杆旁了，不过我那时已经深知她的脾性，所以毫不忧郁的答应了她，男子气魄大的惊人！ 果然，我们走完引桥，她就已经把身上能仍的都仍到了我身上，到了桥头堡，她说出了我千呼万唤的一句话：“我不行了！坐电梯，下桥，还是轮渡过江吧！” 我偷笑，并嘲笑她：“再走走吧！不远了！” 她知道我偷着乐呢，只瞥了我一眼：“哼！……” 哈哈……我很有成就感。 轮渡是我们两个都很喜欢的方式，我们上了轮渡，一般都会趴在栏杆上，江风轻捋发梢，有淡淡的潮湿的感觉，看着对岸林立的高楼，我们对未来指手画脚，偶尔她也与我谈些“沉重”的话题——感情上的话题。对她来说之所以沉重，是因为她不像一般女孩那么迷恋，她一味逃避；对我来说之所以沉重，是因为我爱上她了，而更多的迹象表明，她并不爱我。更多的时候，我们仅仅是在说笑，嬉闹，没有意义的对白经常发生，她轻描淡写的讲述她的生活，而我总是浓墨重彩的描述我的世界，这时候的我们，快乐的像江面上飘摇的江鸥，轻盈自由。 常常汽笛鸣响，我们却忘了下船，听到师傅的叫喊，才如梦初醒的扮着鬼脸，一蹦一跳的拾阶而下…… 出了渡口，繁华的大汉口立刻生动起来，车水马龙，磨肩擦踵，街对面硕大的江汉关钟楼向人们昭示这座城市沧桑而传奇的过去，每隔半小时，它沉重的钟鸣声，仿佛要穿透历史，指向飘渺的未来…… 她嘟哝着：“我们怎么去呢？三阳路啊？你知道在哪里吗？” 我摊开两手：“路盲啊大姐，别问我！” 我指了指那些等待载客的TAXI。 “不呀，旋子，我们坐那种‘黄包车’吧？”她两眼看着人力三轮车上皮肤黝黑的中年男子，很坚决的样子 我在纳闷，这年头怎么还会有这种落后的交通工具招摇过市？她虽然听起来是在问我，可是我知道根本没有选择，我们径直走过去， “师傅，三阳路几多钱？” “7块……” “啊？！那我们还不如坐红车子呢！”我最后努力着 她并没有说话，已经跳上车了，兴高采烈的拉我上去。 我们坐在这辆怀旧的小车上，在大汉口的小巷里迂回穿行，一排排欧式的古老建筑从身边滑过，真有点像电影里的桥段——30年代的大上海，富家小姐坐着黄包车悠闲的研磨时光，而她身旁的我，既不是风度翩翩的公子爷，也不是高大威猛的护花使者，大概是个静静凝望着她的花痴吧——白日梦在摇晃的树影中渐渐模糊，她一路上唧唧喳喳的不停，我很喜欢她的活力和灵性，她总有很多希奇古怪的问题，有的我知道答案，有的不知道，这都无关紧要，我只是这样随声的附和，就感到很幸福了。 买车的过程很痛苦，我们在街道两旁来回比较，尝试做一个决定，她是个糊涂虫，有自己的观点，却很贪心，最后她听了我的建议买了一辆阿米尼的跑车，很贵但很IN的，我们在车后轮两旁加装了两个彩色的铝棒，这样就可以让一个人站在后面飙车啦！ 回家的路，我们决定用刚买的车，一路上我骑车，她就站在后面，两手放在我的肩上，我们在沿江大道上飞驰，引来路人注目，风在耳边呼呼的响，我只听见她哇哇的叫，还有风拂过她的长发啧啧的声音——那时的她是长发飘飘的。有时她也带我，呼哧呼哧的卖力骑着，这时我会在后面帮她整理被风弄乱的头发，一绿一缕的挽到她的耳朵后面，看着这个如此接近的背影，仿佛一个洁白的天使，而我，张开双臂，也许就是她的翅膀了——天使不会爱上她的翅膀，她只会爱上另一个天使。 武汉关那个轮渡口越来越近了，大钟又敲响了，时间从不给你预兆，它从发丝的风中流逝，从短暂的笑声中逃逸，一粒一粒散落在身后，伸手去抓，好滑好滑，抓起来，又滚落了，跌在地上，碎成了回忆…… 我们推着新车上了轮渡。她很疲惫，我们找了两个缠绕锚绳的铁墩坐下，车子立在旁边，那是个没什么人的角落，依旧可以吹到飘浮在江面上的暧昧的清风，那个时间里，那里只有我们，两个人的世界，她的一只手轻轻地放在我腿上，另一之手托着头趴在栏杆上，懒洋洋地看着对岸的武昌，呢喃一些听不懂的呓语，那时我似乎也讲的很少，只觉的腿上的那只手的体温像在撩动我的心神……我对自己说，这是爱的感觉，我好想去握住她，握住那只手，可是开船的汽笛将我抛到现实，她像个孩子一般睡着了，她的确累了，我静静的看着她的侧影，是个优美的轮廓。眼神随着渡轮一起颠簸，她却一直平静的睡着，知道船靠岸，他都没有醒，我不忍心吵醒他，又怕错过了下船，被船师傅骂，就把嘴凑到她耳朵旁低声的叫了两句，她真是个天使，睁开眼睛的那一霎，也带走了我的世界！ 她不愿坐TAXI回家，执意要我带她回家，工具就是那辆新车，我到一直乐意，于是，两个疯子又在武昌的拥挤道路上把玩生命！穿过鼓楼洞那个涵洞的时候，我们被黑暗笼罩，她快乐地叫了一声，很兴奋的感觉 “啊！！” …… “再叫一声。” “什么?” “再叫一声啊” “恩。啊……哈哈哈” “哈哈哈哈” 这笑声一直深深地藏在我的记忆里……多年 多年前两人的画像一直是我心中 无价的收藏外面风雨再强 生活再乱再忙我总是翻箱倒柜 寻找你的微笑——吴宗宪《两人的画像》 ……当天使懂得海豚的伤悲 当海豚疼惜天使的心碎我们的相逢变得好可贵 我们在风中留下了喜悦的眼泪天使好想去学会了游泳 海豚在梦里飞到了半空中这样的恋爱或许不轻松 可是只有你让我深深心动天使好想给海豚一个吻 可是情海那么神秘那么深海豚想给天使一个拥抱 可是天使的家住得那么高……——梁咏琪《天使与海豚》 我依着窗，轻轻地吟唱，眼睛没有光彩，人轻的像羽毛。她就坐在我后面，旁边没有窗，是一堵墙，墙上是各种斑驳的字迹，记录了高三那段充满靡废气息的狗年月…… 她轻轻的说：“旋子，天使与海豚，再唱两遍吧？” 我没有回答——我是天使，一个孤单浪漫的天使……歌声响起的时候，我听见她的呼吸，均匀而清晰，闻着她的发香，沿着一条曲折的轨迹飘进鼻翼，掠夺我的灵魂，可是我不敢将头转过去，因为我知道，她此刻一定靠着墙，眼神不时地瞟向教室的另一个角落，那里是一个男生。她丝毫不掩饰自己的魂不守舍，而我，依旧看着窗外，花开的正旺，姹紫嫣红，一朵一朵簇拥在一起，像一颗心在渗血，娇艳欲滴。 自从被班主任无理粗暴的数落我们走的太近以后，她开始变的冷漠，我失去了每天晚上送她回家的机会，现在，座位也被换开了，我被强行拖离了她的世界，偶尔我也会绕过大半个教室去看看她，聊两句虚无缥缈的话，话题无外乎学习或者新闻，她努力不让我看出她的变化，我努力不让她觉得尴尬，对白总是在空气凝固的时候嘎然而止，没有继续的必要，我们默契的让希望胎死腹中。我更喜欢的方式是找各种借口到离她较近的地方，静静的观察。直到我发现她的眼神早就被另一个人牵引，无论上课，下课，教室里还是教室外，每一次在那里停留的关注都像剑一样刺进心脏，绞痛的感觉迅速蔓延开来，虽然只是一刹那，却好像失去了好多。 她身边从不缺少关心她的人，一个，两个，三个……我只是其中一个草草收场的受伤者，当我逃到她看不见的荒野的时候，他们依旧在她身边，继续暧昧而尴尬的你追我赶，那时的我真替她担心，她还是个涉世未深的少女，如何能够承受那么多的纠葛和矛盾。时间让她习惯了处在炮火中心，习惯了避重就轻，习惯了转移话题，习惯了逃避。偶尔一闪而过的忧郁，也是稍瞬即逝，被她深深地埋在心底，可是那么多人不甘心，她不能从容的选择，也不能从容的全身而退，终于暴风雨来临了。 他们争吵，她哭泣，他们继续争吵，她就逃离。我好心急，我站的很远，远离硝烟，我以为，只要我不再去添乱，她就少一份麻烦，可是这样她也少了一份支持，我不知道当初的冷漠有没有做对。可是那天她不见了，我心急如燎，我实在忍不住了，起着车子，在这个迷乱城市的每一个可能角落寻找她的身影，车灯在前面慌乱的摇晃，我左顾右盼，这里，那里，都没有，我知道这样没有结果的寻找也只能安慰我自己而已。我像在寻找那个迷失的自我，寻找一个坚持的理由，寻找这样不明不白的爱的原因。 最后，她终于回教室了，我看着她，她看见我，只有那么0. 01秒，之后，我继续冷漠，她继续挣扎在漩涡中，我实在不能忍受这种窒息的彼此隔离，我一口气冲到操场上，跑了不知道多久，汗水一滴一滴从脸上跌到塑胶跑道上，没有声音，马上就消失的无影无踪了，精疲力竭的时候，我躺在草坪上，天上群星闪烁，两行泪水不安分的沿着曲折的轨迹蹒跚的摩梭到耳根，我又想起她的发香，一路撩动脸上的神经，酥麻而暗自痛苦！ 后来她说，我回教室的时候，眼神像是要杀人，的确，要是杀了他们可以减轻她的痛苦，当时我也许真的下得了手。 后记：明天早上8点，她就要走了，不知道彼岸的花美不美，她还会不会那么天真，我是想消失了，她说我消失，她也会躲起来，可是她不知道她不见了，多少人会心痛啊！而我本来就是一个小角色，虽然依然在跋涉，却早已没有了方向。这个世界好复杂，和人相处好复杂。我们熟能生巧，我们眉开眼笑。当笑容不再代表快乐，甚至与悲伤放弃成正比。我们能说什么做什么呢？ 什么都无所谓了…… 那些情歌唱得好动听。 我好想她一剑刺穿我的胸膛，那样就不会疼。她怎么忍心把我交给岁月，将我一层一层的蜕去外皮，学会忘记。为什么美好的动心的感人的话语场景也要忘记？我要怎么背得起？ 我还会和别的人欢欣缠绵共渡云雨。我不想这样。我告诉过她我不想。可是她忘记了。最后我还是要和别的人一起。他忘记了……我也快忘了…… 我与你已经相隔天与地的距离。你飞上天际，我沉入海底。我闭上眼睛。忘记一切。默默许愿，但愿我们永生永世不再关联，愿过去的自己已经死去~~~~ 听见 冬天的离开 我在某年某月 醒过来我想 我等 我期待 未来却不能理智安排阴天 傍晚 车窗外 未来有一个人在等待向左 向右 向前看 爱要拐几个弯才来我遇见谁 会有怎样的对白我等的人 他在多远的未来我听见风来自地铁和人海我排着队 拿着爱的号码牌我往前飞 飞过一片时间海我们也常在爱情里受伤害我看着路 梦的入口有点窄我遇见你是最美的意外终有一天 我的谜底会揭开《遇见》――孙燕姿 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/20/你飞上天际，我沉入海底！~/]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的一个小的ajax功能！]]></title>
    <url>%2F2016%2F05%2F17%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9A%84AJAX%E5%8A%9F%E8%83%BD%EF%BC%81%2F</url>
    <content type="text"><![CDATA[js12345678910111213141516171819202122232425262728function getarea()&#123; var project_id = $(&quot;#project_id&quot;).val();//获得下拉框中大区域的值// alert(project_id);return; if(project_id != &apos;&apos;)&#123; $.ajax(&#123; type: &quot;post&quot;, url: &quot;getdata.php&quot;, data:&quot;project_id=&quot;+project_id, cache:false, beforeSend: function(XMLHttpRequest)&#123; &#125;, success: function(data, textStatus)&#123; // alert(data); $(&quot;#building_id&quot;).empty();//清空area下拉框 $(&quot;#building_id&quot;).append(data);//给area下拉框添加option &#125;, complete: function(XMLHttpRequest, textStatus)&#123; &#125;, error: function()&#123; //请求出错处理 &#125; &#125;); &#125;&#125; html12345678910111213141516&lt;div&gt;&lt;table class=&apos;itable&apos; width=&apos;100%&apos; id=&apos;timetable&apos;&gt;&lt;tr&gt;&lt;td class=&quot;test_c&quot; id=&quot;one&quot;&gt;所属项目 &lt;select id=&quot;project_id&quot;name=&quot;project_id&quot; onchange=&quot;getarea();&quot;&gt;&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;&lt;?php$query=&quot;SELECT p.* FROM re_project p ORDER BY p.project_id &quot;;$result=exequery($connection,$query);while ($rs=mysql_fetch_assoc($result))&#123;echo &quot;&lt;option value=&#123;$rs[&apos;project_id&apos;]&#125;&gt;&#123;$rs[&apos;project_name&apos;]&#125;&lt;/option&gt;&quot;;&#125;?&gt;&lt;/select&gt;&lt;/td&gt;&lt;td&gt;所属楼栋 &lt;select id=&quot;building_id&quot; name=&quot;building_id&quot;&gt;&lt;/select&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt; **《php部分》123456789101112$project_id = $_POST[&apos;project_id&apos;];//根据前台传过来的region_id来处理下拉框的内容.//这里演示直接输出,你可以从数据库中读出来组织后再输出.$query = &quot;select d.* from re_building d where d.project_id =&apos;&#123;$project_id&#125;&apos; order by d.id&quot;;$cursor = exequery( $connection, $query ); while ( $result = mysql_fetch_array( $cursor ) ) &#123; if ( $project_id == $result[&apos;project_id&apos;] ) &#123; $select = &quot; selected &quot;; &#125; echo $area_option = &quot;&lt;option value=&apos;&quot;.$result[&apos;id&apos;].$select.&quot;&apos;&gt;&quot;.$result[&apos;name&apos;].&quot;&lt;/option&gt;&lt;br&gt;&quot;;&#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/17/常用的一个小的AJAX功能！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础函数！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330LINUX常用命令:1.pwd(Print Working Directory) 描述:打印当前目录 语法: pwd2.cd (Change Directory) 描述:改变当前目录 语法: cd 选项cd .. :返回上一级目录(父目录) cd . :返回当前目录cd ~ :返回当前用户的主目录 cd / :返回根目录3.路径 相对路径:从当前目录开始的路径。 绝对路径:从根目录开始的路径。4.ls(list)命令 描述:显示目录的所有文件及子目录 语法: ls [参数] [目录]-l(long):显示文档/目录的详细信息(权限、用户、用户组、尺寸等)-a(all) : 显示所有文档及子目录 -R[Recursive] 递归显示5.mkdir(Make Directory) 描述:创建目录 语法:mkdir [参数] 路径 -p 同时创建父子目录6.rmdir(Remove Directory) 描述:删除目录 语法:rmdir [参数] 路径-p 同时删除父子目录,但要求所有的目录内不能存在文件。说明:只能删除空目录(不存在文件和子目录)。使用命令进行删除时,不经过回收站。7.mv(Move) 描述:移动文件/目录 语法:mv 源文件/目录 目标文件/目录如果目标目录不存在,则将源目录移动到指定位置后,名称为指定的新名称。如果目标目录已经存在并且没有指定新名称时,则移动后名称为原来的名称。8.unlink 描述:删除文件 语法:unlink 路径9.touch 描述:设置文件的创建访问及修改时间,如果文件不存在,则创建。 语法: touch 路径10.rm(Remove) 描述:删除文件/目录 语法:rm [参数] 路径-f [force] 不询问是否删除 -r [recursive] 递归11.cp(Copy) 描述:复制文件/目录 语法:cp [参数] 源路径 目标路径 -r [recursive] 递归权限问题:r[read] 4 ; w[write] 2; x[execute] 1;0: --- 1: --x 2: -w- 3: -wx 4: r-- 5: r-x 6: rw- 7: rwx (user group others)chmod 描述:权限 语法:chmod 权限 [-R] 路径vi(Visual) vi [+行号] [文件的路径及名称]i I ==&gt; 进入编辑状态Esc ==&gt; 命令状态:w [文件的路径及名称](Write) --&gt; 保存,但仍然可编辑:q! (Quit) --&gt; 不保存,并且退出:wq[文件的路径及名称] --&gt; 保存并退出HTML:标签:&lt;b&gt;...&lt;/b&gt; 加粗 &lt;strong&gt;...&lt;/strong&gt; 加粗&lt;i&gt;...&lt;/i&gt; 倾斜 &lt;em&gt;...&lt;/em&gt; 倾斜&lt;u&gt;...&lt;/u&gt; 下划线 &lt;s&gt;...&lt;/s&gt; 删除线&lt;strike&gt;...&lt;/strike&gt; 删除线 &lt;sup&gt;...&lt;/sup&gt; 上标&lt;sub&gt;...&lt;/sub&gt; 下标 &lt;span&gt;...&lt;/span&gt; 内联对象表格属性:width:宽度 height:高度border:边框宽度 bordercolor:边框颜色bgcolor:背景颜色 background:背景图像align:水平对齐方式(left|center|right) cellpadding:单元格边距(单元格内容与框线之间的距离)cellspacing:单元格间距(相邻单元格之间的距离)单元格属性:width:宽度 height:高度bgcolor:背景颜色 background:背景图像align:水平对齐方式(left|center|right,默认为left)valign:垂直对齐方式(top|middle|bottom,默认为middle)rowspan:行合并数目 colspan:列合并数目行属性:height:高度 bgcolor:背景颜色align:水平对齐方式(left|center|right,默认为left)body标记的属性:leftmargin:左边距 topmargin:上边距rightmargin:右边距 bottommargin:下边距 bgcolor:背景颜色HTML实体:大于号: &gt; 小于号: &lt; 单引号: &apos;按位与: &amp; 双引号: &quot; 不间断空格: 版权符号: © 注册商品: ® 英镑: £欧元: € 日元: ¥乘号: × 除号: ÷有序列表、无序列表及定义列表:有序列表 &lt;ol type=&quot;1|a|A|i|I&quot; start=&quot;起始编号&quot;&gt;&lt;li&gt;...&lt;/li&gt;...&lt;/ol&gt;无序列表 &lt;ul type=&quot;disc|square|circle&quot;&gt;&lt;li&gt;...&lt;/li&gt;...&lt;/ul&gt;定义列表 &lt;dl&gt; &lt;dt&gt;...&lt;/dt&gt; &lt;dd&gt;...&lt;/dd&gt; ...&lt;/dl&gt;缩进: &lt;blockquote&gt;...&lt;/blockquote&gt;保持原样 &lt;pre&gt;....&lt;/pre&gt;CSS样式:clear描述:清除浮动 语法:clear:left|right|both; 作用:清除浮动为了良好的文档结构及良好的代码阅读性,一定我们定义如下的CSS类:/* == clearfix == */.clearfix:after &#123; /*/*/ content: &quot;.&quot;; /* IE8 hack */ display: block; height: 0; clear: both; visibility: hidden; &#125;/* IE7 hack */.clearfix &#123; display: inline-block; &#125;/* IE-mac, IE5, IE6 */* html .clearfix &#123; height: 1%; &#125;.clearfix &#123; display: block; &#125;当我们定义完毕该类后,只需要在浮动对象的父对象上添加class=&quot;clearfix&quot;属性即可。重要提示:如果子标记存在float属性,并且还存在margin属性,那么将在IE6中产生双倍间距！！！清理IE6双倍间距display:inline;边框属性:border-top-width 描述:设置上边框的线宽 语法:border-top-width:value;border-top-style 描述:设置上边框的线型 语法:border-top-style:none|solid|dotted|dashed;border-top-color 描述:设置上边框的颜色 语法:border-top-color:value;border-top 描述:设置上边框的样式 语法:border-top:线宽 线型 颜色;Border 描述:设置边框的样式 语法:border:线宽 线型 颜色;列表样式:list-style-type 描述:设置列表样式 语法:list-style-type:none|circle|disc|square|lower-alphalist-style-image 描述:设置列表图像 语法:list-style-image:url(背景URL);list-style-position 描述:设置列表符号的位置 语法:list-style-position:inside|outside;list-style 描述:设置列表属性 语法:list-style:type url(图像URL) position;定位属性:Position 描述:设置对象的定位方式 语法:position:static(静态)|relative(相对)|absolute(绝对);Left 描述:设置与父对象左侧的间距 语法:left:value;Top 描述:设置与父对象上侧的间距 语法:top:value;Right 描述:设置与父对象右侧的间距 语法:right:value;Bottom 描述:设置与父对象下侧的间距 语法:bottom:value;z-index 描述:设置对象的叠放顺序 语法:z-index:value;重要说明:relative为相对定位,此时使用top、left、right、bottom等属性时是相对于父对象而言。但是该对象没有脱离文档流。absolute为绝对定位,此时使用top、left、right、bottom等属性时是相对于浏览器的坐标原点而言。但是该对象已经脱离文档流。(父)relative+(子)absolute,此时:(1)、子对象的定位为绝对定位。对象已经脱离文档流。(2)、子对象是相对于父对象的坐标原点而言的。半透明颜色:IE:filter:alpha(opacity=value); 取值范围为0~100Firefox等:opacity:value; (取值为0~1)Cursor:描述:设置鼠标指针类型语法:cursor:pointer(手形)|wait(沙漏)|text(I形)|crosshair(十字光标)|help(帮助);解决IE6不支持PNG透明:(1)、PNG透明图像作为背景使用filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=是否启用效果,src=背景图像URL,sizingmethod=图像的显示方式)enabled值只能为true/false。src为PNG透明图像的URL。sizingmethod为图像显示方式(image|scale|crop)image:放大/缩小盒子的尺寸,以显示一个完整的图像。scale:放大/缩小图像,以显示充满盒子。crop:裁切,只显示盒子尺寸部分的图像(2)、PNG透明图像作为图像使用 直接在文档的头部,书写 &lt;script type=&quot;text/javascript&quot; src=&quot;JS文档URL&quot;&gt;&lt;/script&gt;(3)、无论为PNG的图像/背景图像添加链接,那么IE6中,产生 (1)、鼠标形状在文本的空白区域没有呈现手形 (2)、文本的空白区域内不能使用链接 解决方案: 为链接添加以下样式: cursor:pointer; position:relative; PHP函数: 1数字函数：floor float floor(float $value) float float 舍一取整ceil float ceil(float $value) float float 进一取整min mixed min(int $value....) int intmax mixed max(int $value....) int intround float round(float $value) float floatpow pow(5.2); 幂运算sqrt sqrt(23); 求平方根2.日期函数：time int time(void) int voiddate string date(string $format) string stringdate string date(string $format,int $value) string string intdate_default_timezone_set() bool date_default_timezone_set(string$value) bool stringdate_default_timezone_get() string date_default_timezone_get(void) string voidstrtotime string strtotime(string $value) string string 3.字符串函数：strlen int strlen(string $string) int stringstpos int strpos(string $sting,mixed $needle) int string stringsubstr string substr(string $string,int $start,int $length) string string intstr_replace string str_replace(被替换的内容,替换的内容,原字符串) stringunset() void unset(string $string) void string ucwords:把每个单词的首字母改成大写的ucfirst:把首字母改成大写的 uclower:把字母改成小写的ucupper:把字母改成大写的 trim:把字符两侧的空格去掉md5:加密文件 strrev:把字符反转4.数组函数：count int count(array $array) int arrayexplode array explode(char $val,string $val) array char stringjoin string join(char $val,array $array) string char arrayarray_values array array_values(array $array) array arrayarray_keys array array_keys(array $array) array arrayarray_shift() string array_shift(array $array) string arrayarray_pop string array_pop(array $array) string arraycurrent string current(array &amp;$array) string arraynext string next(array &amp;$array) string arrayprev string prev(array &amp;$array) string arrayreset string reset(array &amp;$array) string arrayend string end(array &amp;$array) string arrayin_array boolen in_array(string $val,array $array) boolen array stringsort array sort(array $array) array arrayarray_reverse array array_reverse(array $array) array array 数组倒置5.函数函数库：func_get_arg(); mixed func_get_arg(int $val) mixed intfunc_get_args(); array func_get_args(void) array voidfunction_exists(); boolen function_exists(函数名字) boolen func_get_arg(); 返回对应位置参数的值 func_get_args(); 以数组的形式获得参数的值func_num_args(); 返回参数的个数 function_exists();判断函数是否存在6.文件函数：fopen(); resource fopen(string $filename,string $mode) resource stringfwrite; int fwrite(string $openfile,string 要写入的内容) int stringfread(); srtring fread(string $openfile) string stringfclose(); boolen fclose($openfile) boolen string filesize(); int filesize($filename) int stringfile_get_contents(); fopen+fread string stringfile_put_contents(); fopen+fwrite+fclose int stringunlink boolen unlink($filename) boolen stringis_file: 判断文件是否存在 boolen string serialize string serialize(mixed val) string mixedunserialize mixed unserialize(string ) mixed stringinclude/include_once: 如果找不到包含文件,后面的文件继续执行require/require_once: 如果找不到包含文件,后面的文件不执行了get_include_path; set_include_path;__FLIE__:获得当前文件的路径;dirname(__FILE__):获得当前文件的路径 ,但不包含文件名basename(__FILE__):获得当前文件的名称URL函数：string urlencode(url) url编码 string urlencode(str) url编码Mysql中聚合函数:函数名称 作用 格式sum(); 求和 select sum(price) from books;avg(); 求平均数 select avg(money) from smon;min(); 最小值 select min(price) from books;max(); 最大值 select max(price) from books;count(); 统计记录数 select count(*) as ct from books;round(); 四舍五入(列的整数部分) select round(money) from smon;2 字符串函数:substr(string,start,len); 字段截取mysql 中的起始位置 从 1开始的。 select substr(bName,1,5) from books where bId=1;concat(str1,str2,str3....) 提取字段然后连接成字符串 select concat(bName,author,publishing) as bna from books;upper(); 大写 select upper(字段) from 表名lower(); 小写 select lower(字段) from 表名 curdate();取得当前日期 curtime(); 取得当前时间 php 操作mysql函数库:mysql_connect(&quot;localhost&quot;,&quot;userName&quot;,&quot;userPwd&quot;); php 用来连接数据库。mysql_error(); 返回上一个 mysql操作的错误信息。 mysql_select_db(dbname,$link); 选择数据库 mysql_query(string sql); 向mysql 数据库发送一条 sql语句。执行sql语句mysql_affected_rows(); 返回前一次 mysql 执行 增 删 改 操作所影响的行数。mysql_num_rows(resource result); 返回结果集当中的记录数。把数据从结果集当中取出来。取出的记录以索引或关联数组的形式存在。mysql_fetch_array(resource result[,string mode]); 从结果集当中 取出数组,组成一个索引+关联的混合数组。mysql_fetch_assoc(); 取得结果集当中的关联数组, 会使指向结果集的指针下移一位mysql_free_result(); 释放的结果集占用的内存资源mysql_close(); 关闭连接; mysql_insert_id(); 返回最后插入数据库的记录的idmysql_num_fields(resource $result); 返回结果集当中包含的字段数;mysql_field_name(resource $result,int num); 返回字段的名称(); num字段的编号,是从0开始。mysql_field_type(resource $result,int num); 返回字段的数据类型:mysql_field_len(resource $result,int num); 返回字段长度。url函数:string urlencode（url） url编码string urldecode(str) url解码php图像函数库:int $x , int $y , 点的坐标。int $color 颜色。int $x1 , int $y1 , 起点的坐标。int $x2 , int $y2 , 终点的坐标。int $font , 字号。 string $c ,图像上写的字。Imagecreate 创建基于调色板的图像。 resource imagecreate ( int $x_size , int $y_size );Imagecreatetruecolor 新建一个真彩色图像。 resource imagecreatetruecolor ( int $x_size , int $y_size );imagegif | imagejpeg | imagepng 将图像以 gif|jpeg|png的格式输入到页面（文件）; imagedestroy 销毁图像在内存中的垃圾。 描述:销毁图像在内存中的垃圾。imagechar() 水平绘制一个字符。 bool imagechar ( resource $image , int $font , int $x , int $y , string $c , int $color )imagestring(); 水平绘制字符串; bool imagestring ( resource $image , int $font , int $x , int $y , string $s , int $col )imagecolorallocate(); 为一幅图像分配颜色 int imagecolorallocate ( resource $image , int $red , int $green , int $blue )imagerectangle(); 画一个矩形 线框 bool imagerectangle ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $col )imagefilledrectangle(); 绘制填充矩形。 bool imagefilledrectangle ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color )imagesetpixel(); 绘制像素点（一个） bool imagesetpixel ( resource $image , int $x , int $y , int $color )imageline(); 绘制线段 bool imageline ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color ) 聚合函数:select count(*) from 表名; 记录数select sum(字段) from 表名; 字段求和select avg(字段) from 表名; 字段求平均数select max(字段) from 表名; 字段求最大值select min(字段) from 表名; 字段求最小值JavaScript函数:数字函数:Math.ceil;进一取整; Math.round;四舍五入;Math.floor;舍一取整; Math.max;取最大数;Math.min;取最小数; Math.random;随即数;Math.abs;绝对值;日期函数:var d=new date();日期; var year=d.getYear(); var month=d.getMonth();var day=d.getDate();日 var week=d.getDay();星期几 var hour=d.getHours();var minute=d.getMinute(); var second=d.getSeconds();字符串函数:charAt();返回指定位置对应的字符; indexOf();返回指定字符对应的位置;lastIndexOf();从最后开始寻找,返回指定字符对应的位置;replace();替换; split();分割字符串,返回数组;substr(&quot;起始值&quot;,&quot;长度&quot;);截取字符串; substring(&quot;起始值&quot;,&quot;最后位置&quot;);截取字符串;toLowerCase();转小写; toUpperCase();转大写;JavaScript方法:alert(); confirm();setTimeout(&quot;函数()&quot;,&quot;时间&quot;); open(&quot;页面地址&quot;,&quot;pop&quot;,&quot;width=值,height=值,top=值,left=值&quot;);close();关闭当前页面; document.write(&quot;内容&quot;); document.getElementById();获取对象;Jquery相关知识:$(&quot;对象&quot;).attr(&quot;属性名&quot;,&quot;值&quot;);操纵属性Jquery对象.attr(&quot;属性名&quot;);获取属性值; Jquery对象.removeAttr(&quot;属性名&quot;);移除属性操作表单元素Jquery对象.val(&quot;值&quot;):设置值; Jquery对象.val();获得值;Jquery对象.html(); Jquery对象.html(&quot;值&quot;);Jquery对象.text(); Jquery对象.text(&quot;值&quot;);Jquery对象.addClass(&quot;类名&quot;); Jquery对象.removeClass(&quot;类名&quot;);Jquery对象.toggleClass(&quot;类名&quot;); Jquery对象.css(&quot;样式名&quot;,&quot;值&quot;);Jquery对象.css(&quot;样式名&quot;);Jquery对象.css(&#123;&quot;样式名&quot;:&quot;值&quot;,&quot;样式名&quot;:&quot;值&quot;。。。&#125;); 用到了json对象;Jquery对象.width(&quot;值&quot;); Jquery对象.height(&quot;值&quot;);绝对定位获得标签的左边距和上边距:Jquery对象.css(&quot;left&quot;); Jquery对象.css(&quot;top&quot;);相对定位获得标签的左边距和上边距:Jquery对象.offset().left; Jquery对象..offset().top;给某个标签邦定事件:Jquery对象.bind(&quot;事件&quot;,&quot;函数明&quot;); 事件on要去掉,函数名不能加括号;Jquery对象.bind(&quot;事件&quot;.function()&#123;执行代码&#125;);获取鼠标的坐标:Jquery对象.bind(&quot;mousemove&quot;,function(e)&#123; var x=e.pageX; var y=e.pageY;&#125;)Jquery对象.hide(［时间］,［函数］); Jquery对象.show(［时间］,［函数］);Jquery对象.toggle(［时间］,［函数］);滑动:Jquery对象.slideDown(［时间］,［函数］); Jquery对象.slideUp(［时间］,［函数］);Jquery对象.slideToggle(［时间］,［函数］);淡入淡出:Jquery对象.fadeIn(［时间］,［函数］); Jquery对象.fadeOut(［时间］,［函数］);Jquery对象.fadeTo(［时间］,［函数］);ajax$.ajax(&#123;type:&quot;post&quot;,url:&quot;处理页面&quot;,data:&quot;参数&quot;,dataType:&quot;html/json/xml&quot;,success:function(msg)&#123;执行代码&#125;&#125;); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP基础函数！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP下隐藏index-php以及URL伪静态！]]></title>
    <url>%2F2016%2F05%2F16%2FThinkPHP%E4%B8%8B%E9%9A%90%E8%97%8Findex-php%E4%BB%A5%E5%8F%8AURL%E4%BC%AA%E9%9D%99%E6%80%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[设置url的重写模式(默认模式是1)123&apos;URL_MODEL&apos; =&gt; 2, // URL访问模式,可选参数0、1、2、3,//代表以下四种模式： 0 (普通模式); 1 (PATHINFO 模式); 2 (REWRITE 模式); 3 (兼容模式) // 默认为PATHINFO 模式，提供最好的用户体验和SEO支持 使用Apache来进行设置1.打开配置文件httpd.conf #LoadModule rewrite_module modules/mod_rewrite.so 去掉前面的#2.在根目录index.php同级下新建一个.htaccess文件 ############################################# 123456789101112131415&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks RewriteEngine On RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt;因为在Fastcgi模式下，php不支持rewrite的目标网址的PATH_INFO的解析 ThinkPHP运行在URL_MODEL=2时，会出现 No input file specified.的情况， 这时可以修改网站目录的.htaccess文件： RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] 改为 RewriteRule ^(.*)$ index.php?s=$1 [QSA,PT,L] .htaccess的内容为：RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php?s=$1 [QSA,PT,L] #############################################123456&lt;IfModule mod_rewrite.c&gt;RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php?s=$1 [QSA,PT,L]&lt;/IfModule&gt; ###############################################url伪静态的实现 在你配置文件中修改即可‘URL_HTML_SUFFIX’ =&gt; ‘html|shtml’, // URL伪静态后缀设置 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/ThinkPHP下隐藏index-php以及URL伪静态！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP整合PHPMailer发送邮件笔记！]]></title>
    <url>%2F2016%2F05%2F16%2FThinkPHP%E6%95%B4%E5%90%88PHPMailer%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[下载PHPMailer：https://sourceforge.net/projects/phpmailer/GitHub下载:https://github.com/PHPMailer/PHPMailer config.php 加入配置：1234567891011// 配置邮件发送服务器&apos;MAIL_HOST&apos; =&gt;&apos;smtp.163.com&apos;,//smtp服务器的名称&apos;MAIL_SMTPAUTH&apos; =&gt;TRUE, //启用smtp认证&apos;MAIL_USERNAME&apos; =&gt;&apos;L1623283744@163.com&apos;,//你的邮箱名&apos;MAIL_FROM&apos; =&gt;&apos;L1623283744@163.com&apos;,//发件人地址&apos;MAIL_FROMNAME&apos;=&gt;&apos;DragonersLi&apos;,//发件人姓名&apos;MAIL_PASSWORD&apos; =&gt;&apos;LSLONG052344&apos;,//邮箱密码&apos;MAIL_CHARSET&apos; =&gt;&apos;utf-8&apos;,//设置邮件编码&apos;MAIL_ISHTML&apos; =&gt;TRUE, // 是否HTML格式邮件 function.php加方法如下：1234567891011121314151617181920212223242526272829/** * 邮件发送函数 * @param string $to 发送给哪个邮箱 * @param string $title 发送主题 * @param string $content 发送内容 * */function sendEmail($to, $title, $content) &#123; Vendor(&apos;PHPMailer.PHPMailerAutoload&apos;); $mail = new PHPMailer(); //实例化 $mail-&gt;IsSMTP(); // 设定使用SMTP服务 // $mail-&gt;SMTPSecure = &apos;ssl&apos;;// SMTP 安全协议 $mail-&gt;Host=C(&apos;MAIL_HOST&apos;); //smtp服务器的名称（这里以QQ邮箱为例） $mail-&gt;SMTPAuth = C(&apos;MAIL_SMTPAUTH&apos;); //启用smtp认证 $mail-&gt;Username = C(&apos;MAIL_USERNAME&apos;); //你的邮箱名 $mail-&gt;Password = C(&apos;MAIL_PASSWORD&apos;) ; //邮箱密码 $mail-&gt;From = C(&apos;MAIL_FROM&apos;); //发件人地址（也就是你的邮箱地址） $mail-&gt;FromName = C(&apos;MAIL_FROMNAME&apos;); //发件人姓名 $mail-&gt;AddAddress($to,&quot;尊敬的客户&quot;); $mail-&gt;WordWrap = 50; //设置每行字符长度 $mail-&gt;IsHTML(C(&apos;MAIL_ISHTML&apos;)); // 是否HTML格式邮件 $mail-&gt;CharSet=C(&apos;MAIL_CHARSET&apos;); //设置邮件编码 $mail-&gt;Subject =$title; //邮件主题 $mail-&gt;Body = $content; //邮件内容 $mail-&gt;AltBody = &quot;这是一个纯文本的身体在非营利的HTML电子邮件客户端&quot;; //邮件正文不支持HTML的备用显示 return $mail-&gt;Send() ? true : $mail-&gt;ErrorInfo;&#125; 调用代码如下：1var_dump(sendEmail($to=&apos;865196792@qq.com&apos;, $title=&apos;这是一封测试邮件！&apos;, $content=&apos;天下武功唯快不破！如来神掌，专克蛤蟆功！&apos;)); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/ThinkPHP整合PHPMailer发送邮件笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
        <tag>PHPMailer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP单例模式和工厂模式小记！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[12//空对象new stdClass() == object(null); 12345678910111213141516171819202122//在php语言中，一个对象还可以使用clone运算符进行克隆，则就也会“生成”新对象。//因此，还需要在类中使用私有化措施来禁止克隆，最终，单例模式的实现如下：//单例模式4个关键点class S&#123; public $v = 10; private static $state;//存储实例化的类 private function __Construct()&#123;&#125;//私有化构造方法 public static function getNew()&#123; if(!isset(self::$state))&#123;//如果没有实例化则实例化，实例化则直接返回 self::$state = new self; &#125; return self::$state; &#125; private function __clone()&#123;&#125;//禁止克隆&#125; $s = S::getNew(); $m = S::getNew();var_dump($s);var_dump($m);die; 1234567891011121314151617181920//项目中的工厂类class F&#123;//生成模型的单列对象public static function M($name)&#123;static $list = array();//存储已实例化的模型对象列表 if(!isset($list[$name]))&#123;//判断当前模型是否已实例化 require_once&apos;./&apos;.$name.&apos;.class.php&apos;; $list[$name] = new $name;//可变类 &#125; return $list[$name]; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//类名，也习惯上（推荐）使用跟文件名相似的名字//定义一个mysql连接类，该类可以连接mysql数据库//并实现其单例模式//该类的功能还能够完成如下基本mysql操作：//执行普通的增删改非返回结果集的语句//执行select语句并可以返回3种类型的数据：//多行结果（二维数组），单行结果（一维数组）//单行单列（单个数据）class MySQLDB&#123; public $host; public $port; public $username; public $password; public $charset; public $dbname; //连接结果（资源） private static $link; private $resourc; public static function getInstance($config)&#123; if(!isset(self::$link))&#123; self::$link = new self($config); &#125; return self::$link; &#125; //构造函数：禁止new private function __construct($config)&#123; //初始化数据 $this-&gt;host = isset($config[&apos;host&apos;]) ? $config[&apos;host&apos;] : &apos;localhost&apos;; $this-&gt;port = isset($config[&apos;port&apos;]) ? $config[&apos;port&apos;] : &apos;3306&apos;; $this-&gt;username = isset($config[&apos;username&apos;]) ? $config[&apos;username&apos;] : &apos;root&apos;; $this-&gt;password = isset($config[&apos;password&apos;]) ? $config[&apos;password&apos;] : &apos;&apos;; $this-&gt;charset = isset($config[&apos;charset&apos;]) ? $config[&apos;charset&apos;] : &apos;utf8&apos;; $this-&gt;dbname = isset($config[&apos;dbname&apos;]) ? $config[&apos;dbname&apos;] : &apos;&apos;; //连接数据库 $this-&gt;connect(); //设定连接编码 $this-&gt;setCharset($this-&gt;charset); //选定数据库 $this-&gt;selectDb($this-&gt;dbname); &#125; //禁止克隆 private function __clone()&#123;&#125; //这里进行连接 private function connect()&#123; $this-&gt;resourc = mysql_connect(&quot;$this-&gt;host:$this-&gt;port&quot;, &quot;$this-&gt;username&quot;,&quot;$this-&gt;password&quot;) or die(&quot;连接数据库失败！&quot;); &#125; public function setCharset($charset)&#123; //mysql_set_charset($charset, $this-&gt;resourc); $this-&gt;query(&quot;set names $charset&quot;); &#125; public function selectDb($dbname)&#123; //mysql_select_db($dbname, $this-&gt;resourc); $this-&gt;query(&quot;use $dbname;&quot;) ; &#125; //进行序列化的时候会调用 public function __sleep()&#123; echo &quot;序列化。。。&quot;; mysql_close($this-&gt;resourc);//关闭连接资源（清理资源） //如果定义了该__sleep方法，则此时必须返回数组，才能进行序列化 return array(&apos;host&apos;,&apos;port&apos;,&apos;username&apos;,&apos;password&apos;,&apos;charset&apos;,&apos;dbname&apos;); &#125; //进行反序列化的时候会调用 public function __wakeup()&#123; //连接数据库 $this-&gt;connect(); //设定连接编码 $this-&gt;setCharset($this-&gt;charset); //选定数据库 $this-&gt;selectDb($this-&gt;dbname); &#125; /** * 功能：执行最基本（任何）sql语句 * 返回：如果失败直接结束，如果成功，返回执行结果 */ public function query($sql)&#123; if(!$result = mysql_query($sql, $this-&gt;resourc)) &#123; echo (&quot;&lt;br /&gt;执行失败。&quot;); echo &quot;&lt;br /&gt;失败的sql语句为：&quot; . $sql; echo &quot;&lt;br /&gt;出错信息为：&quot; . mysql_error(); echo &quot;&lt;br /&gt;错误代号为：&quot; . mysql_errno(); die(); &#125; return $result; &#125; /** * 功能：执行select语句，返回2维数组 * 参数：$sql 字符串类型 select语句 */ public function getAll($sql)&#123; $result = $this-&gt;query($sql); $arr = array(); //空数组 while( $rec = mysql_fetch_assoc( $result ))&#123; $arr[] = $rec;//这样就形成二维数组 &#125; return $arr; &#125; //返回一行数据（作为一维数组） public function getRow($sql)&#123; $result = $this-&gt;query($sql); //$rec = array(); if( $rec2 = mysql_fetch_assoc( $result ))&#123;//返回下标为字段名的数组 //如果fetch出来有数据（也就是取得了一行数据），结果自然是数组 return $rec2; &#125; return false; &#125; //返回一个数据（select语句的第一行第一列） //比如常见的：select count(*) as c from XXX where ... public function getOne($sql)&#123; $result = $this-&gt;query($sql); $rec = mysql_fetch_row($result);//返回下标为数字的数组,且下标一定是0,1,2, 3..... //如果没有数据，返回false if($rec === false)&#123; return false; &#125; return $rec[0]; //该数组的第一项。 &#125;&#125;require &apos;./MySQLDB.class.php&apos;;$dao = MySQLDB::getInstance($config);//$dao , Database Access Object 数据库操作对象（dao层）//获得比赛列表数据$sql = &quot;select * from table;&quot;;$match_list = $dao-&gt;getAll($sql); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP单例模式和工厂模式小记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp下php生成pdf文件!]]></title>
    <url>%2F2016%2F05%2F16%2FThinkPHP%E4%B8%8Bphp%E7%94%9F%E6%88%90PDF%E6%96%87%E4%BB%B6!%2F</url>
    <content type="text"><![CDATA[#####php生成pdf下载：https://github.com/tecnickcom/TCPDF 下载完成放入thinkphp框架vendor目录下，如图： function函数文件加入函数pdf()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 生成pdf * @param string $html 需要生成的内容 */function pdf($html=&apos;&lt;h1 style=&quot;color:red&quot;&gt;这是一个测试文件，生成pdf文件！&lt;/h1&gt;&apos;)&#123; vendor(&apos;tcpdf.tcpdf&apos;); $pdf = new \tcpdf(PDF_PAGE_ORIENTATION, PDF_UNIT, PDF_PAGE_FORMAT, true, &apos;UTF-8&apos;, false); // 设置打印模式 $pdf-&gt;SetCreator(PDF_CREATOR); $pdf-&gt;SetAuthor(&apos;Nicola Asuni&apos;); $pdf-&gt;SetTitle(&apos;TCPDF Example 001&apos;); $pdf-&gt;SetSubject(&apos;TCPDF Tutorial&apos;); $pdf-&gt;SetKeywords(&apos;TCPDF, PDF, example, test, guide&apos;); // 是否显示页眉 $pdf-&gt;setPrintHeader(false); // 设置页眉显示的内容 $pdf-&gt;SetHeaderData(&apos;logo.png&apos;, 60, &apos;baijunyao.com&apos;, &apos;白俊遥博客&apos;, array(0,64,255), array(0,64,128)); // 设置页眉字体 $pdf-&gt;setHeaderFont(Array(&apos;dejavusans&apos;, &apos;&apos;, &apos;12&apos;)); // 页眉距离顶部的距离 $pdf-&gt;SetHeaderMargin(&apos;5&apos;); // 是否显示页脚 $pdf-&gt;setPrintFooter(true); // 设置页脚显示的内容 $pdf-&gt;setFooterData(array(0,64,0), array(0,64,128)); // 设置页脚的字体 $pdf-&gt;setFooterFont(Array(&apos;dejavusans&apos;, &apos;&apos;, &apos;10&apos;)); // 设置页脚距离底部的距离 $pdf-&gt;SetFooterMargin(&apos;10&apos;); // 设置默认等宽字体 $pdf-&gt;SetDefaultMonospacedFont(PDF_FONT_MONOSPACED); // 设置行高 $pdf-&gt;setCellHeightRatio(1); // 设置左、上、右的间距 $pdf-&gt;SetMargins(&apos;10&apos;, &apos;10&apos;, &apos;10&apos;); // 设置是否自动分页 距离底部多少距离时分页 $pdf-&gt;SetAutoPageBreak(TRUE, &apos;15&apos;); // 设置图像比例因子 $pdf-&gt;setImageScale(PDF_IMAGE_SCALE_RATIO); if (@file_exists(dirname(__FILE__).&apos;/lang/eng.php&apos;)) &#123; require_once(dirname(__FILE__).&apos;/lang/eng.php&apos;); $pdf-&gt;setLanguageArray($l); &#125; $pdf-&gt;setFontSubsetting(true); $pdf-&gt;AddPage(); // 设置字体 $pdf-&gt;SetFont(&apos;stsongstdlight&apos;, &apos;&apos;, 14, &apos;&apos;, true); $pdf-&gt;writeHTMLCell(0, 0, &apos;&apos;, &apos;&apos;, $html, 0, 1, 0, true, &apos;&apos;, true); $pdf-&gt;Output(&apos;example_001.pdf&apos;, &apos;I&apos;);&#125; 调用pdf函数，传入内容：1pdf(&quot;hello,world!&quot;); 生成页面效果如图： 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/ThinkPHP下php生成PDF文件!/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp-完整配置config-php!]]></title>
    <url>%2F2016%2F05%2F16%2FThinkPHP-%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AEconfig-php!%2F</url>
    <content type="text"><![CDATA[thinkphp子类的_initialize方法自动调用父类的_initialize方法。而php的构造函数construct，如果要调用父类的方法，必须在子类构造函数显示调用parent::__construct(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148CHECK_FILE_CASE -- windows环境下面的严格检查大小写。 /* 项目设定 */ &apos;APP_DEBUG&apos; =&gt; false, // 是否开启调试模式 &apos;APP_DOMAIN_DEPLOY&apos; =&gt; false, // 是否使用独立域名部署项目 &apos;APP_PLUGIN_ON&apos; =&gt; false, // 是否开启插件机制 &apos;APP_FILE_CASE&apos; =&gt; false, // 是否检查文件的大小写 对Windows平台有效 &apos;APP_GROUP_DEPR&apos; =&gt; &apos;.&apos;, // 模块分组之间的分割符 &apos;APP_GROUP_LIST&apos; =&gt; &apos;&apos;, // 项目分组设定,多个组之间用逗号分隔,例如&apos;Home,Admin&apos; &apos;APP_AUTOLOAD_REG&apos; =&gt; false, // 是否开启SPL_AUTOLOAD_REGISTER &apos;APP_AUTOLOAD_PATH&apos; =&gt; &apos;Think.Util.&apos;,// __autoLoad 机制额外检测路径设置,注意搜索顺序 &apos;APP_CONFIG_LIST&apos; =&gt; array(&apos;taglibs&apos;,&apos;routes&apos;,&apos;tags&apos;,&apos;htmls&apos;,&apos;modules&apos;,&apos;actions&apos;),// 项目额外需要加载的配置列表，默认包括：taglibs(标签库定义),routes(路由定义),tags(标签定义),(htmls)静态缓存定义, modules(扩展模块),actions(扩展操作) /* Cookie设置 */ &apos;COOKIE_EXPIRE&apos; =&gt; 3600, // Coodie有效期 &apos;COOKIE_DOMAIN&apos; =&gt; &apos;&apos;, // Cookie有效域名 &apos;COOKIE_PATH&apos; =&gt; &apos;/&apos;, // Cookie路径 &apos;COOKIE_PREFIX&apos; =&gt; &apos;&apos;, // Cookie前缀 避免冲突 /* 默认设定 */ &apos;DEFAULT_APP&apos; =&gt; &apos;@&apos;, // 默认项目名称，@表示当前项目 &apos;DEFAULT_GROUP&apos; =&gt; &apos;Home&apos;, // 默认分组 &apos;DEFAULT_MODULE&apos; =&gt; &apos;Index&apos;, // 默认模块名称 &apos;DEFAULT_ACTION&apos; =&gt; &apos;index&apos;, // 默认操作名称 &apos;DEFAULT_CHARSET&apos; =&gt; &apos;utf-8&apos;, // 默认输出编码 &apos;DEFAULT_TIMEZONE&apos; =&gt; &apos;PRC&apos;, // 默认时区 &apos;DEFAULT_AJAX_RETURN&apos; =&gt; &apos;JSON&apos;, // 默认AJAX 数据返回格式,可选JSON XML ... &apos;DEFAULT_THEME&apos; =&gt; &apos;default&apos;, // 默认模板主题名称 &apos;DEFAULT_LANG&apos; =&gt; &apos;zh-cn&apos;, // 默认语言 /* 数据库设置 */ &apos;DB_TYPE&apos; =&gt; &apos;mysql&apos;, // 数据库类型 &apos;DB_HOST&apos; =&gt; &apos;localhost&apos;, // 服务器地址 &apos;DB_NAME&apos; =&gt; &apos;&apos;, // 数据库名 &apos;DB_USER&apos; =&gt; &apos;root&apos;, // 用户名 &apos;DB_PWD&apos; =&gt; &apos;&apos;, // 密码 &apos;DB_PORT&apos; =&gt; 3306, // 端口 &apos;DB_PREFIX&apos; =&gt; &apos;think_&apos;, // 数据库表前缀 &apos;DB_SUFFIX&apos; =&gt; &apos;&apos;, // 数据库表后缀 &apos;DB_FIELDTYPE_CHECK&apos; =&gt; false, // 是否进行字段类型检查 &apos;DB_FIELDS_CACHE&apos; =&gt; true, // 启用字段缓存 &apos;DB_CHARSET&apos; =&gt; &apos;utf8&apos;, // 数据库编码默认采用utf8 &apos;DB_DEPLOY_TYPE&apos; =&gt; 0, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器) &apos;DB_RW_SEPARATE&apos; =&gt; false, // 数据库读写是否分离 主从式有效 /* 数据缓存设置 */ &apos;DATA_CACHE_TIME&apos; =&gt; -1, // 数据缓存有效期 &apos;DATA_CACHE_COMPRESS&apos; =&gt; false, // 数据缓存是否压缩缓存 &apos;DATA_CACHE_CHECK&apos; =&gt; false, // 数据缓存是否校验缓存 &apos;DATA_CACHE_TYPE&apos; =&gt; &apos;File&apos;, // 数据缓存类型,支持:File|Db|Apc|Memcache|Shmop|Sqlite| Xcache|Apachenote|Eaccelerator &apos;DATA_CACHE_PATH&apos; =&gt; TEMP_PATH,// 缓存路径设置 (仅对File方式缓存有效) &apos;DATA_CACHE_SUBDIR&apos; =&gt; false, // 使用子目录缓存 (自动根据缓存标识的哈希创建子目录) &apos;DATA_PATH_LEVEL&apos; =&gt; 1, // 子目录缓存级别 /* 错误设置 */ &apos;ERROR_MESSAGE&apos; =&gt; &apos;您浏览的页面暂时发生了错误！请稍后再试～&apos;,//错误显示信息,非调试模式有效 &apos;ERROR_PAGE&apos; =&gt; &apos;&apos;, // 错误定向页面 /* 静态缓存设置 */ &apos;HTML_CACHE_ON&apos; =&gt; false, // 默认关闭静态缓存 &apos;HTML_CACHE_TIME&apos; =&gt; 60, // 静态缓存有效期 &apos;HTML_READ_TYPE&apos; =&gt; 0, // 静态缓存读取方式 0 readfile 1 redirect &apos;HTML_FILE_SUFFIX&apos; =&gt; &apos;.shtml&apos;,// 默认静态文件后缀 /* 语言设置 */ &apos;LANG_SWITCH_ON&apos; =&gt; false, // 默认关闭多语言包功能 &apos;LANG_AUTO_DETECT&apos; =&gt; true, // 自动侦测语言 开启多语言功能后有效 /* 日志设置 */ &apos;LOG_RECORD&apos; =&gt; false, // 默认不记录日志 &apos;LOG_FILE_SIZE&apos; =&gt; 2097152, // 日志文件大小限制 &apos;LOG_RECORD_LEVEL&apos; =&gt; array(&apos;EMERG&apos;,&apos;ALERT&apos;,&apos;CRIT&apos;,&apos;ERR&apos;),// 允许记录的日志级别 /* 分页设置 */ &apos;PAGE_ROLLPAGE&apos; =&gt; 5, // 分页显示页数 &apos;PAGE_LISTROWS&apos; =&gt; 20, // 分页每页显示记录数 /* SESSION设置 */ &apos;SESSION_AUTO_START&apos; =&gt; true, // 是否自动开启Session // 内置SESSION类可用参数 //&apos;SESSION_NAME&apos; =&gt; &apos;&apos;, // Session名称 //&apos;SESSION_PATH&apos; =&gt; &apos;&apos;, // Session保存路径 //&apos;SESSION_CALLBACK&apos; =&gt; &apos;&apos;, // Session 对象反序列化时候的回调函数 /* 运行时间设置 */ &apos;SHOW_RUN_TIME&apos; =&gt; false, // 运行时间显示 &apos;SHOW_ADV_TIME&apos; =&gt; false, // 显示详细的运行时间 &apos;SHOW_DB_TIMES&apos; =&gt; false, // 显示数据库查询和写入次数 &apos;SHOW_CACHE_TIMES&apos; =&gt; false, // 显示缓存操作次数 &apos;SHOW_USE_MEM&apos; =&gt; false, // 显示内存开销 &apos;SHOW_PAGE_TRACE&apos; =&gt; false, // 显示页面Trace信息 由Trace文件定义和Action操作赋值 &apos;SHOW_ERROR_MSG&apos; =&gt; true, // 显示错误信息 /* 模板引擎设置 */ &apos;TMPL_ENGINE_TYPE&apos; =&gt; &apos;Think&apos;, // 默认模板引擎 以下设置仅对使用Think模板引擎有效 &apos;TMPL_DETECT_THEME&apos; =&gt; false, // 自动侦测模板主题 &apos;TMPL_TEMPLATE_SUFFIX&apos; =&gt; &apos;.html&apos;, // 默认模板文件后缀 &apos;TMPL_CACHFILE_SUFFIX&apos; =&gt; &apos;.php&apos;, // 默认模板缓存后缀 &apos;TMPL_DENY_FUNC_LIST&apos; =&gt; &apos;echo,exit&apos;, // 模板引擎禁用函数 &apos;TMPL_PARSE_STRING&apos; =&gt; &apos;&apos;, // 模板引擎要自动替换的字符串，必须是数组形式。 &apos;TMPL_L_DELIM&apos; =&gt; &apos;&#123;&apos;, // 模板引擎普通标签开始标记 &apos;TMPL_R_DELIM&apos; =&gt; &apos;&#125;&apos;, // 模板引擎普通标签结束标记 &apos;TMPL_VAR_IDENTIFY&apos; =&gt; &apos;array&apos;, // 模板变量识别。留空自动判断,参数为&apos;obj&apos;则表示对象 &apos;TMPL_STRIP_SPACE&apos; =&gt; false, // 是否去除模板文件里面的html空格与换行 &apos;TMPL_CACHE_ON&apos; =&gt; true, // 是否开启模板编译缓存,设为false则每次都会重新编译 &apos;TMPL_CACHE_TIME&apos; =&gt; -1, // 模板缓存有效期 -1 为永久，(以数字为值，单位:秒) &apos;TMPL_ACTION_ERROR&apos; =&gt; &apos;Public:success&apos;, // 默认错误跳转对应的模板文件 &apos;TMPL_ACTION_SUCCESS&apos; =&gt; &apos;Public:success&apos;, // 默认成功跳转对应的模板文件 &apos;TMPL_TRACE_FILE&apos; =&gt; THINK_PATH.&apos;/Tpl/PageTrace.tpl.php&apos;, // 页面Trace的模板文件 &apos;TMPL_EXCEPTION_FILE&apos; =&gt; THINK_PATH.&apos;/Tpl/ThinkException.tpl.php&apos;,// 异常页面的模板文件 &apos;TMPL_FILE_DEPR&apos;=&gt;&apos;/&apos;, //模板文件MODULE_NAME与ACTION_NAME之间的分割符，只对项目分组部署有效 // Think模板引擎标签库相关设定 &apos;TAGLIB_BEGIN&apos; =&gt; &apos;&lt;&apos;, // 标签库标签开始标记 &apos;TAGLIB_END&apos; =&gt; &apos;&gt;&apos;, // 标签库标签结束标记 &apos;TAGLIB_LOAD&apos; =&gt; true, // 是否使用内置标签库之外的其它标签库，默认自动检测 &apos;TAGLIB_BUILD_IN&apos; =&gt; &apos;cx&apos;, // 内置标签库名称(标签使用不必指定标签库名称),以逗号分隔 &apos;TAGLIB_PRE_LOAD&apos; =&gt; &apos;&apos;, // 需要额外加载的标签库(须指定标签库名称)，多个以逗号分隔 &apos;TAG_NESTED_LEVEL&apos; =&gt; 3, // 标签嵌套级别 &apos;TAG_EXTEND_PARSE&apos; =&gt; &apos;&apos;, // 指定对普通标签进行扩展定义和解析的函数名称。 /* 表单令牌验证 */ &apos;TOKEN_ON&apos; =&gt; true, // 开启令牌验证 &apos;TOKEN_NAME&apos; =&gt; &apos;__hash__&apos;, // 令牌验证的表单隐藏字段名称 &apos;TOKEN_TYPE&apos; =&gt; &apos;md5&apos;, // 令牌验证哈希规则 /* URL设置 */&apos;URL_CASE_INSENSITIVE&apos; =&gt; false, // URL地址是否不区分大小写 &apos;URL_ROUTER_ON&apos; =&gt; false, // 是否开启URL路由 &apos;URL_DISPATCH_ON&apos; =&gt; true, // 是否启用Dispatcher &apos;URL_MODEL&apos; =&gt; 1, // URL访问模式,可选参数0、1、2、3,代表以下四种模式： // 0 (普通模式); 1 (PATHINFO 模式); 2 (REWRITE 模式); 3 (兼容模式) 当URL_DISPATCH_ON开启后有效; 默认为PATHINFO 模式，提供最好的用户体验和SEO支持 &apos;URL_PATHINFO_MODEL&apos; =&gt; 2, // PATHINFO 模式,使用数字1、2、3代表以下三种模式: // 1 普通模式(参数没有顺序,例如/m/module/a/action/id/1); // 2 智能模式(系统默认使用的模式，可自动识别模块和操作/module/action/id/1/ 或者 /module,action,id,1/...); // 3 兼容模式(通过一个GET变量将PATHINFO传递给dispather，默认为s index.php?s=/module/action/id/1) &apos;URL_PATHINFO_DEPR&apos; =&gt; &apos;/&apos;, // PATHINFO模式下，各参数之间的分割符号 &apos;URL_HTML_SUFFIX&apos; =&gt; &apos;&apos;, // URL伪静态后缀设置 /* 系统变量名称设置 */ &apos;VAR_GROUP&apos; =&gt; &apos;g&apos;, // 默认分组获取变量 &apos;VAR_MODULE&apos; =&gt; &apos;m&apos;, // 默认模块获取变量 &apos;VAR_ACTION&apos; =&gt; &apos;a&apos;, // 默认操作获取变量 &apos;VAR_ROUTER&apos; =&gt; &apos;r&apos;, // 默认路由获取变量 &apos;VAR_PAGE&apos; =&gt; &apos;p&apos;, // 默认分页跳转变量 &apos;VAR_TEMPLATE&apos; =&gt; &apos;t&apos;, // 默认模板切换变量&apos;VAR_LANGUAGE&apos; =&gt; &apos;l&apos;, // 默认语言切换变量 &apos;VAR_AJAX_SUBMIT&apos; =&gt; &apos;ajax&apos;, // 默认的AJAX提交变量 &apos;VAR_PATHINFO&apos; =&gt; &apos;s&apos;, // PATHINFO 兼容模式获取变量例如 ?s=/module/action/id/1 后面的参数取决于URL_PATHINFO_MODEL 和 URL_PATHINFO_DEPR 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/ThinkPHP-完整配置config-php!/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段好用的JQUERY动态添加和删除元素代码！]]></title>
    <url>%2F2016%2F05%2F16%2F%E4%B8%80%E6%AE%B5%E5%A5%BD%E7%94%A8%E7%9A%84JQUERY%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%BB%A3%E7%A0%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;html&gt;&lt;head&gt;&lt;title&gt;TEST&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; form&#123;width:600px;min-height:200px;margin:50px auto;padding:20px;border:1px solid #ccc;&#125; #queryinput div&#123;padding:5px 0;&#125;&lt;/style&gt;&lt;script&gt; $(function()&#123; $(&quot;input[name=&apos;add&apos;]&quot;).click(function(event) &#123; $(&quot;#queryinput&quot;).append($(&quot;#queryinput div:first-child&quot;).clone(true)); &#125;); $(&quot;input[name=&apos;del&apos;]&quot;).click(function(event) &#123; $(this).parent().remove(); &#125;); &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;input type=&quot;button&quot; name=&quot;add&quot; value=&quot;添加查询栏位&quot; /&gt; &lt;div id=&quot;queryinput&quot;&gt; &lt;div&gt; &lt;select&gt; &lt;option&gt;aitem1&lt;/option&gt; &lt;option&gt;bitem2&lt;/option&gt; &lt;option&gt;bitem3&lt;/option&gt; &lt;option&gt;ditem4&lt;/option&gt; &lt;option&gt;eitem5&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;del&quot; value=&quot;删除&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;select&gt; &lt;option&gt;aitem1&lt;/option&gt; &lt;option&gt;bitem2&lt;/option&gt; &lt;option&gt;bitem3&lt;/option&gt; &lt;option&gt;ditem4&lt;/option&gt; &lt;option&gt;eitem5&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;del&quot; value=&quot;删除&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/一段好用的JQUERY动态添加和删除元素代码！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JQUERY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP写接口笔记！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E5%86%99%E6%8E%A5%E5%8F%A3%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[####php://input 通过输入流以文件读取方式取得未经处理的POST原始数据。可以获取POST 请求除enctype=”multipart/form-data” 外的数据流！ 使用 php://input 来代替 $HTTP_RAW_POST_DATA的好处是因为它它给内存带来的压力较小，并且不需要任何特殊的 php.ini 设置。 php://input 与$HTTP_RAW_POST_DATA读取的数据是一样的，都只读取Content-Type不为multipart/form-data的数据。 ###Coentent-Type仅在取值为application/x-www-data-urlencoded和multipart/form-data两种情况下，PHP才会将http请求数据包中相应的数据填入全局变量$_POST ###PHP不能识别的Content-Type类型的时候，会将http请求包中相应的数据填入变量$HTTP_RAW_POST_DATA ###只有Coentent-Type为multipart/form-data的时候，PHP不会将http请求数据包中的相应数据填入php://input，否则其它情况都会。填入的长度，由Coentent-Length指定。 ###只有Content-Type为application/x-www-data-urlencoded时，php://input数据才跟$_POST数据相一致。 ###PHP会将PATH字段的query_path部分，填入全局变量$_GET。通常情况下，GET方法提交的http请求，body为空。php://input读取不到$_GET数据。是因为$_GET数据作为query_path写在http请求头部(header)的PATH字段，而不是写在http请求的body部分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 $data = file_get_contents(&quot;php://input&quot;); //@file phpinput_post.php $data=file_get_contents(&apos;btn.png&apos;); $http_entity_body = $data; $http_entity_type = &apos;application/x-www-form-urlencoded&apos;; $http_entity_length = strlen($http_entity_body); $host = &apos;127.0.0.1&apos;; $port = 80; $path = &apos;/image.php&apos;; $fp = fsockopen($host, $port, $error_no, $error_desc, 30); if ($fp)&#123; fputs($fp, &quot;POST &#123;$path&#125; HTTP/1.1\r\n&quot;); fputs($fp, &quot;Host: &#123;$host&#125;\r\n&quot;); fputs($fp, &quot;Content-Type: &#123;$http_entity_type&#125;\r\n&quot;); fputs($fp, &quot;Content-Length: &#123;$http_entity_length&#125;\r\n&quot;); fputs($fp, &quot;Connection: close\r\n\r\n&quot;); fputs($fp, $http_entity_body . &quot;\r\n\r\n&quot;); while (!feof($fp)) &#123; $d .= fgets($fp, 4096); &#125; fclose($fp); echo $d; &#125; /** *Recieve image data **/ error_reporting(E_ALL); function get_contents() &#123; $xmlstr= file_get_contents(&quot;php://input&quot;); $filename=time().&apos;.png&apos;; if(file_put_contents($filename,$xmlstr))&#123; echo &apos;success&apos;; &#125;else&#123; echo &apos;failed&apos;; &#125; &#125; get_contents(); /** * 获取HTTP请求原文 * @return string */ function get_http_raw() &#123; $raw = &apos;&apos;; // (1) 请求行 $raw .= $_SERVER[&apos;REQUEST_METHOD&apos;].&apos; &apos;.$_SERVER[&apos;REQUEST_URI&apos;].&apos; &apos;.$_SERVER[&apos;SERVER_PROTOCOL&apos;].&quot;\r\n&quot;; // (2) 请求Headers foreach($_SERVER as $key =&gt; $value) &#123; if(substr($key, 0, 5) === &apos;HTTP_&apos;) &#123; $key = substr($key, 5); $key = str_replace(&apos;_&apos;, &apos;-&apos;, $key); $raw .= $key.&apos;: &apos;.$value.&quot;\r\n&quot;; &#125; &#125; // (3) 空行 $raw .= &quot;\r\n&quot;; // (4) 请求Body $raw .= file_get_contents(&apos;php://input&apos;); return $raw; &#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP写接口笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP数组排序的思想！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%81%2F</url>
    <content type="text"><![CDATA[参考：http://zh.wikipedia.org/wiki/冒泡排序冒泡排序目标：将下列数组进行正序（从小到大）排列出来$arr2 = array( 5, 15, 3, 4， 9， 11);一般性逻辑描述：１，对该数组从第一个元素开始，从左到右，相邻的２个元素比较大小：如果左边的比右边的大，则将他们俩交换位置，结果：123456789101112131415array( 5, 15, 3, 4， 9， 11);（原始）array( 5, 15, 3, 4， 9， 11); array( 5, 3， 15, 4， 9， 11);array( 5, 3， 4, 15， 9， 11);array( 5, 3， 4, 9， 15， 11);array( 5, 3， 4, 9， 11， 15);此时，才“走完一轮回”，继续下一轮：array( 5, 3， 4, 9， 11， 15);（初始）array( 3 5， 4, 9， 11， 15);array( 3 4， 5 9， 11， 15);array( 3 4， 5 9， 11， 15);array( 3 4， 5 9， 11， 15);继续下一轮：array( 3 4， 5 9， 11， 15);。。。。。。。。 隐含的逻辑描述（假设数组有n项）：1， 需要进行n-1趟的“冒泡”比较过程。2， 每一趟的比较都前一趟少比一次，第一趟需要比较n-1次3， 每趟比较，都是从数组的开头（0）开始，跟紧挨的元素比较，并进行交换（需要的时候） 1234567891011121314151617//DEMO$arr = array(5,20,3,4,9,10);$len = count($arr);//需要进行n-1次的冒泡比较 for($i=0;$i&lt;$len-1;$i++)&#123;//设定比较的次数//每一次比前一次少一次，第一次要比较n-1 for($j=0;$j&lt;$len-1-$i;$j++)&#123; //这里要实现下标为$j和$j+1的比较 if($arr[$j] &gt;$arr[$j+1])&#123; $a1 = $arr[$j]; $a2 = $arr[$j+1]; $arr[$j] =$a2; $arr[$j+1] = $a1; &#125; &#125;&#125;print_R($arr); 选择排序目标：将下列数组进行正序（从小到大）排列出来$arr2 = array( 5, 15, 3, 4， 9， 11);一般性逻辑描述：第1趟：取得该数组中的最大值及其下标，然后跟该数组的最后一项“交换”（倒数第1项确定）第2趟：取得该数组中除最后1项中的最大值及其下标，然后跟倒数第2项交换（倒数第2项确定）第3趟：取得该数组中除最后2项中的最大值及其下标，然后跟倒数第3项交换（倒数第3项确定）。。。。。。 隐含的逻辑描述（假设数组有n项）：1，要进行n-1趟才可能得出结论2，每一趟要找的数据的个数都比前一趟少一个，第1趟要找n个3，每次找出的最大值所在的项，和要与之进行交换的项的位置，依次减1，第一次的位置n-1DEMO: 12345678910111213141516171819202122//DEMO$arr = array( 5, 15, 3, 4, 9, 11);$len = count($arr);//要进行找出最大值所在项的趟数for($i = 0; $i &lt; $len-1; ++$i)&#123; //设定比较的趟数 $max_val = $arr[0]; //取得第一项，并以之当作存储最大值的变量 $max_key = 0; //取得第一项的下标，并当作存储最大值对应下标的变量 for($k = 0; $k &lt; $len-$i; ++$k)&#123; //这里开始对从0到$len-$i这些元素进行“找最大值及其下标” if($arr[$k] &gt; $max_val)&#123; $max_val = $arr[$k]; //存储最大值 $max_key = $k; //并同时存储对应下标 &#125; &#125; //开始做交换（只有循环结束后，才可以确定最大值及其下标）： $a1 = $arr[$max_key]; $a2 = $arr[$len-1-$i]; $arr[$max_key] = $a2;//$len-1-$i就是“当前查找数据的最后一个位置” $arr[$len-1-$i] = $a1;&#125;print_r($arr); 123456789101112131415161718192021222324252627282930313233343536//DEMO//二分查找思想：//目标：找一个数据（31）在该数组中的位置$v1 = 15;$arr2 = array( 3, 4, 5, 15, 19, 21, 25, 30, 30, 30, 33, 38, 44, 51, 52, 55, 60, 77, 80, 82, 83);//$arr: 要从中找数据的数组//$v: 要找的数据//$start: 要从该数组中查找的开始位置//$start: 要从该数组中查找的结尾位置function binary_search($arr, $v, $start, $end)&#123; if($start &gt; $end)return false; $mid = floor(($start + $end)/2); //计算出中间项的位置 if($v == $arr[$mid])&#123; return $mid; //千恩万谢，第一次就找到了 &#125; else if($v &lt; $arr[$mid])&#123; //此时就只要去“左边那一半”找了 $start = $start; //左边位置还是左边位置 $end = $mid - 1; //右边位置就应该是$mid - 1; //if($start &gt; $end)return false; return binary_search($arr, $v, $start, $end); &#125; else&#123; $start = $mid + 1; //左边位置就应该是$mid + 1 $end = $end; //右边位置还是右边位置; //if($start &gt; $end)return false; return binary_search($arr, $v, $start, $end); &#125;&#125;$len = count($arr2);$result = binary_search($arr2, $v1, 0, $len-1);if($result === false)&#123; echo &quot;没找到&quot;;&#125;else&#123; echo &quot;位置为：$result&quot;;&#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP数组排序的思想！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常见笔试题目收集！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E6%94%B6%E9%9B%86%EF%BC%81%2F</url>
    <content type="text"><![CDATA[PHP介绍1234HTML: Hypertext Markup Language----超文本标记语言 Hypertext Preprocessor----超文本预处理, 是一种用来开发动态网站的服务器脚本语言。Personal Home Page 原始名称 echo、print_r、print、var_dump之间的区别123456* echo、print是php语句，var_dump和print_r是函数* echo 输出一个或多个字符串，中间以逗号隔开，没有返回值是语言结构而不是真正的函数，因此不能作为表达式的一部分使用* print也是php的一个关键字，有返回值 只能打印出简单类型变量的值(如int，string)，如果字符串显示成功则返回true，否则返回false* print_r 可以打印出复杂类型变量的值(如数组、对象）以列表的形式显示，并以array、object开头，* 但print_r输出布尔值和NULL的结果没有意义，因为都是打印&quot;\n&quot;，因此var_dump()函数更适合调试* var_dump() 判断一个变量的类型和长度，并输出变量的数值 include和require的区别12require:出现错误后直接终止退出，程序不再执行 include:包含一个不存在的文件，会提示警告程序会继续执行 PHP中echo和print有什么区别？1234这两个看起来很相似，因为它们都是将一些值打印在屏幕上。但是echo和print的本质区别在于：echo用来输出字符串，显示多个值的时候可以用逗号隔开。只支持基本类型，print不仅可以打印字符串值，而且可以打印函数的返回值。 请问GET和POST方法有什么区别？ 1234网页上填写的表单信息都可以通过这两个方法将数据传递到服务器上，当我们使用GET方法是，所有的信息都会出现在URL地址中，并且使用GET方法最多只能传递1024个字符，所以如果在传输量小或者安全性不那么重要的情况下可以使用GET方法。POST方法，最多可以传输2MB字节的数据，而且可以根据需要调节。 PHP中的PEAR是什么？1PEAR也就是为PHP扩展与应用库（PHP Extension and Application Repository），它是一个PHP扩展及应用的一个代码仓库。 PHP中的错误类型有哪些？1234PHP中遇到的错误类型大致有3类。提示：这都是一些非常正常的信息，而非重大的错误，有些甚至不会展示给用户。比如访问不存在的变量。警告：这是有点严重的错误，将会把警告信息展示给用户，但不会影响代码的输出，比如包含一些不存在的文件。错误：这是真正的严重错误，比如访问不存在的PHP类。 PHP中获取图像尺寸大小的方法是什么？123getimagesize () 获取图片的尺寸Imagesx () 获取图片的宽度Imagesy () 获取图片的高度 @test()和&amp;test()的区别12@test()的作用是屏蔽test()方法中警告的作用 &amp;test()引用test()方法 array+array与array_merge()的区别1234561 键名为数字时，array_merge()不会覆盖掉原来的值，但＋合并数组则会把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值“抛弃”掉（不是覆盖） 2 键名为字符时，＋仍然把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值“抛弃”掉，但array_merge()此时会覆盖掉前面相同键名的值 双引号和单引号的区别12345双引号解释变量，单引号不解释变量双引号里插入单引号，其中单引号里如果有变量的话，变量解释双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用&#123;&#125;讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误双引号解释转义字符，单引号不解释转义字符，但是解释&apos;\和\\能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断） 常用的超全局变量(8个)1234567891011$_GET -----&gt;get传送方式$POST -----&gt;post传送方式$REQUEST -----&gt;可以接收到get和post两种方式的值 $SESSION -----&gt;会话控制的时候会用到$COOKIE -----&gt;会话控制的时候会用到 $GLOBALS -----&gt;所有的变量都放在里面$FILE -----&gt;上传文件使用$SERVER -----&gt;系统环境变量$ENV -----&gt;系统环境变量 在php中定义常量时,const与define的区别?123456789使用const使得代码简单易读，const本身就是一个语言结构，而define是一个函数。另外const在编译时要比define快很多。(1).const用于类成员变量的定义，一经定义，不可修改。define不可用于类成员变量的定义，可用于全局常量。(2).const可在类中使用，define不能。(3).const不能在条件语句中定义常量。(4).const采用一个普通的常量名称，define可以采用表达式作为名称。 (5).const只能接受静态的标量，而define可以采用任何表达式。 (6).const定义的常量时大小写敏感的，而define可通过第三个参数（为true表示大小写不敏感）来指定大小写是否敏感。//define(&apos;HELLO&apos;, &apos;world&apos;, true); //不区分大小写 在PHP中，heredoc是一种特殊的字符串，它的结束标志必须? 12345 $str = &lt;&lt;&lt;SHOW echo&quot;heredoc的语法是用 &lt;&lt;&lt; 加上自己定义成对的标签，在标签范围內的文字视为一个字符串 .结束标识符所在的行不能包含任何其它字符除&quot;;&quot; &quot;;SHOW; 请写一个函数验证电子邮件的格式是否正确 ?12345 function checkEmail($email)&#123;$pregEmail = &quot;/([a-z0-9]*[-_\.]?[a-z0-9]+)*@([a-z0-9]*[-_]?[a-z0-9]+)+[\.][a-z]&#123;2,3&#125;([\.][a-z]&#123;2&#125;)?/i&quot;;return preg_match($pregEmail,$email);&#125; 用最少的代码写一个求3值最大值的函数.12345 function abc($a,$b,$c)&#123; return $a&gt;$b ? ($a&gt;$c?$a:$c) : ($b&gt;$c?$b:$c); //return ($a&gt;$b?$a:$b)&gt;$c ? ($a&gt;$b?$a:$b) : $c;//两种写法 &#125;echo abc(23,34,44);die; 求两个日期的差数1( strtotime(‘2012-12-12′) - strtotime(‘2011-11-11′))/(24*3600); 求月份第一天和最后一天12345date(&quot;Y-m-01&quot;,strtotime(&apos;-1 month&apos;));//上个月第一天date(&quot;Y-m-d&quot;,strtotime(date(&apos;Y-m-01&apos;).&quot;-1 day&quot;));//上个月最后一天（当前月第一天减一天）date(&quot;Y-m-01&quot;);//当月第一天date(&quot;Y-m-d&quot;,strtotime(&apos;Y-m-01&apos;).&quot; +1 month -1 day&quot;));//当月最后一天（当月第一天加一个月减一天） 求昨天的日期123echo date(&quot;Y-h-d H:i:s&quot;,strtotime(&quot;-1days&quot;));echo date(&quot;Y-h-d H:i:s&quot;,strtotime(&quot;-24 hours&quot;));echo date(&quot;Y-h-d H:i:s&quot;,time()-24*3600); if()前面为真，后面则不执行。。。。12345678$a=0;$b=0;if(($a=3)&gt;0||($b=3)&gt;0)&#123;$a++;$b++;echo $a ;echo $b; //输出b的值 ($a=4 ,$b=1) $b=3没有执行&#125; 用PHP写出显示客户端IP与服务器IP的代码 12345678910//客户端 getenv(‘REMOTE_ADDR’);$_SERVER[&apos;REMOTE_ADDR&apos;];//服务器端 getenv(‘SERVER_ADDR’);$_SERVER[&apos;SERVER_ADDR&apos;]; gethostbyname(“www.baidu.com”);//客户端的ip(要求取得一个int) ip2long进行转换 求$a 的值 123456789101112$a = 3;echo &quot;$a&quot;; // 3 echo &apos;$a&apos;; // $a echo &quot;\$a&quot;; // $aecho &quot;\\$a&quot;; // \3echo &quot;\\\$a&quot;; // \$aecho &quot;$&#123;a&#125;&quot;; //3echo &apos;$&#123;a&#125;&apos;; //$&#123;a&#125;echo &quot;$a&quot;.&quot;$a&quot;; // 33echo &quot;$a&quot;+&quot;$a&quot;;// 6 不用新变量直接交换现有两个变量的值.1答案：list($a, $b) = array($b, $a); 说明php中传值与传引用的区别，并说明传值什么时候传引用？12345678变量默认总是传值赋值，那也就是说，当将一个表达式的值赋予一个变量时，整个表达式的值被赋值到目标变量，这意味着：当一个变量的赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量php也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的__引用__(换言之，成为了其别名或者指向)了原始变量。改动的新的变量将影响到原始变量，反之亦然。使用引用赋值，简单地将一个&amp;符号加到将要赋值的变量前(源变量)对象默认是传引用对于较大是的数据，传引用比较好，这样可以节省内存的开销 描述一下php开发中常见的几种攻击以及解决方案123 SQL注入： 解决这个问题的办法是，将 PHP 的内置 mysql_real_escape_string() 函数用作任何用户输入的包装器。这个函数对字符串中的字符进行转义，使字符串不可能传递撇号等特殊字符并让 [MySQL](http://lib.csdn.net/base/mysql) 根据特殊字符进行操作。 跨站点脚本攻击（XSS）: strip_tags() 函数，这个函数可以清除任何包围在 HTML 标记中的内容 或者使用htmlspecialchars() 函数。 开发一款扑克游戏，请给出一套洗牌算法，公平的洗牌并将洗好的牌存储在一个整形数组里。（鑫众人云）123456789101112$card_num = 54;//牌数 function ws($n)&#123; $arr = range(1,$n);//定义一个数组 for($i=1;$i&lt;=$n;$i++)&#123; $k = array_rand($arr,1);//数组随机返回key $new[] = $arr[$k];//把随机数放新数组 unset($arr[$k]);//销毁随机数 &#125; return $new;//返回新数组 &#125;echo&quot;&lt;pre&gt;&quot;; print_R(ws(54)); 12mysql 存储引擎MyISAM和INNODB区别？？？memcache,redis,mongodb区别？？？ 1.HTTP协议中几个状态码的含义:1xx（临时响应） Php代码1.表示临时响应并需要请求者继续执行操作的状态代码。 3.代码 说明4.100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。5.101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 7.2xx （成功）8.表示成功处理了请求的状态代码。9.代码 说明10.200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。11.201 （已创建） 请求成功并且服务器创建了新的资源。12.202 （已接受） 服务器已接受请求，但尚未处理。13.203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。14.204 （无内容） 服务器成功处理了请求，但没有返回任何内容。15.205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。16.206 （部分内容） 服务器成功处理了部分 GET 请求。 18.3xx （重定向）19.表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 21.代码 说明22.300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。23.301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。24.302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。25.303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。26.304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。27.305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。28.307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 30.4xx（请求错误）31.这些状态代码表示请求可能出错，妨碍了服务器的处理。 33.代码 说明34.400 （错误请求） 服务器不理解请求的语法。35.401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。36.403 （禁止） 服务器拒绝请求。37.404 （未找到） 服务器找不到请求的网页。38.405 （方法禁用） 禁用请求中指定的方法。39.406 （不接受） 无法使用请求的内容特性响应请求的网页。40.407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。41.408 （请求超时） 服务器等候请求时发生超时。42.409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。43.410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。44.411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。45.412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。46.413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。47.414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。48.415 （不支持的媒体类型） 请求的格式不受请求页面的支持。49.416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。50.417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 52.5xx（服务器错误）53.这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 55.代码 说明56.500 （服务器内部错误） 服务器遇到错误，无法完成请求。57.501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。58.502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。59.503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。60.504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。61.505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP常见笔试题目收集！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP数组排序等数据结构基础算法！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AD%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%81%2F</url>
    <content type="text"><![CDATA[参考：http://zh.wikipedia.org/wiki/冒泡排序冒泡排序目标：将下列数组进行正序（从小到大）排列出来$arr2 = array( 5, 15, 3, 4， 9， 11);一般性逻辑描述：１，对该数组从第一个元素开始，从左到右，相邻的２个元素比较大小：如果左边的比右边的大，则将他们俩交换位置，结果：123456789101112131415array( 5, 15, 3, 4， 9， 11);（原始）array( 5, 15, 3, 4， 9， 11); array( 5, 3， 15, 4， 9， 11);array( 5, 3， 4, 15， 9， 11);array( 5, 3， 4, 9， 15， 11);array( 5, 3， 4, 9， 11， 15);此时，才“走完一轮回”，继续下一轮：array( 5, 3， 4, 9， 11， 15);（初始）array( 3 5， 4, 9， 11， 15);array( 3 4， 5 9， 11， 15);array( 3 4， 5 9， 11， 15);array( 3 4， 5 9， 11， 15);继续下一轮：array( 3 4， 5 9， 11， 15);。。。。。。。。 隐含的逻辑描述（假设数组有n项）：1， 需要进行n-1趟的“冒泡”比较过程。2， 每一趟的比较都前一趟少比一次，第一趟需要比较n-1次3， 每趟比较，都是从数组的开头（0）开始，跟紧挨的元素比较，并进行交换（需要的时候） 1234567891011121314151617//DEMO$arr = array(5,20,3,4,9,10);$len = count($arr);////要进行找出最大值所在项的趟数，需要进行n-1次的冒泡比较 for($i=0;$i&lt;$len-1;$i++)&#123;//设定比较的次数//每一次比前一次少一次，第一次要比较n-1 for($j=0;$j&lt;$len-1-$i;$j++)&#123; //这里要实现下标为$j和$j+1的比较 if($arr[$j] &gt;$arr[$j+1])&#123; $a1 = $arr[$j]; $a2 = $arr[$j+1]; $arr[$j] =$a2; $arr[$j+1] = $a1; &#125; &#125;&#125;print_R($arr); 选择排序目标：将下列数组进行正序（从小到大）排列出来$arr2 = array( 5, 15, 3, 4， 9， 11);一般性逻辑描述：第1趟：取得该数组中的最大值及其下标，然后跟该数组的最后一项“交换”（倒数第1项确定）第2趟：取得该数组中除最后1项中的最大值及其下标，然后跟倒数第2项交换（倒数第2项确定）第3趟：取得该数组中除最后2项中的最大值及其下标，然后跟倒数第3项交换（倒数第3项确定）。。。。。。 隐含的逻辑描述（假设数组有n项）：1，要进行n-1趟才可能得出结论2，每一趟要找的数据的个数都比前一趟少一个，第1趟要找n个3，每次找出的最大值所在的项，和要与之进行交换的项的位置，依次减1，第一次的位置n-1DEMO: 12345678910111213141516171819202122//DEMO$arr = array( 5, 15, 3, 4, 9, 11);$len = count($arr);//要进行找出最大值所在项的趟数for($i = 0; $i &lt; $len-1; ++$i)&#123; //设定比较的趟数 $max_val = $arr[0]; //取得第一项，并以之当作存储最大值的变量 $max_key = 0; //取得第一项的下标，并当作存储最大值对应下标的变量 for($k = 0; $k &lt; $len-$i; ++$k)&#123; //这里开始对从0到$len-$i这些元素进行“找最大值及其下标” if($arr[$k] &gt; $max_val)&#123; $max_val = $arr[$k]; //存储最大值 $max_key = $k; //并同时存储对应下标 &#125; &#125; //开始做交换（只有循环结束后，才可以确定最大值及其下标）： $a1 = $arr[$max_key]; $a2 = $arr[$len-1-$i]; $arr[$max_key] = $a2;//$len-1-$i就是“当前查找数据的最后一个位置” $arr[$len-1-$i] = $a1;&#125;print_r($arr); 123456789101112131415161718192021222324252627282930313233343536//DEMO//二分查找思想：//目标：找一个数据（31）在该数组中的位置$v1 = 15;$arr2 = array( 3, 4, 5, 15, 19, 21, 25, 30, 30, 30, 33, 38, 44, 51, 52, 55, 60, 77, 80, 82, 83);//$arr: 要从中找数据的数组//$v: 要找的数据//$start: 要从该数组中查找的开始位置//$start: 要从该数组中查找的结尾位置function binary_search($arr, $v, $start, $end)&#123; if($start &gt; $end)return false; $mid = floor(($start + $end)/2); //计算出中间项的位置 if($v == $arr[$mid])&#123; return $mid; //千恩万谢，第一次就找到了 &#125; else if($v &lt; $arr[$mid])&#123; //此时就只要去“左边那一半”找了 $start = $start; //左边位置还是左边位置 $end = $mid - 1; //右边位置就应该是$mid - 1; //if($start &gt; $end)return false; return binary_search($arr, $v, $start, $end); &#125; else&#123; $start = $mid + 1; //左边位置就应该是$mid + 1 $end = $end; //右边位置还是右边位置; //if($start &gt; $end)return false; return binary_search($arr, $v, $start, $end); &#125;&#125;$len = count($arr2);$result = binary_search($arr2, $v1, 0, $len-1);if($result === false)&#123; echo &quot;没找到&quot;;&#125;else&#123; echo &quot;位置为：$result&quot;;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320//-------------------- // 基本数据结构算法//--------------------//二分查找（数组里查找某个元素） function bin_sch($array, $low, $high, $k)&#123; if ($low &lt;= $high)&#123; $mid = intval(($low+$high)/2); if ($array[$mid] == $k)&#123; return $mid; &#125;elseif ($k &lt; $array[$mid])&#123; return bin_sch($array, $low, $mid-1, $k); &#125;else&#123; return bin_sch($array, $mid+1, $high, $k); &#125; &#125; return -1; &#125; //顺序查找（数组里查找某个元素） function seq_sch($array, $n, $k)&#123; $array[$n] = $k; for($i=0; $i&lt;$n; $i++)&#123; if($array[$i]==$k)&#123; break; &#125; &#125; if ($i&lt;$n)&#123; return $i; &#125;else&#123; return -1; &#125; &#125; //线性表的删除（数组中实现） function delete_array_element($array, $i) &#123; $len = count($array); for ($j=$i; $j&lt;$len; $j++)&#123; $array[$j] = $array[$j+1]; &#125; array_pop($array); return $array; &#125;//冒泡排序（数组排序） function bubble_sort($array) &#123; $count = count($array); if ($count &lt;= 0) return false; for($i=0; $i&lt;$count; $i++)&#123; for($j=$count-1; $j&gt;$i; $j--)&#123; if ($array[$j] &lt; $array[$j-1])&#123; $tmp = $array[$j]; $array[$j] = $array[$j-1]; $array[$j-1] = $tmp; &#125; &#125; &#125; return $array; &#125;//快速排序（数组排序） function quick_sort($array) &#123; if (count($array) &lt;= 1) return $array; $key = $array[0]; $left_arr = array(); $right_arr = array(); for ($i=1; $i&lt;count($array); $i++)&#123; if ($array[$i] &lt;= $key) $left_arr[] = $array[$i]; else $right_arr[] = $array[$i]; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, array($key), $right_arr); &#125; //------------------------ // PHP内置字符串函数实现 //------------------------//字符串长度 function strlen($str) &#123; if ($str == &apos;&apos;) return 0; $count = 0; while (1)&#123; if ($str[$count] != NULL)&#123; $count++; continue; &#125;else&#123; break; &#125; &#125; return $count; &#125;//截取子串 function substr($str, $start, $length=NULL) &#123; if ($str==&apos;&apos; || $start&gt;strlen($str)) return; if (($length!=NULL) &amp;&amp; ($start&gt;0) &amp;&amp; ($length&gt;strlen($str)-$start)) return; if (($length!=NULL) &amp;&amp; ($start&lt;0) &amp;&amp; ($length&gt;strlen($str)+$start)) return; if ($length == NULL) $length = (strlen($str) - $start); if ($start &lt; 0)&#123; for ($i=(strlen($str)+$start); $i&lt;(strlen($str)+$start+$length); $i++) &#123; $substr .= $str[$i]; &#125; &#125; if ($length &gt; 0)&#123; for ($i=$start; $i&lt;($start+$length); $i++) &#123; $substr .= $str[$i]; &#125; &#125; if ($length &lt; 0)&#123; for ($i=$start; $i&lt;(strlen($str)+$length); $i++) &#123; $substr .= $str[$i]; &#125; &#125; return $substr; &#125;//字符串翻转 function strrev($str) &#123; if ($str == &apos;&apos;) return 0; for ($i=(strlen($str)-1); $i&gt;=0; $i--)&#123; $rev_str .= $str[$i]; &#125; return $rev_str; &#125;//字符串比较 function strcmp($s1, $s2) &#123; if (strlen($s1) &lt; strlen($s2)) return -1; if (strlen($s1) &gt; strlen($s2)) return 1; for ($i=0; $i&lt;strlen($s1); $i++)&#123; if ($s1[$i] == $s2[$i])&#123; continue; &#125;else&#123; return false; &#125; &#125; return 0; &#125;//查找字符串 function strstr($str, $substr) &#123; $m = strlen($str); $n = strlen($substr); if ($m &lt; $n) return false; for ($i=0; $i&lt;=($m-$n+1); $i++)&#123; $sub = substr($str, $i, $n); if (strcmp($sub, $substr) == 0) return $i; &#125; return false; &#125;//字符串替换 function str_replace($substr, $newsubstr, $str) &#123; $m = strlen($str); $n = strlen($substr); $x = strlen($newsubstr); if (strchr($str, $substr) == false) return false; for ($i=0; $i&lt;=($m-$n+1); $i++)&#123; $i = strchr($str, $substr); $str = str_delete($str, $i, $n); $str = str_insert($str, $i, $newstr); &#125; return $str; &#125; //-------------------- // 自实现字符串处理函数//--------------------//插入一段字符串 function str_insert($str, $i, $substr) &#123; for($j=0; $j&lt;$i; $j++)&#123; $startstr .= $str[$j]; &#125; for ($j=$i; $j&lt;strlen($str); $j++)&#123; $laststr .= $str[$j]; &#125; $str = ($startstr . $substr . $laststr); return $str; &#125;//删除一段字符串 function str_delete($str, $i, $j) &#123; for ($c=0; $c&lt;$i; $c++)&#123; $startstr .= $str[$c]; &#125; for ($c=($i+$j); $c&lt;strlen($str); $c++)&#123; $laststr .= $str[$c]; &#125; $str = ($startstr . $laststr); return $str; &#125;//复制字符串 function strcpy($s1, $s2) &#123; if (strlen($s1)==NULL || !isset($s2)) return; for ($i=0; $i&lt;strlen($s1); $i++)&#123; $s2[] = $s1[$i]; &#125; return $s2; &#125;//连接字符串 function strcat($s1, $s2) &#123; if (!isset($s1) || !isset($s2)) return; $newstr = $s1; for($i=0; $i&lt;count($s); $i++)&#123; $newstr .= $st[$i]; &#125; return $newsstr; &#125;//简单编码函数（与php_decode函数对应） function php_encode($str) &#123; if ($str==&apos;&apos; &amp;&amp; strlen($str)&gt;128) return false; for($i=0; $i&lt;strlen($str); $i++)&#123; $c = ord($str[$i]); if ($c&gt;31 &amp;&amp; $c&lt;107) $c += 20; if ($c&gt;106 &amp;&amp; $c&lt;127) $c -= 75; $word = chr($c); $s .= $word; &#125; return $s; &#125;//简单解码函数（与php_encode函数对应） function php_decode($str) &#123; if ($str==&apos;&apos; &amp;&amp; strlen($str)&gt;128) return false; for($i=0; $i&lt;strlen($str); $i++)&#123; $c = ord($word); if ($c&gt;106 &amp;&amp; $c&lt;127) $c = $c-20; if ($c&gt;31 &amp;&amp; $c&lt;107) $c = $c+75; $word = chr($c); $s .= $word; &#125; return $s; &#125;//简单加密函数（与php_decrypt函数对应） function php_encrypt($str) &#123; $encrypt_key = &apos;abcdefghijklmnopqrstuvwxyz1234567890&apos;; $decrypt_key = &apos;ngzqtcobmuhelkpdawxfyivrsj2468021359&apos;; if (strlen($str) == 0) return false; for ($i=0; $i&lt;strlen($str); $i++)&#123; for ($j=0; $j&lt;strlen($encrypt_key); $j++)&#123; if ($str[$i] == $encrypt_key[$j])&#123; $enstr .= $decrypt_key[$j]; break; &#125; &#125; &#125; return $enstr; &#125;//简单解密函数（与php_encrypt函数对应） function php_decrypt($str) &#123; $encrypt_key = &apos;abcdefghijklmnopqrstuvwxyz1234567890&apos;; $decrypt_key = &apos;ngzqtcobmuhelkpdawxfyivrsj2468021359&apos;; if (strlen($str) == 0) return false; for ($i=0; $i&lt;strlen($str); $i++)&#123; for ($j=0; $j&lt;strlen($decrypt_key); $j++)&#123; if ($str[$i] == $decrypt_key[$j])&#123; $enstr .= $encrypt_key[$j]; break; &#125; &#125; &#125; return $enstr; &#125; 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP数组排序等数据结构基础算法！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML、CSS、JavaScript、PHP、Linux笔记！]]></title>
    <url>%2F2016%2F05%2F16%2F%E5%87%BD%E6%95%B0%E5%BA%93%E6%94%B6%E9%9B%86%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859LINUX常用命令:1.pwd(Print Working Directory) 描述:打印当前目录 语法: pwd2.cd (Change Directory) 描述:改变当前目录 语法: cd 选项cd .. :返回上一级目录(父目录) cd . :返回当前目录cd ~ :返回当前用户的主目录 cd / :返回根目录3.路径 相对路径:从当前目录开始的路径。 绝对路径:从根目录开始的路径。4.ls(list)命令 描述:显示目录的所有文件及子目录 语法: ls [参数] [目录]-l(long):显示文档/目录的详细信息(权限、用户、用户组、尺寸等)-a(all) : 显示所有文档及子目录 -R[Recursive] 递归显示5.mkdir(Make Directory) 描述:创建目录 语法:mkdir [参数] 路径 -p 同时创建父子目录6.rmdir(Remove Directory) 描述:删除目录 语法:rmdir [参数] 路径-p 同时删除父子目录,但要求所有的目录内不能存在文件。说明:只能删除空目录(不存在文件和子目录)。使用命令进行删除时,不经过回收站。7.mv(Move) 描述:移动文件/目录 语法:mv 源文件/目录 目标文件/目录如果目标目录不存在,则将源目录移动到指定位置后,名称为指定的新名称。如果目标目录已经存在并且没有指定新名称时,则移动后名称为原来的名称。8.unlink 描述:删除文件 语法:unlink 路径9.touch 描述:设置文件的创建访问及修改时间,如果文件不存在,则创建。 语法: touch 路径10.rm(Remove) 描述:删除文件/目录 语法:rm [参数] 路径-f [force] 不询问是否删除 -r [recursive] 递归11.cp(Copy) 描述:复制文件/目录 语法:cp [参数] 源路径 目标路径 -r [recursive] 递归权限问题:r[read] 4 ; w[write] 2; x[execute] 1;0: --- 1: --x 2: -w- 3: -wx 4: r-- 5: r-x 6: rw- 7: rwx (user group others)chmod 描述:权限 语法:chmod 权限 [-R] 路径vi(Visual) vi [+行号] [文件的路径及名称]i I ==&gt; 进入编辑状态Esc ==&gt; 命令状态:w [文件的路径及名称](Write) --&gt; 保存,但仍然可编辑:q! (Quit) --&gt; 不保存,并且退出:wq[文件的路径及名称] --&gt; 保存并退出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237HTML:标签:&lt;b&gt;...&lt;/b&gt; 加粗 &lt;strong&gt;...&lt;/strong&gt; 加粗&lt;i&gt;...&lt;/i&gt; 倾斜 &lt;em&gt;...&lt;/em&gt; 倾斜&lt;u&gt;...&lt;/u&gt; 下划线 &lt;s&gt;...&lt;/s&gt; 删除线&lt;strike&gt;...&lt;/strike&gt; 删除线 &lt;sup&gt;...&lt;/sup&gt; 上标&lt;sub&gt;...&lt;/sub&gt; 下标 &lt;span&gt;...&lt;/span&gt; 内联对象表格属性:width:宽度 height:高度border:边框宽度 bordercolor:边框颜色bgcolor:背景颜色 background:背景图像align:水平对齐方式(left|center|right) cellpadding:单元格边距(单元格内容与框线之间的距离)cellspacing:单元格间距(相邻单元格之间的距离)单元格属性:width:宽度 height:高度bgcolor:背景颜色 background:背景图像align:水平对齐方式(left|center|right,默认为left)valign:垂直对齐方式(top|middle|bottom,默认为middle)rowspan:行合并数目 colspan:列合并数目行属性:height:高度 bgcolor:背景颜色align:水平对齐方式(left|center|right,默认为left)body标记的属性:leftmargin:左边距 topmargin:上边距rightmargin:右边距 bottommargin:下边距 bgcolor:背景颜色HTML实体:大于号: &gt; 小于号: &lt; 单引号: &apos;按位与: &amp; 双引号: &quot; 不间断空格: 版权符号: © 注册商品: ® 英镑: £欧元: € 日元: ¥乘号: × 除号: ÷有序列表、无序列表及定义列表: 有序列表 &lt;ol type=&quot;1|a|A|i|I&quot; start=&quot;起始编号&quot;&gt;&lt;li&gt;...&lt;/li&gt;...&lt;/ol&gt; 无序列表 &lt;ul type=&quot;disc|square|circle&quot;&gt;&lt;li&gt;...&lt;/li&gt;...&lt;/ul&gt; 定义列表 &lt;dl&gt; &lt;dt&gt;...&lt;/dt&gt; &lt;dd&gt;...&lt;/dd&gt; ...&lt;/dl&gt; 缩进: &lt;blockquote&gt;...&lt;/blockquote&gt; 保持原样 &lt;pre&gt;....&lt;/pre&gt; CSS样式:clear描述:清除浮动 语法:clear:left|right|both; 作用:清除浮动为了良好的文档结构及良好的代码阅读性,一定我们定义如下的CSS类:/* == clearfix == */.clearfix:after &#123; /*/*/ content: &quot;.&quot;; /* IE8 hack */ display: block; height: 0; clear: both; visibility: hidden; &#125;/* IE7 hack */.clearfix &#123; display: inline-block; &#125;/* IE-mac, IE5, IE6 */* html .clearfix &#123; height: 1%; &#125;.clearfix &#123; display: block; &#125;当我们定义完毕该类后,只需要在浮动对象的父对象上添加class=&quot;clearfix&quot;属性即可。重要提示:如果子标记存在float属性,并且还存在margin属性,那么将在IE6中产生双倍间距！！！清理IE6双倍间距display:inline; 边框属性:border-top-width 描述:设置上边框的线宽 语法:border-top-width:value;border-top-style 描述:设置上边框的线型 语法:border-top-style:none|solid|dotted|dashed;border-top-color 描述:设置上边框的颜色 语法:border-top-color:value;border-top 描述:设置上边框的样式 语法:border-top:线宽 线型 颜色;Border 描述:设置边框的样式 语法:border:线宽 线型 颜色;列表样式:list-style-type 描述:设置列表样式 语法:list-style-type:none|circle|disc|square|lower-alphalist-style-image 描述:设置列表图像 语法:list-style-image:url(背景URL);list-style-position 描述:设置列表符号的位置 语法:list-style-position:inside|outside;list-style 描述:设置列表属性 语法:list-style:type url(图像URL) position;定位属性:Position 描述:设置对象的定位方式 语法:position:static(静态)|relative(相对)|absolute(绝对);Left 描述:设置与父对象左侧的间距 语法:left:value;Top 描述:设置与父对象上侧的间距 语法:top:value;Right 描述:设置与父对象右侧的间距 语法:right:value;Bottom 描述:设置与父对象下侧的间距 语法:bottom:value;z-index 描述:设置对象的叠放顺序 语法:z-index:value;重要说明:relative为相对定位,此时使用top、left、right、bottom等属性时是相对于父对象而言。但是该对象没有脱离文档流。absolute为绝对定位,此时使用top、left、right、bottom等属性时是相对于浏览器的坐标原点而言。但是该对象已经脱离文档流。(父)relative+(子)absolute,此时:(1)、子对象的定位为绝对定位。对象已经脱离文档流。(2)、子对象是相对于父对象的坐标原点而言的。半透明颜色:IE:filter:alpha(opacity=value); 取值范围为0~100Firefox等:opacity:value; (取值为0~1)Cursor:描述:设置鼠标指针类型语法:cursor:pointer(手形)|wait(沙漏)|text(I形)|crosshair(十字光标)|help(帮助);解决IE6不支持PNG透明:(1)、PNG透明图像作为背景使用filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=是否启用效果,src=背景图像URL,sizingmethod=图像的显示方式)enabled值只能为true/false。src为PNG透明图像的URL。sizingmethod为图像显示方式(image|scale|crop)image:放大/缩小盒子的尺寸,以显示一个完整的图像。scale:放大/缩小图像,以显示充满盒子。crop:裁切,只显示盒子尺寸部分的图像(2)、PNG透明图像作为图像使用 直接在文档的头部,书写 &lt;script type=&quot;text/javascript&quot; src=&quot;JS文档URL&quot;&gt;&lt;/script&gt;(3)、无论为PNG的图像/背景图像添加链接,那么IE6中,产生 (1)、鼠标形状在文本的空白区域没有呈现手形 (2)、文本的空白区域内不能使用链接 解决方案: 为链接添加以下样式: cursor:pointer; position:relative; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210PHP函数: 1数字函数：floor float floor(float $value) float float 舍一取整ceil float ceil(float $value) float float 进一取整min mixed min(int $value....) int intmax mixed max(int $value....) int intround float round(float $value) float floatpow pow(5.2); 幂运算sqrt sqrt(23); 求平方根2.日期函数：time int time(void) int voiddate string date(string $format) string stringdate string date(string $format,int $value) string string intdate_default_timezone_set() bool date_default_timezone_set(string$value) bool stringdate_default_timezone_get() string date_default_timezone_get(void) string voidstrtotime string strtotime(string $value) string string 3.字符串函数：strlen int strlen(string $string) int stringstpos int strpos(string $sting,mixed $needle) int string stringsubstr string substr(string $string,int $start,int $length) string string intstr_replace string str_replace(被替换的内容,替换的内容,原字符串) stringunset() void unset(string $string) void string ucwords:把每个单词的首字母改成大写的ucfirst:把首字母改成大写的 uclower:把字母改成小写的ucupper:把字母改成大写的 trim:把字符两侧的空格去掉md5:加密文件 strrev:把字符反转4.数组函数：count int count(array $array) int arrayexplode array explode(char $val,string $val) array char stringjoin string join(char $val,array $array) string char arrayarray_values array array_values(array $array) array arrayarray_keys array array_keys(array $array) array arrayarray_shift() string array_shift(array $array) string arrayarray_pop string array_pop(array $array) string arraycurrent string current(array &amp;$array) string arraynext string next(array &amp;$array) string arrayprev string prev(array &amp;$array) string arrayreset string reset(array &amp;$array) string arrayend string end(array &amp;$array) string arrayin_array boolen in_array(string $val,array $array) boolen array stringsort array sort(array $array) array arrayarray_reverse array array_reverse(array $array) array array 数组倒置5.函数函数库：func_get_arg(); mixed func_get_arg(int $val) mixed intfunc_get_args(); array func_get_args(void) array voidfunction_exists(); boolen function_exists(函数名字) boolen func_get_arg(); 返回对应位置参数的值 func_get_args(); 以数组的形式获得参数的值func_num_args(); 返回参数的个数 function_exists();判断函数是否存在6.文件函数：fopen(); resource fopen(string $filename,string $mode) resource stringfwrite; int fwrite(string $openfile,string 要写入的内容) int stringfread(); srtring fread(string $openfile) string stringfclose(); boolen fclose($openfile) boolen string filesize(); int filesize($filename) int stringfile_get_contents(); fopen+fread string stringfile_put_contents(); fopen+fwrite+fclose int stringunlink boolen unlink($filename) boolen stringis_file: 判断文件是否存在 boolen string serialize string serialize(mixed val) string mixedunserialize mixed unserialize(string ) mixed stringinclude/include_once: 如果找不到包含文件,后面的文件继续执行require/require_once: 如果找不到包含文件,后面的文件不执行了get_include_path; set_include_path;__FLIE__:获得当前文件的路径;dirname(__FILE__):获得当前文件的路径 ,但不包含文件名basename(__FILE__):获得当前文件的名称URL函数：string urlencode(url) url编码 string urlencode(str) url编码Mysql中聚合函数:1.本地图片，请重新上传算数运算函数: 2 字符串函数: 本地图片，请重新上传 php 操作mysql函数库:本地图片，请重新上传 url函数:string urlencode（url） url编码string urldecode(str) url解码 php图像函数库:int $x , int $y , 点的坐标。int $color 颜色。int $x1 , int $y1 , 起点的坐标。int $x2 , int $y2 , 终点的坐标。int $font , 字号。 string $c ,图像上写的字。本地图片，请重新上传 聚合函数:本地图片，请重新上传 JavaScript函数:数字函数:Math.ceil;进一取整; Math.round;四舍五入;Math.floor;舍一取整; Math.max;取最大数;Math.min;取最小数; Math.random;随即数;Math.abs;绝对值;日期函数:var d=new date();日期; var year=d.getYear(); var month=d.getMonth();var day=d.getDate();日 var week=d.getDay();星期几 var hour=d.getHours();var minute=d.getMinute(); var second=d.getSeconds();字符串函数:charAt();返回指定位置对应的字符; indexOf();返回指定字符对应的位置;lastIndexOf();从最后开始寻找,返回指定字符对应的位置;replace();替换; split();分割字符串,返回数组;substr(&quot;起始值&quot;,&quot;长度&quot;);截取字符串; substring(&quot;起始值&quot;,&quot;最后位置&quot;);截取字符串;toLowerCase();转小写; toUpperCase();转大写;JavaScript方法:alert(); confirm();setTimeout(&quot;函数()&quot;,&quot;时间&quot;); open(&quot;页面地址&quot;,&quot;pop&quot;,&quot;width=值,height=值,top=值,left=值&quot;);close();关闭当前页面; document.write(&quot;内容&quot;); document.getElementById();获取对象; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Jquery相关知识:$(&quot;对象&quot;).attr(&quot;属性名&quot;,&quot;值&quot;);操纵属性Jquery对象.attr(&quot;属性名&quot;);获取属性值; Jquery对象.removeAttr(&quot;属性名&quot;);移除属性操作表单元素Jquery对象.val(&quot;值&quot;):设置值; Jquery对象.val();获得值;Jquery对象.html(); Jquery对象.html(&quot;值&quot;);Jquery对象.text(); Jquery对象.text(&quot;值&quot;);Jquery对象.addClass(&quot;类名&quot;); Jquery对象.removeClass(&quot;类名&quot;);Jquery对象.toggleClass(&quot;类名&quot;); Jquery对象.css(&quot;样式名&quot;,&quot;值&quot;);Jquery对象.css(&quot;样式名&quot;);Jquery对象.css(&#123;&quot;样式名&quot;:&quot;值&quot;,&quot;样式名&quot;:&quot;值&quot;。。。&#125;); 用到了json对象;Jquery对象.width(&quot;值&quot;); Jquery对象.height(&quot;值&quot;);绝对定位获得标签的左边距和上边距:Jquery对象.css(&quot;left&quot;); Jquery对象.css(&quot;top&quot;);相对定位获得标签的左边距和上边距:Jquery对象.offset().left; Jquery对象..offset().top;给某个标签邦定事件:Jquery对象.bind(&quot;事件&quot;,&quot;函数明&quot;); 事件on要去掉,函数名不能加括号;Jquery对象.bind(&quot;事件&quot;.function()&#123;执行代码&#125;);获取鼠标的坐标:Jquery对象.bind(&quot;mousemove&quot;,function(e)&#123; var x=e.pageX; var y=e.pageY;&#125;)Jquery对象.hide(［时间］,［函数］); Jquery对象.show(［时间］,［函数］);Jquery对象.toggle(［时间］,［函数］);滑动:Jquery对象.slideDown(［时间］,［函数］); Jquery对象.slideUp(［时间］,［函数］);Jquery对象.slideToggle(［时间］,［函数］);淡入淡出:Jquery对象.fadeIn(［时间］,［函数］); Jquery对象.fadeOut(［时间］,［函数］);Jquery对象.fadeTo(［时间］,［函数］);ajax$.ajax(&#123;type:&quot;post&quot;,url:&quot;处理页面&quot;,data:&quot;参数&quot;,dataType:&quot;html/json/xml&quot;,success:function(msg)&#123;执行代码&#125;&#125;); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/函数库收集！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JavaScript</tag>
        <tag>Linux</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记！]]></title>
    <url>%2F2016%2F05%2F16%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 查看组权限（cat /etc/group）// useradd 添加用户// useradd -g 组名 用户名// useradd -g polise p1// 查看用户信息： cat /etc/passwd// passwd 用户名 密码// demo：passwd p1 root// 用户名 用户id 用户组id// p1:x:1003:1003::/home/p1:/bin/sh// 更改用户所在组：// usermod -g 新组名 用户名// demo：usermod -g tufei p2// ls -ahl 查看文件所有者// 更改文件所有者// chown 用户名 文件名// 更改文件所在组// chgrp 组名 文件名// chmod 权限 文件名 ：chmod 777 文件名// logout登出 EXIT;// vi （cat 只可查看）// 可读权限：r-4// 可写权限：w-2// 可执行权限： x-1// 当前用户-所在组-其它组：rwx-rwx-rwx// 创建多个空文件夹：mkdir a b c// 删除多个空文件夹：rmdir a b c// sudo -i ubuntu切换root用户// cd / 切换根目录// cd ~切换当前用户的根目录 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/Linux学习笔记！/]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp调用phpqrcode类生成二维码！]]></title>
    <url>%2F2016%2F05%2F16%2FThinkPHP%E8%B0%83%E7%94%A8phpqrcode%E7%B1%BB%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[######phpqrcode下载地址：http://phpqrcode.sourceforge.net/ 下载解压放入Thinkphp框架Library/Vendor目录下，如图： 在项目function.php加个方法，如下图文件：方法代码：123456789/** * 生成二维码 * @param string $url url连接 * @param integer $size 尺寸 纯数字 */function qrcode($url,$size=4)&#123; Vendor(&apos;Phpqrcode.phpqrcode&apos;); QRcode::png($url,false,QR_ECLEVEL_L,$size,2,false,0xFFFFFF,0x000000);&#125; 然后项目中就可以直接调用qrcode($url,$size)函数；第一个参数传链接；第二个参数传大小：1qrcode($url=&quot;http://www.baidu.com&quot;,$size=4); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/ThinkPHP调用phpqrcode类生成二维码！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
        <tag>phpqrcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML学习笔记！]]></title>
    <url>%2F2016%2F05%2F16%2FXML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[第一讲 XML简介和DTDHTML中文名称：超文本标记语言优点：简单缺点：不可扩展作用：显示XMLeXtensible Markup language:可扩展的标记语言解决HTML不可扩展的问题，作用：保存或传输数据，不是用来显示数据的。XML介绍1、基于文本格式的2、标签没有被预定义，需要自定义3、用于保存或传输数据，不是用来显示数据的。4、是元语言（可以通过这门语言开发其他的语言）文档结构1、最上面一行是文档的声明，注意：声明必须放在第一行 2、是一种树形的结构3、必须包含根元素，在根元素中扩展到树叶4、文档有元素、属性、值、注释、实体组成 标签的规则1、至少需要一个元素2、XML标签是区分大小写（HTML不区分大小写）3、不允许空标记存在，所有的标记必须成对4、标签的嵌套要正确5、标签的命名规则：以字母、下划线、冒号开头，后面跟的是字母，数字，下划线、冒号、句号(点)、连字符。中间不能有空格，不能以XML开头。注释 使用工具 数据的分类1、PCDATA（parse character data）:可以解析的字符数据，2、CDATA（character data）字符数据，不会由解析器解析。 注意：CDATA块之中的字符串中不能出现”]]&gt;”。实体实体相当于我们说的常亮， DTD 文档类型定义&lt;!DOCTYPE 根 SYSTEM “验证文档.dtd”&gt;例题（外部DTD）demo3.xml和demo3.dtddtd在XML文件外称为外部dtd1、XML如下 2、DTD如下： 例题（内部DTD）demo4.html dtd文件在XML文件内部称为内部DTD。 例题（空标记）demo5.xml 例题（ANY）demo6.xml 混合元素（demo7.xml） XML 对应的DTD如下： 自定义一般实体1、DTD如下： 2、XML如下： 属性格式：&lt;!ATTLIST 元素名称 属性的名称 数据类型 附加条件&gt; TIP:声明元素的时候，元素的数据类型是PCDATA 属性的时候，属性的数据类型是CDATA属性的声明 例题（属性）XML如下： 对应的DTD是： 定义参数实体参数实体就是在普通实体名字前面加上“%”。 对应的XML是 总结1、XML是可扩展标记语言，用于保存，传输结构化数据。2、XML的文档定义： 第一行必须放文档的声明 按树形结构组织XML元素3、XML中包含：声明、元素、属性、值、实体、注释4、XML最低规范： 1、必须（只能）要一个一个根 2、标签必须是容器标记 3、命名规则：以字母、下划线、冒号开头，后面跟的是字母、数字、下划线、冒号、句号、连字符。5、格式良好和有效 满足最低规范称为格式良好，先满足格式良好，再满足有效，通过DTD来保证文档的有效性。6、DTD分为：内部DTD和外部DTD 内部DTD把规范写在XML文档的内部 外部DTD把规范写在XML文档的外部7、引用外部DTD的方法 SYSTEM:如果DTD和XML在同一台服务器上用SYSTEM PUBLIC:如果引用的网络上的DTD用public。8、通过&lt;!ELEMENT&gt;来声明元素通过&lt;!ATTLIST&gt;来声明属性通过&lt;!ENTITY&gt;声明实体9、表示数量 =1 =0? =0 =110、属性必填 required隐含 implied固定 fixed默认枚举唯一11实体实体的分类 参数实体和一般实体的区别，在一般实体前面加一个%就是参数实体 补充：（W3C是什么）World Wide Web Consortium =&gt; wwwc =&gt; 3wc =&gt; w3c扩展部分引入命名空间 xmlns DTD缺点1、不支持命名空间2、支持的数据类型很少3、DTD不可扩展4、DTD不遵循XML规范DTD的优点简洁schema通过schema来解决DTD的不足Schema的注意事项1、如果一个元素下有子元素或属性，必须把元素和属性放在复杂数据类型的标记()里面2、如果是子元素，必须放在复杂数据类型下的序列标签中（），属性不可以放在序列标签中。例题： XML代码如下： 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/XML学习笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底理解PHP的SESSION机制！]]></title>
    <url>%2F2016%2F05%2F16%2F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3PHP%E7%9A%84SESSION%E6%9C%BA%E5%88%B6%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1.session.save_handler = files * 1. session_start() 1. session_start()是session机制的开始，它有一定概率开启垃圾回收,因为session是存放在文件中， PHP自身的垃圾回收是无效的，SESSION的回收是要删文件的，这个概率是根据php.ini的配置决定的，但是有的系统是 session.gc_probability = 0，这也就是说概率是0，而是通过cron脚本来实现垃圾回收。 session.gc_probability = 1 session.gc_divisor = 1000 session.gc_maxlifetime = 1440//过期时间 默认24分钟 //概率是 session.gc_probability/session.gc_divisor 结果 1/1000, //不建议设置过小，因为session的垃圾回收，是需要检查每个文件是否过期的。 session.save_path = //好像不同的系统默认不一样，有一种设置是 &quot;N;/path&quot; //这是随机分级存储，这个样的话，垃圾回收将不起作用，需要自己写脚本 2. session会判断当前是否有$_COOKIE[session_name()];session_name()返回保存session_id的COOKIE键值， 这个值可以从php.ini找到 session.name = PHPSESSID //默认值PHPSESSID 3. 如果不存在会生成一个session_id,然后把生成的session_id作为COOKIE的值传递到客户端. 相当于执行了下面COOKIE 操作，注意的是，这一步执行了setcookie()操作，COOKIE是在header头中发送的，这之前是不能有输出的，PHP有另外一个函数 session_regenerate_id() 如果使用这个函数，这之前也是不能有输出的。 setcookie(session_name(), session_id(), session.cookie_lifetime,//默认0 session.cookie_path,//默认&apos;/&apos;当前程序跟目录下都有效 session.cookie_domain,//默认为空 ) 4. 如果存在那么session_id = $_COOKIE[session_name]; 然后去session.save_path指定的文件夹里去找名字为&apos;SESS_&apos; . session_id()的文件. 读取文件的内容反序列化，然后放到$_SESSION中 * 2. 为$_SESSION赋值 比如新添加一个值$_SESSION[&apos;test&apos;] = &apos;blah&apos;; 那么这个$_SESSION只会维护在内存中，当脚本执行结束的时候， 用把$_SESSION的值写入到session_id指定的文件夹中，然后关闭相关资源. 这个阶段有可能执行更改session_id的操作，比如销毁一个旧的的session_id，生成一个全新的session_id.一半用在自定义 session操作，角色的转换上，比如Drupal.Drupal的匿名用户有一个SESSION的，当它登录后需要换用新的session_id if (isset($_COOKIE[session_name()])) { setcookie(session_name(), &apos;&apos;, time() - 42000, &apos;/&apos;);//旧session cookie过期 } session_regenerate_id();//这一步会生成新的session_id //session_id()返回的是新的值 3.写入SESSION操作 在脚本结束的时候会执行SESSION写入操作，把$_SESSION中值写入到session_id命名的文件中，可能已经存在， 可能需要创建新的文件。 * 4. 销毁SESSION SESSION发出去的COOKIE一般属于即时COOKIE，保存在内存中，当浏览器关闭后，才会过期，假如需要人为强制过期， 比如 退出登录，而不是关闭浏览器，那么就需要在代码里销毁SESSION，方法有很多， o 1. setcookie(session_name(), session_id(), time() - 8000000, ..);//退出登录前执行 o 2. usset($_SESSION);//这会删除所有的$_SESSION数据，刷新后，有COOKIE传过来，但是没有数据。 o 3. session_destroy();//这个作用更彻底，删除$_SESSION 删除session文件，和session_id 当不关闭浏览器的情况下，再次刷新，2和3都会有COOKIE传过来，但是找不到数据 2.session.save_handler = user 用户自定义session处理机制，更加直观 * session_set_save_handler(&apos;open&apos;, &apos;close&apos;, &apos;read&apos;, &apos;write&apos;, &apos;destroy&apos;, &apos;gc&apos;); 1.session_start(), 执行open($save_path, $session_name)打开session操作句柄 $save_path 在session.save_handler = files的情况下它就是session.save_path，但是如果用户自定的话，这个两个参数都用不上，直接返回TRUE 执行read($id)从中读取数据.//这个参数是自动传递的就是session_id(),可以通过这个值进行操作。 * 2.脚本执行结束 执行write($id, $sess_data) //两个参数，很简单 * 3.假如用户需要session_destroy() 先执行destroy.在执行第2步 一个实际例子： //SESSION初始化的时候调用 function open($save_path, $session_name) { global $sess_save_path; $sess_save_path = $save_path; return(true); } //关闭的时候调用 function close() { return(true); } function read($id) { global $sess_save_path; $sess_file = &quot;$sess_save_path/sess_$id&quot;; return (string) @file_get_contents($sess_file); } //脚本执行结束之前，执行写入操作 function write($id, $sess_data) { echo &quot;sdfsf&quot;; global $sess_save_path; $sess_file = &quot;$sess_save_path/sess_$id&quot;; if ($fp = @fopen($sess_file, &quot;w&quot;)) { $return = fwrite($fp, $sess_data); fclose($fp); return $return; } else { return(false); } } function destroy($id) { global $sess_save_path; $sess_file = &quot;$sess_save_path/sess_$id&quot;; return(@unlink($sess_file)); } function gc($maxlifetime) { global $sess_save_path; foreach (glob(&quot;$sess_save_path/sess_*&quot;) as $filename) { if (filemtime($filename) + $maxlifetime &lt; time()) { @unlink($filename); } } return true; } 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/彻底理解PHP的SESSION机制！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SESSION</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP轻量级框架CI简单学习笔记！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A1%86%E6%9E%B6CI%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[下载CI框架解压拷贝到php环境下www目录，浏览器访问该目录，会生成application项目目录。更改默认控制器在config文件夹下routes.php ,但不建议使用index作为默认控制器，控制器方法名和类名相同，表示是构造方法。1$route[&apos;default_controller&apos;] = &apos;welcome&apos;;//默认控制器 12345678910111213141516171819202122232425262728293031$this-&gt;load-&gt;vars(&apos;key&apos;,&apos;values&apos;); //分配变量至模板$this-&gt;load-&gt;view(&apos;dirName/fileName&apos;); // 模板/文件夹名称/文件名$this-&gt;load-&gt;database();//数据库操作对象$this-&gt;load-&gt;model();//模型操作对象$this-&gt;load-&gt;helper();//帮助类//http://www.cc/index.php/user/index/id/2/name/lily$this-&gt;uri-&gt;segment(1);//获取url参数//1：控制器（user）//2：方法（index）//3：id//4：2//5：name//6：lily//http://www.cc/index.php/user/index/2/lily//get方式参数可以这么传递 /**id:用户id*name:用户名*p:第几页*/ function index($id=0,$name=&apos;&apos;,$p=0)&#123;echo $id.&quot;----&quot;.$name.&quot;----&quot;.$p;&#125;$this-&gt;input-&gt;post(&apos;username&apos;); //获取$_POST$this-&gt;input-&gt;server(&apos;DOCUMENT_ROOT&apos;); //获取$_SERVER 数据库操作config文件夹下database.php配置数据库信息123456789101112131415161718192021222324252627282930313233343536373839404142434445//加载数据库$this-&gt;db-&gt;database();//默认defalut ，可以在配置文件添加其他数据库配置，进行多数据库操作$autoload[&apos;libraries&apos;] = array(&apos;database&apos;);//在autoload.php配置，可以免写$this-&gt;db-&gt;database();$this-&gt;load-&gt;model(&apos;user_model&apos;,&apos;user&apos;);//起别名$this-&gt;user-&gt;getAll();//执行sql操作$sql=&quot;&quot;;$this-&gt;load-&gt;query($sql);$this-&gt;db-&gt;affected_rows(); //受影响行数$this-&gt;db-&gt;insert_id(); //自增id参数绑定$sql = &quot;select * from db_user where username= ?&quot;;$this-&gt;db-&gt;query($sql,$name);//多个？传索引数组表前缀$db[&apos;default&apos;][&apos;dbprefix&apos;] = &apos;db_&apos;;$db[&apos;default&apos;][&apos;swap_pre&apos;] = &apos;db_&apos;; //直接写sql语句用此表前缀//数据插入(表名，关联数组）$this-&gt;db-&gt;insert(&apos;表名&apos;,array(&apos;username&apos;=&gt;&apos;admin&apos;,&apos;password&apos;=&gt;&apos;123456&apos;));//数据更新（表名，新数据，条件）$this-&gt;db-&gt;update(&quot;db_user&quot;,$newData,array(&apos;id&apos;=&gt;1));//数据删除(表名，条件）$this-&gt;db-&gt;delete(&apos;db_user&apos;,array(&apos;id&apos;=&gt;1));//数据库连贯操作$this-&gt;db-&gt;select(&quot;id,username&quot;)-&gt;from(&quot;db_user&quot;)-&gt;where(&quot;id&gt;=1&quot;)-&gt;limit(10,1) //跳过1条取10条-&gt;order_by(&quot;id desc&quot;)-&gt;get();//显示最近一条sql$this-&gt;db-&gt;last_query(); 模板view操作相关12345678910//site_url(‘控制器’/‘方法’)&lt;form action=&quot;&lt;?php echo site_url(&apos;user/add&apos;);?&gt;&quot; method=&apos;post&apos; &gt;......//base_url();//相对于网站项目根目录，index.php同级目录&lt;img src=&apos;&lt;?php echo base_url(); ?&gt;/Upload/submit.png&apos;&gt;&lt;/form&gt; 引用类 123456789101112131415161718192021222324//分页demo $this-&gt;load-&gt;database(); $this-&gt;load-&gt;library(&apos;pagination&apos;);//装载分页类 $this-&gt;load-&gt;helper(&apos;url&apos;); $config[&apos;base_url&apos;] = site_url(&apos;user/index&apos;); $config[&apos;total_rows&apos;] = $this-&gt;db-&gt;count_all_results(&apos;db_article&apos;); $config[&apos;per_page&apos;] = 5; $config[&apos;first_link&apos;] = &quot;首页&quot;; $config[&apos;last_link&apos;] = &quot;尾页&quot;; $config[&apos;next_link&apos;] = &quot;下一页&quot;; $config[&apos;prev_link&apos;] = &quot;上一页&quot;; $config[&apos;uri_segment&apos;] = 3; $this-&gt;pagination-&gt;initialize($config); $offset = intval($this-&gt;uri-&gt;segment(3)); //$sql = &quot;select * from db_article limit $offset,&#123;$config[&apos;per_page&apos;]&#125;&quot;; $data[&apos;links&apos;] = $this-&gt;pagination-&gt;create_links(); $this-&gt;load-&gt;view(&apos;user/index&apos;,$data);//view模板：&lt;?php echo $links;?&gt; session 使用：12345 $this-&gt;load-&gt;library(&apos;session&apos;);$this-&gt;session-&gt;set_userdata(&apos;user&apos;,array(&apos;id&apos;=&gt;1,&apos;name&apos;=&gt;&apos;admin&apos;)); $user = $this-&gt;session-&gt;userdata(&apos;user&apos;);print_R($user); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP轻量级框架CI简单学习笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YII-快速用gii创建一个简单的yii项目！]]></title>
    <url>%2F2016%2F05%2F16%2FYII-%E5%BF%AB%E9%80%9F%E7%94%A8GII%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84yii%E9%A1%B9%E7%9B%AE%EF%BC%81%2F</url>
    <content type="text"><![CDATA[yii提供了强大的命令行工具来快速的创建相关组件和应用。下面就来讲解用yiic工具快速创建yii应用我的web目录在 d:\www下 yiiframework在 D:\www\yii\frameworkwin平台 cd进入 www\yii\framework目录运行cmd命令 1234567891011```C:\Users\******&gt;d: *【切换到D盘】D:\&gt;cd www\yii\frameworkD:\www\yii\framework&gt;yiic webapp../testapp/ *创建一个testapp应用在framework上一级目录【回车】Create a Web application under &apos;D:\www\yii\testapp&apos;? [Yes|No]y *【选择y/yes回车】 mkdir D:/www/yii/testapp mkdir D:/www/yii/testapp/assets mkdir D:/www/yii/testapp/css generate css/bg.gif generatecss/form.css generate css/ie.css generatecss/main.css generatecss/print.css generatecss/screen.css mkdir D:/www/yii/testapp/images generateindex-test.php generate index.php mkdir D:/www/yii/testapp/protected generateprotected/.htaccess mkdir D:/www/yii/testapp/protected/commands mkdir D:/www/yii/testapp/protected/commands/shell mkdir D:/www/yii/testapp/protected/components generateprotected/components/Controller.php generateprotected/components/UserIdentity.php mkdir D:/www/yii/testapp/protected/config generateprotected/config/console.php generateprotected/config/main.php generateprotected/config/test.php mkdir D:/www/yii/testapp/protected/controllers generateprotected/controllers/SiteController.php mkdir D:/www/yii/testapp/protected/data generateprotected/data/schema.mysql.sql generateprotected/data/schema.sqlite.sql generateprotected/data/testdrive.db mkdir D:/www/yii/testapp/protected/extensions mkdir D:/www/yii/testapp/protected/messages mkdir D:/www/yii/testapp/protected/migrations mkdir D:/www/yii/testapp/protected/models generateprotected/models/ContactForm.php generateprotected/models/LoginForm.php mkdir D:/www/yii/testapp/protected/runtime mkdir D:/www/yii/testapp/protected/tests generateprotected/tests/bootstrap.php mkdir D:/www/yii/testapp/protected/tests/fixtures mkdir D:/www/yii/testapp/protected/tests/functional generateprotected/tests/functional/SiteTest.php generateprotected/tests/phpunit.xml mkdir D:/www/yii/testapp/protected/tests/report mkdir D:/www/yii/testapp/protected/tests/unit generateprotected/tests/WebTestCase.php mkdir D:/www/yii/testapp/protected/views mkdir D:/www/yii/testapp/protected/views/layouts generateprotected/views/layouts/column1.php generateprotected/views/layouts/column2.php generateprotected/views/layouts/main.php mkdir D:/www/yii/testapp/protected/views/site generateprotected/views/site/contact.php generateprotected/views/site/error.php generateprotected/views/site/index.php generateprotected/views/site/login.php mkdir D:/www/yii/testapp/protected/views/site/pages generateprotected/views/site/pages/about.php generateprotected/yiic generateprotected/yiic.bat generateprotected/yiic.php mkdir D:/www/yii/testapp/themes mkdir D:/www/yii/testapp/themes/classic mkdir D:/www/yii/testapp/themes/classic/views generatethemes/classic/views/.htaccess mkdir D:/www/yii/testapp/themes/classic/views/layouts mkdir D:/www/yii/testapp/themes/classic/views/site mkdir D:/www/yii/testapp/themes/classic/views/system Your application has been created successfullyunder ok 到这里yii新应用已经创建成功 用win+wamp的的朋友可能会遇到下面的问题： 在执行yiic webapp命令时，就报以下错误了： ‘“php.exe”’不是内部或外部命令，也不是可运行的程序或批处理文件。 这个事yiic批处理程序找不到php.exe引起的方法一、修改yiic.bat文件打开yii安装目录d：/www/yii/framework/yiic.bat，yiic.bat有记事本打开有如下一行： if “%PHP_COMMAND%” == “” set PHP_COMMAND=php.exe 由于我的WAMP安装时没有将php.exe加入到Windows环境变量中，难怪yiic找不到。这样也只需要将php.exe的绝对路径赋给PHP_COMMAND即可。如在我这环境下是这样设置的： if “%PHP_COMMAND%” == “” setPHP_COMMAND=D:\wamp\php\php.exe 方法二、将php和yii framework 加入环境变量 在我的电脑右键-&gt;属性 确定 完成 *各自根据自己php.exe所在目录设置。 ok yiic创建应用到此结束！~gii的用法：首先config配置文件开启gii模块，设置密码。选择数据库，开启连接，配置完毕，建库建表。通过路由访问gii模块，Model Generator 输入*号，自动生成连接的数据库下所有表的模型操作类。 把刚生成的model类通过 Crud Generator 生成controller和view下的文件。如果不写表前缀table prefix 生成的model文件，会有表前缀。填上之后，生成的model class会匹配掉表前缀，生成简化的模型名称。table name 一定要写表前缀，否则扫描不到数据表。Modules模块生成demo：输入APP，会在protected文件夹生成modeules/APP文件夹。模块生成后，用gii配置，需要在main.php 文件 modules添加如下代码： &apos;modules&apos;=&gt;array( // uncomment the following to enable the Gii tool &apos;gii&apos;=&gt;array( &apos;class&apos;=&gt;&apos;system.gii.GiiModule&apos;, &apos;password&apos;=&gt;&apos;a&apos;, // If removed, Gii defaults to localhost only. Edit carefully to taste. &apos;ipFilters&apos;=&gt;array(&apos;127.0.0.1&apos;,&apos;::1&apos;), ), &apos;Home&apos;=&gt;array( &apos;class&apos;=&gt;&apos;application.modules.Home.HomeModule&apos;, ), &apos;Admin&apos;=&gt;array( &apos;class&apos;=&gt;&apos;application.modules.Admin.AdminModule&apos;, ), &apos;App&apos;=&gt;array( &apos;class&apos;=&gt;&apos;application.modules.App.AppModule&apos;, ), ), 生成的模块在项目下protected/modules下。model模型公用。curd生成时，model class可以和前面相同，但controller id 要指定module路径。 然后在前台只设读的权限(在控制器文件中把 public $layout=’//layouts/column2’; column2改成column1),调用布局文件（protected\views\layouts\column1.php） 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/YII-快速用GII创建一个简单的yii项目！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>YII</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KindEditor-4-x在PHP中的应用实例！]]></title>
    <url>%2F2016%2F05%2F16%2FKindEditor-4-x%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%81%2F</url>
    <content type="text"><![CDATA[KindEditor 4.x 文档：http://kindeditor.net/doc.php案例：http://kindeditor.net/ke4/examples/demo：http://kindeditor.net/demo.php最新源代码下载解压：Github: https://github.com/kindsoft/kindeditor 1.解压放入php项目静态资源文件夹，如下图： 2.如果只是php使用，可以删除其它类型语言的文件夹，文件结构如下图： 3.打开php文件夹，更改upload_json.php里文件上传目录文件夹至Uploads，修改上传文件大小限制。如下图： 4.然后效果图如下： firebug审查提交数据，经测试可以正常获取使用KindEditor4.x获取图片实时上传和textarea内容！ 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748封面图：&lt;input type=&quot;button&quot; id=&quot;image&quot; value=&quot;选择封面图&quot; class=&quot;btn&quot; /&gt;&lt;input type=&quot;hidden&quot; id=&quot;url&quot; name=&quot;article[image]&quot; value=&quot;&lt;&#123;$article.image&#125;&gt;&quot; class=&quot;input&quot; size=&quot;15&quot; /&gt;//图片数据&lt;p id = &quot;image_show&quot;&gt;&lt;&#123;$article.image&#125;&gt;&lt;/p&gt;//实时显示图片内容：&lt;textarea name=&quot;article[contents]&quot; id=&quot;contents&quot; &gt;&lt;&#123;$article.contents&#125;&gt;&lt;/textarea&gt;//文本域内容 //引入jquery文件&lt;script src=&quot;__PUBLIC__/kindeditor/kindeditor-all.js&quot;&gt;&lt;/script&gt; &lt;script charset=&quot;utf-8&quot; src=&quot;__PUBLIC__/kindeditor/lang/zh-CN.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; KindEditor.ready(function(K) &#123; //textarea editor = K.create(&apos;#contents&apos;, &#123; //themeType: &apos;simple&apos;, resizeType : 1, allowImageRemote : true, width : &apos;60%&apos;, height : &apos;40%&apos;, uploadJson: &apos;__PUBLIC__/kindeditor/php/upload_json.php&apos;, fileManagerJson: &apos;__PUBLIC__/kindeditor/php/file_manager_json.php&apos;, //items : [&apos;source&apos;,&apos;bold&apos;,&apos;italic&apos;,&apos;underline&apos;,&apos;forecolor&apos;,&apos;image&apos;], afterCreate: function()&#123;this.sync();&#125;, //此行可不写，不影响获取textarea的值 afterBlur : function()&#123;this.sync();&#125;//需要添加的 &#125;); //封面图实时上传 K(&apos;#image&apos;).click(function() &#123; editor.loadPlugin(&apos;image&apos;, function() &#123; editor.plugin.imageDialog(&#123; imageUrl : K(&apos;#url&apos;).val(), clickFn : function(url, title, width, height, border, align) &#123; K(&apos;#url&apos;).val(url); K(&quot;#image_show&quot;).html(&apos;![](&apos;+url+&apos;)&apos;); editor.hideDialog(); &#125; &#125;); &#125;); &#125;); &#125;); 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/KindEditor-4-x在PHP中的应用实例！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>KindEditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-Yii框架相关知识笔记-！]]></title>
    <url>%2F2016%2F05%2F16%2FPHP-YII%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-%EF%BC%81%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920Yii框架里数据库操作一、查询数据集合$admin=Admin::model()-&gt;findAll($condition,$params); 该方法是根据一个条件查询一个集合，如： findAll(&quot;username=:name&quot;,array(&quot;:name&quot;=&gt;$username)); $admin=Admin::model()-&gt;findAllByPk($postIDs,$condition,$params); findAllByPk($id,&quot;name like &apos;:name&apos; and age=:age&quot;,array(&apos;:name&apos;=&gt;$name,&apos;age&apos;=&gt;$age)); 该方法是根据主键查询一个集合，可以使用多个主键,如： findAllByPk(array(1,2)); $admin=Admin::model()-&gt;findAllByAttributes($attributes,$condition,$params); 该方法是根据条件查询一个集合，可以是多个条件，把条件放到数组里面，如： findAllByAttributes(array(&apos;username&apos;=&gt;&apos;admin&apos;)); $admin=Admin::model()-&gt;findAllBySql($sql,$params); 该方法是根据SQL语句查询一个数组,如： findAllBySql(&quot;select *from admin whereusername=:name&quot;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); 123456789101112131415161718二、查询对像的方法 $admin=Admin::model()-&gt;findByPk($postID,$condition,$params); 根据主键查询出一个对象,如：findByPk(1); $row=Admin::model()-&gt;find($condition,$params); 根据一个条件查询出一组数据，可能是多个，但是他只返回第一行数据,如： find(&apos;username=:name&apos;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); 3、$admin=Admin::model()-&gt;findByAttributes($attributes,$condition,$params); 该方法是根据条件查询一组数据，可以是多个条件，把条件放到数组里面，他查询的也是第一条数据，如： findByAttributes(array(&apos;username&apos;=&gt;&apos;admin&apos;)); 4、$admin=Admin::model()-&gt;findBySql($sql,$params); 该方法是根据SQL语句查询一组数据,他查询的也是第一条数据，如： findBySql(&quot;select *from admin whereusername=:name&quot;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); 5、拼一个获得SQL的方法，在根据find查询出一个对象 $criteria=new CDbCriteria; $criteria-&gt;select=&apos;username&apos;; // only select the &apos;title&apos; column $criteria-&gt;condition=&apos;username=:username&apos;; $criteria-&gt;params=array(&apos;:username=&gt;&apos;admin&apos;); $post=Post::model()-&gt;find($criteria); // $params isnot needed 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162三、查询个数，判断查询是否有结果 1、$n=Post::model()-&gt;count($condition,$params); 该方法是根据一个条件查询一个集合有多少条记录，返回一个int型数字,如 count(&quot;username=:name&quot;,array(&quot;:name&quot;=&gt;$username)); 2、$n=Post::model()-&gt;countBySql($sql,$params); 该方法是根据SQL语句查询一个集合有多少条记录，返回一个int型数字,如 countBySql(&quot;select *from admin whereusername=:name&quot;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); 3、$exists=Post::model()-&gt;exists($condition,$params); 该方法是根据一个条件查询查询得到的数组有没有数据，如果有数据返回一个true，否则没有找到 四、添加的方法 $admin=newAdmin; $admin-&gt;username=$username; $admin-&gt;password=$password; if($admin-&gt;save()&gt;0)&#123; echo &quot;添加成功&quot;; &#125;else&#123; echo &quot;添加失败&quot;; &#125; 五、修改的方法 1、Post::model()-&gt;updateAll($attributes,$condition,$params); $count =Admin::model()-&gt;updateAll(array(&apos;username&apos;=&gt;&apos;11111&apos;,&apos;password&apos;=&gt;&apos;11111&apos;),&apos;password=:pass&apos;,array(&apos;:pass&apos;=&gt;&apos;1111a1&apos;)); if($count&gt;0)&#123; echo &quot;修改成功&quot;; &#125;else&#123; echo &quot;修改失败&quot;; &#125; 2、Post::model()-&gt;updateByPk($pk,$attributes,$condition,$params); $count =Admin::model()-&gt;updateByPk(1,array(&apos;username&apos;=&gt;&apos;admin&apos;,&apos;password&apos;=&gt;&apos;admin&apos;)); $count =Admin::model()-&gt;updateByPk(array(1,2),array(&apos;username&apos;=&gt;&apos;admin&apos;,&apos;password&apos;=&gt;&apos;admin&apos;),&apos;username=:name&apos;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); if($count&gt;0)&#123; echo &quot;修改成功&quot;; &#125;else&#123; echo &quot;修改失败&quot;; &#125; $pk代表主键，可以是一个也可以是一个集合，$attributes代表是要修改的字段的集合，$condition代表条件，$params传入的值 3、Post::model()-&gt;updateCounters($counters,$condition,$params); $count=Admin::model()-&gt;updateCounters(array(&apos;status&apos;=&gt;1),&apos;username=:name&apos;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); if($count&gt;0)&#123; echo &quot;修改成功&quot;; &#125;else&#123; echo &quot;修改失败&quot;; &#125; array(&apos;status&apos;=&gt;1)代表数据库中的admin表根据条件username=&apos;admin&apos;，查询出的所有结果status字段都自加1 六、删除的方法 1、Post::model()-&gt;deleteAll($condition,$params); $count = Admin::model()-&gt;deleteAll(&apos;username=:nameandpassword=:pass&apos;,array(&apos;:name&apos;=&gt;&apos;admin&apos;,&apos;:pass&apos;=&gt;&apos;admin&apos;)); $id=1,2,3 deleteAll(&apos;id in(&quot;.$id.&quot;)&apos;);删除id为这些的数据 if($count&gt;0)&#123; echo &quot;删除成功&quot;; &#125;else&#123; echo &quot;删除失败&quot;; &#125; 2、Post::model()-&gt;deleteByPk($pk,$condition,$params); $count = Admin::model()-&gt;deleteByPk(1); $count =Admin::model()-&gt;deleteByPk(array(1,2),&apos;username=:name&apos;,array(&apos;:name&apos;=&gt;&apos;admin&apos;)); if($count&gt;0)&#123; echo &quot;删除成功&quot;; &#125;else&#123; echo &quot;删除失败&quot;; &#125; 参考网址http://www.yiieye.com/book_cn/chapter17.htmlhttp://www.yiiframework.com/doc/cookbook/http://www.yiiframework.com/doc/guide/zh_cn/form.viewhttp://www.yiiframework.com/doc/api/CBaseController protected/controllers/sitecontroller.php 控制文件protected/components/UserIdentity.php 用户认证protected/models/LoginForm.php 表单文件 相当于逻辑层，进行权限控制 数据的判断等protected/views/site/login.php 模版文件 修改已有登陆登出框流程 在siteController.php actionLogin() actionLogout() 模版 view/site/login.php //这样给form增加其他属性 123 &lt;?php echo CHtml::beginForm(&apos;&apos;,$method=&apos;post&apos;,array(&quot;id&quot;=&gt;&quot;signupForm&quot;)); ?&gt; ``` //给其他文本组件增加属性 &lt;?php echo CHtml::activeTextField($form,’username’,array(“class”=&gt;”required”,”minlength”=&gt;”3”)) ?&gt; 123. 登陆要填写的内容表单 models/LoginForm.php 与之相关的文件是 componets/userIdentity.php 这里进行取库和用户名的认证$user=PROFILE::model()-&gt;find(‘LOWER(EMAIL)=?’,array(strtolower($this-&gt;username))); 12345678910114. 主模版文件 views/layout/main.php -------------------------------------------------------------------------------------------------单个文件展开分析说明: sitecontroller.php-------------------------------------------------------------------------------------------------1. 存取数据库方法 http://www.yiieye.com/book_cn/chapter21.html 存储第一种（SAVE ） 存表时候用到 例子：$post=new Post;$post-&gt;title=’sample post’;$post-&gt;content=’content for the sample post’;$post-&gt;createTime=time();/$post-&gt;createTime=new CDbexpression_r(‘NOW()’);$post-&gt;save(); $user_field_data= new user_field_data;$user_field_data-&gt;flag=0;$user_field_data-&gt;user_id=$profile-&gt;id;$user_field_data-&gt;field_id=$_POST[‘emailhiden’];$user_field_data-&gt;value1=$_POST[‘email’];$user_field_data-&gt;save(); 1234567注：当一个表存储4次的时候，需要创建4个handle new4次存储第二种（存储） 存储后我们需要找到这条记录的流水id 这样做 $profile = new profile; $profile-&gt;id;存储第三种 用于更加安全的方法，来绑定变量类型 这样可以在同一个表中存储两个记录 $sql=”insert into user_field_data(user_id,field_id,flag,value1) values(:user_id,:field_id,:flag,:value1);”; $command=user_field_data::model()-&gt;dbConnection-&gt;createCommand($sql); $command-&gt;bindParam(“:user_id”,$profile-&gt;id,PDO::PARAM_INT); $command-&gt;bindParam(“:field_id”,$_POST[‘firstnamehiden’],PDO::PARAM_INT); $command-&gt;bindParam(“:flag”,$tmpflag,PDO::PARAM_INT); $command-&gt;bindParam(“:value1”,$_POST[‘firstname’],PDO::PARAM_STR); $command-&gt;execute(); $command-&gt;bindParam(“:user_id”,$profile-&gt;id,PDO::PARAM_INT); $command-&gt;bindParam(“:field_id”,$_POST[‘emailhiden’],PDO::PARAM_INT); $command-&gt;bindParam(“:flag”,$tmpflag,PDO::PARAM_INT); $command-&gt;bindParam(“:value1”,$_POST[‘email’],PDO::PARAM_STR); $rowchange = $command-&gt;execute(); // 用来判断 if( $rowchange != 0){ 修改成功 } 注：update delete都可以用这个方法 $sql=”delete from profile where id=:id”; $command=profile::model()-&gt;dbConnection-&gt;createCommand($sql); $command-&gt;bindParam(“:id”,$userid,PDO::PARAM_INT); $this-&gt;rowflag=$command-&gt;execute(); $sql=”update profile set pass=:pass,role=:role where id=:id”; $command=profile::model()-&gt;dbConnection-&gt;createCommand($sql); $command-&gt;bindParam(“:pass”,$password,PDO::PARAM_STR); $command-&gt;bindParam(“:role”,$role,PDO::PARAM_INT); $command-&gt;bindParam(“:id”,$userid,PDO::PARAM_INT); $this-&gt;rowflag=$command-&gt;execute(); // 同理变更updateAll()模式 $sql=”update user_field_data set flag = :flag where user_id= :user_id and field_id= :field_id “; //原始sql语句 $criteria = new CDbCriteria; $criteria-&gt;condition = ‘user_id = :user_id and field_id= :field_id’; $criteria-&gt;params = array(‘:user_id’ =&gt; $userid,’:field_id’ =&gt; $fieldid); $arrupdate = array(‘flag’ =&gt; $flag); if(user_field_data::model()-&gt;updateAll($arrupdate,$criteria) != 0) { 更新成功后。。。 } 1234第四种更新和存储应用同一个handle 流程：先查询记录是否存在，若存在就更新，不存在就新创建 注：1.第一次查询的变量，要跟save()前的变量一致。 2.存储时候需要再次 new一下库对象 $user_field_data = user_field_data::model()-&gt;findByAttributes( $attributes = array(&apos;user_id&apos; =&gt; Yii::app()-&gt;user-&gt;user_id, &apos;field_id&apos; =&gt; $key)); if ($user_field_data !== null) { $user_field_data-&gt;value1 = $value; $user_field_data-&gt;save(); } else { $user_field_data = new user_field_data; $user_field_data-&gt;user_id = Yii::app()-&gt;user-&gt;user_id; $user_field_data-&gt;field_id = $key; $user_field_data-&gt;value1 = $value; $user_field_data-&gt;save(); } 2、查询数据注：当项目没查找到整个对象会为空需要这样判定 if($rows !== null) 当对象不为空 { return true; }else{ return false; } 12SELECT读表时候用到 第一种find() // find the first row satisfying the specified condition $post=Post::model()-&gt;find($condition,$params); // find the row with postID=10 $post=Post::model()-&gt;find(‘postID=:postID’, array(‘:postID’=&gt;10)); 同样的语句，用另种方式表示 $criteria=new CDbCriteria; $criteria-&gt;select=’title’; // only select the ‘title’ column $criteria-&gt;condition=’postID=:postID’; $criteria-&gt;params=array(‘:postID’=&gt;10); $post=Post::model()-&gt;find($criteria); // $params is not needed 第二种 find() $post=Post::model()-&gt;find(array( ‘select’=&gt;’title’, ‘condition’=&gt;’postID=:postID’, ‘params’=&gt;array(‘:postID’=&gt;10), )); // find the row with the specified primary key $post=Post::model()-&gt;findByPk($postID,$condition,$params); // find the row with the specified attribute values $post=Post::model()-&gt;findByAttributes($attributes,$condition,$params); 示例：第一种 findByAttributes() $checkuser = user_field_data::model()-&gt;findByAttributes( array(‘user_id’ =&gt; Yii::app()-&gt;user-&gt;user_id, ‘field_id’ =&gt; $fieldid)); 第二种 findByAttributes() $checkuser = user_field_data::model()-&gt;findByAttributes( $attributes = array(‘user_id’ =&gt; Yii::app()-&gt;user-&gt;user_id, ‘field_id’ =&gt; $fieldid)); 第三种 当没有conditions时候，不用params $user_field_data = user_field_data::model()-&gt;findAllByAttributes( $attributes = array(‘user_id’ =&gt; ‘:user_id’), $condition = “field_id in (:fields)”, $params = array(‘:user_id’ =&gt; Yii::app()-&gt;user-&gt;user_id, ‘:fields’ =&gt; “$rule-&gt;dep_fields”)); // find the first row using the specified SQL statement $post=Post::model()-&gt;findBySql($sql,$params); 例子 user_field_data::model()-&gt;findBySql(“select id from user_field_data where user_id = :user_id and field_id = :field_id “, array(‘:user_id’ =&gt; $userid,’:field_id’=&gt;$fieldid)); 此时回传的是一个对象 第四种 添加其他条件 http://www.yiiframework.com/doc/api/CDbCriteria#limit-detail $criteria = new CDbCriteria; $criteria-&gt;select =’newtime’; //选择只显示哪几个字段要与库中名字相同，但是不能COUNT(newtime) as name这样写 $criteria-&gt;join = ‘LEFT JOIN Post ON Post.id=Date.id’; 1. 先要在relation函数中增加与Post表的关系语句 2. Date::model()-&gt;with(&apos;post&apos;)-&gt;findAll($criteria) $criteria-&gt;group = &apos;newtime&apos;; $criteria-&gt;limit = 2; // 都是从0开始，选取几个 $criteria-&gt; offset = 2;// 从哪个偏移量开始 print_r(Date::model()-&gt;findAll($criteria)); 得到行数目或者其他数目 count // get the number of rows satisfying the specified condition $n=Post::model()-&gt;count($condition,$params); // get the number of rows using the specified SQL statement $n=Post::model()-&gt;countBySql($sql,$params); // check if there is at least a row satisfying the specified condition $exists=Post::model()-&gt;exists($condition,$params); 123、更新（UPDATE）例子： $post=Post::model()-&gt;findByPk(10); $post-&gt;title=’new post title’; $post-&gt;save(); // save the change to database // update the rows matching the specified condition Post::model()-&gt;updateAll($attributes,$condition,$params); 例子：或者参考上面例子 $c=new CDbCriteria; $c-&gt;condition=’something=1’; $c-&gt;limit=10; $a=array(‘name’=&gt;’NewName’); Post::model()-&gt;updateAll($a, $c); // update the rows matching the specified condition and primary key(s) Post::model()-&gt;updateByPk($pk,$attributes,$condition,$params); 例子 $profile = profile::model()-&gt;updateByPk( Yii::app()-&gt;user-&gt;user_id, $attributes = array(‘pass’ =&gt; md5($_POST[‘password’]), ‘role’ =&gt; 1)); // update counter columns in the rows satisfying the specified conditions Post::model()-&gt;updateCounters($counters,$condition,$params); 124、删除（DELETE）例子： $post=Post::model()-&gt;findByPk(10); // assuming there is a post whose ID is 10 $post-&gt;delete(); // delete the row from the database table // delete the rows matching the specified condition Post::model()-&gt;deleteAll($condition,$params); // delete the rows matching the specified condition and primary key(s) Post::model()-&gt;deleteByPk($pk,$condition,$params); 1235、比较（COMPARE）目前可以取出的 $allquestion=field::model()-&gt;findAllBySql(“select label from field where step_id = :time1 “, array(‘:time1’ =&gt;1)); $criteria=new CDbCriteria;$criteria-&gt;select=’label,options’;$criteria-&gt;condition=’step_id=:postID’;$criteria-&gt;params=array(‘:postID’=&gt;1);$allquestion=field::model()-&gt;findAll($criteria);$allquestion=field::model()-&gt;find(“”,array(“label”)); 可以与在models文件夹中的 库连接文件relations()函数合用，这样可以联合查询 $criteria=new CDbCriteria; $criteria-&gt;condition=’field.step_id=1’; $this-&gt;_post=field::model()-&gt;with(‘step’)-&gt;findAll($criteria); 这样出来的数组里面包含step表中的值，且这个值的条件为 step.id=field.step_id public function relations() { return array( &apos;step&apos;=&gt;array(self::BELONGS_TO, &apos;step&apos;, &apos;step_id&apos;), ); } 123456---------------------------------------------------------------------------UserIdentity.php--------------------------------------------------------------------------- class UserIdentity extends CUserIdentity&#123;&#125; 进行对数据库的校验密码且复制给$this-&gt;_id=$user-&gt;id; 表示用户状态为登陆 注： 任何登陆的编程都要继承此文件，单独创建文件即使继承的类都一样，但yii是不认可的 $identity=new UserIdentity($forms-&gt;email,&apos;ethos&apos;); $identity-&gt;authenticate(); Yii::app()-&gt;user-&gt;login($identity); 123456---------------------------------------------------------------------------LoginForm.php---------------------------------------------------------------------------这些在models下用来定义文本框符合各种条件 class LoginForm extends CFormModel{ rules() attributeLabels() authenticate() } function rules(){ array(‘username’, ‘email’),//调用js认证 array(‘password’, ‘authenticate’),//调用下一个函数 }1234---------------------------------------------------------------------------login.php--------------------------------------------------------------------------- //这样给form增加其他属性&lt;?php echo CHtml::beginForm(‘’,$method=’post’,array(“id”=&gt;”signupForm”)); ?&gt;//给其他文本组件增加属性触发js函数&lt;?php echo CHtml::activeTextField($form,’username’,array(“class”=&gt;”required”,”minlength”=&gt;”3”)) ?&gt;&lt;?php echo CHtml::submitButton(‘Login’,array (“onclick”=&gt;”testok()”)); ?&gt; //testok() 为js函数&lt;?php echo CHtml::submitButton(‘Login’,array (“onclick”=&gt;”alert(\”sam\”);return false;”)); ?&gt; &lt;?php echo CHtml::activeLabel($post,$post-&gt;label); ?&gt;&lt;?php echo CHtml::activeTextField($post,’label’,array(‘size’=&gt;65,’maxlength’=&gt;128)); ?&gt;&lt;?php echo CHtml::activeTextField($post,’content’,array(‘rows’=&gt;20, ‘cols’=&gt;50)); ?&gt; label或者 content是当前表的列名字这个很重要相当于显示数据对象中的某个属性 可以输出数据库的值&lt;?php foreach($post as $n=&gt;$model): ?&gt;&lt;?php echo CHtml::activeLabel($model,’label’); ?&gt;&lt;?php echo CHtml::textField(‘firstname’,’’,array(“class”=&gt;”required”,”minlength”=&gt;”3”)) ?&gt;&lt;?php endforeach; ?&gt; 注：若需要从数据库传值到input组件需要用CHtml::textField 仅仅是需要录入信息，且后台取得用这个就行 CHtml::textField(‘username’,’’,array(“class”=&gt;”required”,”minlength”=&gt;”3”)); 关于用JQuery验证文本框的改写说明用jquery的validate插件控制文本框输入格式（http://bassistance.de/jquery-plugins/jquery-plugin-validation/）js中要写signupForm 为表单id$().ready(function() {// validate the comment form when it is submitted$(“#commentForm”).validate(); // validate signup form on keyup and submit$(“#signupForm”).validate({ });}); php中要添加 要求此字段的输入要求&lt;?php echo CHtml::activeTextField($form,’username’,array(“class”=&gt;”required”,”minlength”=&gt;”3”)) ?&gt; 注：jquery.validate.js中defaults: {messages: {},groups: {},rules: {},errorClass: “errorjs”, 原来是error现在时errorjs 不然与yii的错误提示冲突 1===================================================================================== 用rule 存数据库http://www.yiiframework.com/doc/guide/database.arr当 数据库的php public function rules() { return array( array(‘email’,’length’,’max’=&gt;40), array(‘pass’,’length’,’max’=&gt;255), array(‘role’, ‘required’), array(‘role, overall_percent, overall_time’, ‘numerical’, ‘integerOnly’=&gt;true), ); } 在controller时候需要在rule的required的时候 都需要赋值。 overall_percent,overall_time遵循 role的原则 $profile = new profile; $profile-&gt;email=$_POST[&apos;email&apos;]; $profile-&gt;firstname=$_POST[&apos;firstname&apos;]; $profile-&gt;role=0; $profile-&gt;overall_time=0; $profile-&gt;overall_percent=0; $zipcode = $this-&gt;zipPlace($_POST[&apos;zipcode&apos;]); echo $zipcode-&gt;state; var_dump($profile-&gt;save()); 注 当一个表存储4次的时候，需要创建4个handle new4次 在登陆验证时候增加额外项给Yii::app()-&gt;user-&gt;lastTime在UserIdentity.php中class UserIdentity extends CUserIdentity{ $this-&gt;setState(‘lastTime’,$user-&gt;lastTime);}前台就可以调用Yii::app()-&gt;user-&gt;lastTime只有这样添加的新值，才能在程序中这样任意重复赋值。默认的值不可，比如Yii::app()-&gt;user-&gt;username Yii::app()-&gt;user-&gt;lastTime=&apos;1&apos;; $form-&gt;validate()如何起作用的说明 StartForm.php中 我们定义了各个文本框的 rules（） 需要在controller中调用， 先声明这个文本框 $forms=new StartForm; // 要把回传函数这些属性给$forms这个对象$forms-&gt;firstname=$_POST[‘firstname’];$forms-&gt;firstname=$_POST[‘email’];$forms-&gt;firstname=$_POST[‘zipcode’];$forms-&gt;firstname=$_POST[‘perstatus’]; //调用php端的文本校验 if($forms-&gt;validate()){ XXXXXX } 同理为LoginForm $form=new LoginForm; if(isset($_POST[‘LoginForm’])) { $form-&gt;attributes=$_POST[‘LoginForm’];//回传函数这些属性给form if($form-&gt;validate()){ } } 当进入到validate的时候我们仍然需要增加逻辑来确认每个文本框需要认证的属性 yii的session可以这样设置 程序中可以这样调用 Yii::app()-&gt;session[$var]=$value； 若main.php定义后 ‘session’ =&gt; array(&apos;class&apos; =&gt; &apos;system.web.CDbHttpSession&apos;, &apos;connectionID&apos; =&gt; &apos;db&apos;, ), 当运行第一次网站时候系统会建立yiisession的表，session自动存储在库的yiisession表内 而库连接可以这样 ‘db’=&gt;array( // ‘connectionString’=&gt;’Your DSN’, ‘connectionString’=&gt;’mysql:host=localhost;dbname=testnewtax’, ‘username’=&gt;’root’, ‘password’=&gt;’adminzhao’, ), 在main.php中 增加参数文件 params.php （这个文件是与main.php平行结构 放到文件夹中）‘params’=&gt;require(dirname(FILE).’/params.php’),在程序里可以这样引用 yii 返回的地址也可以这样写 Yii::app()-&gt;user-&gt;returnUrl = Yii::app()-&gt;getBaseUrl().”/step/show/id/1”;$this-&gt;redirect(Yii::app()-&gt;user-&gt;returnUrl); $this-&gt;redirect(array(‘step/show’,’id’=&gt;1)); $this-&gt;render(‘index’,array(‘post’=&gt;$questions)); $this-&gt;renderPartial(‘field_show’,array(‘field’=&gt;$field,’key’=&gt;++$key,)); 注意：有的时候$this-&gt;render、$this-&gt;redirect在同一个action中应用，程序会报错原因如下 1.当我们创建新的form的时候 我们应用2中方法， 1》FillForm.php class FillForm extends CFormModel 这样可以把这个表单中每个项目用php进行核查是否符合规则，在FillForm.php public function rules()中创建规则 2》直接在继承数据库表时候创建表单的核查规则 Post.php （post是库中的表）class Post extends CActiveRecord 在Post.php 中 public function rules() 中创建规则 2. 在继承CFormModel类后同一个action中就不能同时出现$this-&gt;render、$this-&gt;redirect，否则会报错 变通办法如下在controller中创建2个action对应一个form public function actionFill() { $form=new FillForm; $this-&gt;render(&apos;fill&apos;,array(&apos;form&apos;=&gt;$form)); } public function actionUpdatePass() { if(isset($_POST[&apos;password&apos;])) { //XXX $this-&gt;redirect(array(&apos;step/show&apos;,&apos;id&apos;=&gt;1)); } else $this-&gt;refresh(); } } 在tpl中设置 &lt;?php echo CHtml::beginForm(&apos;UpdatePass&apos;,$method=&apos;post&apos;,array(&quot;id&quot;=&gt;&quot;fillForm&quot;)); ?&gt; 123456789101112 ----------------------------------------------------------------------------------------弹出窗口 目前有个问题就是弹出的窗口路径是相对于现在的controller的无法调到另外路径下1. 在ptl文件中 输入 &lt;?php echo CHtml::linkButton(&apos;popup&apos;,array (&quot;onclick&quot;=&gt;&quot;startAlert()&quot;)); ?&gt;2. js文件 function startAlert()&#123; window.open(&apos;fillpass&apos;); &#125;3. sitecontroller.php public function actionFillpass()&#123; $this-&gt;render(&apos;fillpass&apos;); &#125;4. 创建fillpass的tpl themes/views/site/fillpass.php--------------------------------------------------------------------------------------------------------------------------------------------------------删除按钮 带确认项--------------------------------------------------------------------------------------------------------------------------------------------------------- 在tpl中&lt;?php echo CHtml::Button(‘cancel’, array (&apos;submit&apos; =&gt; &apos;DeleteUser&apos;, &apos;params&apos; =&gt; &apos;&apos;, &apos;confirm&apos;=&gt;&apos;Are you sure?&apos; ))?&gt; //这样写就可以传送参数用get方法接收$this-&gt;redirect(array(‘category/show’,array(‘id’=&gt;1,’rule_id’=&gt;’1’))); 原始代码&lt;?php echo CHtml::linkButton(‘Logout’,array( ‘submit’=&gt;’’, ‘params’=&gt;array(‘command’=&gt;’logout’),));?&gt; &lt;?php echo CHtml::Button(‘Delete’, array ( ‘submit’ =&gt; $this-&gt;createUrl(‘post/delete’,$this-&gt;getReturnParams()), ‘params’ =&gt; array(‘id’=&gt;123), ‘confirm’=&gt;’Are you sure?’ ))?&gt;1234------------------------------------------------------------------------------------------------------------------------------------------------代码可以先取出用户已经选的选项，再赋值到前台页面中------------------------------------------------------------------------------------------------------------------------------------------------ &lt;?php foreach($options = $tempradio as $key =&gt; $value): ?&gt;&lt;?php if ($field-&gt;value == $key) echo ““,CHtml::radioButton($field-&gt;id, true, array(“class” =&gt; “noborder”, “value” =&gt; $key)),$value,”“; else echo ““,CHtml::radioButton($field-&gt;id, false, array(“class” =&gt; “noborder”, “value” =&gt; $key)),$value,”“;?&gt;&lt;?php endforeach; ?&gt; 123--------------------------------------------------------------------------------------------------------------------------------tpl调用jquery的AJAX-------------------------------------------------------------------------------------------------------------------------------- 1.tpl中 调用js中的函数startAlert() &lt;?php echo CHtml::Button(‘Flag’, array(“id” =&gt; “cbbtn$field-&gt;id”, “name” =&gt; “cbbtn$field-&gt;id”, “onclick” =&gt; “startAlert(‘$field-&gt;id’)”));?&gt;2.js中 function startAlert(id){ $.ajax({ type: “POST”, url: “../../Change”, data: “id=”+id+”&amp;location=Boston”, success: function(msg){ //alert( “Data Saved: “ + msg ); document.getElementById(‘cb_’+id).innerHTML=msg; } }); } 注意：data传递参数是post且格式如下”id=”+id+”&amp;location=Boston” 可以传递N个变量 url ：填写路径是有技巧的 1. 当URL路径 trunk/bo/index.php/category/show/id/1 意义为 在categorycontroller下的 actionshow中 id是参数名 1 为参数值这样时候 AJAX需要写&quot;../../Change&quot; 网上递归两层 2. 当URL路径 trunk/bo/index.php/category/fill 意义为 在categorycontroller下的 actionfill中这样时候 AJAX需要写&quot;Change&quot; 不需要递归 123--------------------------------------------------------------------------------------------------------------------------------------------main.php 里面的内容包括-------------------------------------------------------------------------------------------------------------------------------------------- 1》 params 文件的应用 1.protected/config/main.php 中进入这个文件’params’ =&gt; include(dirname(FILE) . ‘/params.php’) 相当于引入了一些全局静态变量到系统中 实际的操作方法为。在tpl文件中可以引用 Yii::app()-&gt;params[‘TEXT_TYPE’] 2》 http://www.yiiframework.com/doc/guide/zh_cn/topics.url 设置网页上的URL 把带问号的参数?r=site/login，变成/组成的URL opentax/trunk/bo/index.php?r=site/login ====》 opentax/trunk/bo/site/login 1. &apos;components&apos; =&gt; array(这里增加一个数组 &apos;urlManager&apos; =&gt; array( &apos;urlFormat&apos; =&gt; &apos;path&apos;, &apos;showScriptName&apos; =&gt; &apos;false&apos;, &apos;urlSuffix&apos; =&gt; &apos;.html&apos;, //传递参数后会自动添加此后缀名,用于欺骗作用的下标。id/1 ===&gt; id/1.html ), ) 3》 http://www.yiiframework.com/doc/guide/zh_cn/topics.theming 设置新主题 theme 相当于整个网站的新tpl风格 ‘theme’ =&gt; ‘opentax’, 与components数组平行 Yii::app()-&gt;theme-&gt;baseUrl . ‘/images/FileName.gif’ 需要调用theme中的图片时候，可以用此地址 4》 http://www.yiiframework.com/doc/guide/zh_cn/topics.logging 在components中设置，可以用来输出特出的值 ‘log’ =&gt; array( ‘class’ =&gt; ‘CLogRouter’, ‘routes’ =&gt; array( array( ‘class’ =&gt; ‘CFileLogRoute’, ‘levels’ =&gt; ‘error, warning’, ‘class’=&gt;’CWebLogRoute’, //当加上这两句话时候，程序就显示一个关于执行过程的表格易于开发，但是发布时候需要去除，不然影响程序速度(http://www.yiiframework.com/forum/index.php/topic,2004.0.html) ‘levels’=&gt;’trace’, //当加上这两句话时候，程序就显示一个关于执行过程的表格易于开发，但是发布时候需要去除，不然影响程序速度 ), ), ), 5》 增加数据库的连接文件 ‘db’=&gt;array( ‘class’=&gt;’CDbConnection’, ‘connectionString’=&gt;’mysql:host=localhost;dbname=ox’, ‘username’=&gt;’root’, ‘password’=&gt;’’, ), 6》 http://www.yiiframework.com/doc/guide/zh_cn/topics.prado 模版引擎 在components中添加 ‘viewRenderer’=&gt;array( ‘class’=&gt;’CPradoViewRenderer’, ), 7》 http://www.yiiframework.com/doc/guide/zh_cn/topics.security 安全性 1.CSRF 保护。在form中添加一个cookie，当提交时候服务器会认证这个值，若相同表示为可信任的表单及其传的值 components中加入 ‘request’=&gt;array( ‘enableCsrfValidation’=&gt;true, ), 且建立表单时候一定用CHtml::form。这种格式，其他格式都不能被保护 2.XSS 保护 &lt;?php $this-&gt;beginWidget(‘CHtmlPurifier’); ?&gt; …display user-entered content here… &lt;?php $this-&gt;endWidget(); ?&gt; 3.Cookie 保护 components中加入 ‘request’=&gt;array( ‘enableCookieValidation’=&gt;true, ), 用时候这样调用和赋值 $cookie=Yii::app()-&gt;request-&gt;cookies[$name]; $value=$cookie-&gt;value; // send a cookie $cookie=new CHttpCookie($name,$value); Yii::app()-&gt;request-&gt;cookies[$name]=$cookie; 8》http://www.yiiframework.com/doc/guide/zh_cn/topics.performance 提高性能 1.应用php的APC(Alternative PHP Cache)。参考http://www.php.net/manual/en/book.apc.php return array( ‘components’=&gt;array( ‘cache’=&gt;array(‘class’=&gt;’CDbCache’), ‘cache2’=&gt;array(‘class’=&gt;’CMemCache’), ), ); 然后通过Yii::app()-&gt;cache和Yii::app()-&gt;cache2来访问。 2.关闭YII_DEBUG 设置为false 3. Active Record用这个调用库文件也可以应用到缓存技术 4. 可以用$cs=Yii::app()-&gt;clientScript;来合并许多的js文件 5. 可以引用google的jquery来代替自身的echo CGoogleApi::bootstrap(); CGoogleApi::load 当用yii自带的BUTTON调用自己的JQuery.yii.js时候会与Jquery.validate.js冲突 这样调用Button 就yii自己生成了 JQuery.yii.js，会产生冲突。文本框验证不了&lt;?php echo CHtml::Button(‘cancel’, array (‘submit’ =&gt; Yii::app()-&gt;request-&gt;baseUrl . ‘/category/DeleteUser’,‘params’ =&gt; ‘’,‘confirm’ =&gt; ‘Are you sure?’)) ?&gt; 解决：需要避开带参数的button&lt;?php echo CHtml::Button(‘cancel’,array(“onclick”=&gt;”deleteuser(‘“.Yii::app()-&gt;request-&gt;baseUrl . ‘/category/DeleteUser’.”‘)”));?&gt;让它去调用js函数deleteuser()且把相对路径传给他。让js去提交表单和询问 js如下：function deleteuser(url){if(confirm(‘are you sure?’)){ document.getElementById(‘fillForm’).action=url; document.getElementById(‘fillForm’).submit();}} yii controller中需要load某些文件的操作方法 /protected/config/main.php 中 是纵览哪些文件是可以load进来的 // autoloading model and component classes‘import’ =&gt; array(‘application.models.‘,‘application.components.‘, ‘application.classes.*’,), controller之间的action不能相互调用且controller之间也不能相互引用需要公共的函数可以写到这些文件中只要建立一个class就可以解决方法在公共函数中进行回传一个变量或者全局变量，用变量进行判断 YII 的 JQUERY 的json 运用方法 php中建立数组$chage[‘fieldid’] = $fieldid;$chage[‘butflag’] = 0;echo CJSON::encode($chage); JS文件中输出 var Jsonstr = $.json.decode(msg); 这样就可以取值Jsonstr[‘fieldid’] YII 不用自带的php validate验证功能，自己可以模仿输出 在php中先用数据库查询用户是否存在if($this-&gt;checkEmail($_POST[‘email’])){$error[0] = ‘email already exists’; $er = true; }if($er) // 如果存在返回到首页 { $questions = $this-&gt;loadQuest(); $this-&gt;render(&apos;index&apos;, array( &apos;post&apos; =&gt; $questions, &apos;error_msg_email&apos; =&gt; $error[0], &apos;error_msg_zip&apos; =&gt; $error[1], &apos;firstname&apos; =&gt; $_POST[&apos;firstname&apos;], &apos;email&apos; =&gt; $_POST[&apos;email&apos;], &apos;zipcode&apos; =&gt; $_POST[&apos;zipcode&apos;], &apos;perstatus&apos; =&gt; $_POST[&apos;perstatus&apos;], )); } tpl中 index.tpl if($textname == “email”) { echo CHtml::textField($textname, $value = $$textname, array(“class” =&gt; “required email”, “minlength” =&gt; “3”)); //用css的控制，决定错误提示是否输出及输出的位置 echo &apos;&lt;label class=&quot;errorjs&quot; for=&quot;email&quot; generated=&quot;true&quot; style=&quot;&apos;,($error_msg_email == &apos;&apos;)?&apos;display:none&apos;:&apos;&apos;,&apos;&quot;&gt;&apos;,$error_msg_email,&apos;&lt;/label&gt;&apos;; echo CHtml::hiddenField($textname . “hiden”, $model-&gt;id); } 类的不同调用 当定义类中函数有静态属性时候。加static 的是静态成员,不能用实例化。在你运行的时候他自己在内存中开辟了块空间,不用再一次new, 有点像全局变量class Uti{public static function teOptions($text){}} 外面函数调用时候，用 Uti::teOptions() 这样就可以。但引用变量时候需self::$a,这样的方式 若类中定义为 先实例化(new)一下才能用class Uti{public function texOptions($text){}} 外部调用如下： 类中变量可以$this-&gt;a方式使用 $component = new Uti;$tmpflag = $component -&gt; texOptions(); 解释models文件夹中读取数据库中表的文件。relationship的应用http://www.yiiframework.com/doc/guide/zh_cn/database.arr 表结构如下category (pk) id , namepostcategory (pk,fk1) postID,(pk,fk2)categoryIDpost (pk) id , title,content,createTime,(fk1)authorIDuser (pk) id , username,password emailprofile (pk,fk1) ownerID,photo,website relation结构如下‘VarName’=&gt;array(‘RelationType’, ‘ClassName’, ‘ForeignKey’, …additional options) // author 为自己命名的标志，在查询时候应用 // user和post的关系是一对多，post belongs to user // 外键是 authorID // categories 为自己命名的标志，在查询时候应用 // category和post的关系是多对多，只不过用了一个中间表让之形成一对多，多对一这样的关系。post many_many category // 外键是 postcategory 这个表，它里面有两个字段class Post extends CActiveRecord { public function relations() { return array( ‘author’=&gt;array(self::BELONGS_TO, ‘User’, ‘authorID’), ‘categories’=&gt;array(self::MANY_MANY, ‘Category’, ‘PostCategory(postID, categoryID)’), ); } } // posts 为自己命名的标志，在查询时候应用 // post和user的关系是多对一，user has many post // 外键是 authorID // profile 为自己命名的标志，在查询时候应用 // user和Profile的关系是多对一，user has one Profile 是 has many的变种 // 外键是 ownerIDclass User extends CActiveRecord { public function relations() { return array( ‘posts’=&gt;array(self::HAS_MANY, ‘Post’, ‘authorID’), ‘profile’=&gt;array(self::HAS_ONE, ‘Profile’, ‘ownerID’), ); } } sql程序调用时候//因为没有调用之前定义的author，categories，查询结果不启用关联查询，不会消耗性能$post=Post::model()-&gt;findByPk(10);//当用到with()这个函数时候，它关联了author 所以查询结果中增加user表中的结果$posts=Post::model()-&gt;with(‘author’)-&gt;findAll();//用到了三个命名标志，所以它关联三个表 user ，Category， PostCategory$posts=Post::model()-&gt;with(‘author’,’categories’)-&gt;findAll();//因为有关联到user中的profile 所以目前关联的是 post ，user， category， postcategory，profile$posts=Post::model()-&gt;with(array( ‘author’=&gt;array( ‘profile’, ‘posts’), ‘categories’))-&gt;findAll(); 注意：当不设置relation的时候但仍然要操作left join 之类的操作。方法如下 $sql = “select from date left join post on post.id = date.id”;$temp=Date::model()-&gt;dbConnection-&gt;createCommand($sql)-&gt;queryAll();用 Yii的AR时候不设置relation时候不能操作这样是错误的。他调用了Yii的 CActiveRecord类中的populateRecords方法，它会根据relation中的表字段重新排列一下，所以左连接的内容不会被显示Date::model()-&gt;findBySql(“select from date left join post on post.id = date.id”); View 的应用http://www.yiiframework.com/doc/guide/basics.view 可以用render用来传值到view层$this-&gt;render(‘edit’, array( &apos;var1&apos;=&gt;$value1, &apos;var2&apos;=&gt;$value2, )); 当用这种形式时候 通过调用 renderPartial() 可以不依赖布局而渲染视图. 主文件的tpl在这里protected/views/layouts/main.php可以用这样的形式来定义头和尾文件……header here……&lt;?php echo $content; ?&gt;……footer here…… 应用组件CWidget&lt;?php $this-&gt;beginWidget(‘path.to.WidgetClass’); ?&gt;…body content that may be captured by the widget…&lt;?php $this-&gt;endWidget(); ?&gt; 或者不需要body的组件&lt;?php $this-&gt;widget(‘path.to.WidgetClass’); ?&gt; 也可以通过传递值到组件中&lt;?php$this-&gt;widget(‘CMaskedTextField’,array( ‘mask’=&gt;’99/99/9999’));?&gt; 系统视图当出现404这样的错误时候 protected/views/system 在这里的模版可以列出显示错误页面 Path Alias and Namespace 路径假名 应用YiiBase::getPathOfAlias() 会把system.web.CController 变成真正的物理路径 yii/framework/web/CController 导入文件的方法，这样比include和require高效Yii::import(‘system.web.CController’);这样可以导入一个目录的文件Yii::import(‘system.web.*’); import基于spl_autoload_extensions创建新对象，且比较快http://cn.php.net/spl_autoloadClassA.php&lt;?php class ClassA { var $val = ‘Hello from class “ClassA”‘; } ?&gt;ClassB.php&lt;?php class ClassB { var $val = ‘Hello from class “ClassB”‘; } ?&gt;ClassC.php&lt;?php class ClassC { var $val = ‘Hello from class “ClassC”‘; } ?&gt;ClassD.php&lt;?php class ClassD { var $val = ‘Hello from class “ClassD”‘; } ?&gt;ClassE.php&lt;?php class ClassE { var $val = ‘Hello from class “ClassE”‘; } ?&gt; 1》spl_autoload_extensions(‘.php,.inc’);// new priority: .php .incfor($n=65; $n&lt;70; $n++) { $className = &apos;Class&apos;.chr($n); spl_autoload($className); $ins = new $className; echo $ins-&gt;val.&apos;&lt;br&gt;&apos;; //1.4 miliseconds} 2》 Simple: &lt;?php // default priority: .inc .php for($n=65; $nval.’‘; } // 4.2 miliseconds ?&gt; http://www.yiiframework.com/doc/guide/zh_cn/extension.integration用Yii::import 方法还可以嵌入第三方程序1》我们嵌入zend的Zend_Search_Lucene模块方法如下 首先，假设protected是网站的主目录，我们提取Zend Framework的发布文件到protected/vendors目录。确认protected/vendors/Zend/Search/Lucene.php文件存在 2》在一个controller类文件的开始写入如下语句 Yii::import(&apos;application.vendors.*&apos;); require_once(&apos;Zend/Search/Lucene.php&apos;); 在任何action中可以这样引用了 $lucene=new Zend_Search_Lucene($pathOfIndex); $hits=$lucene-&gt;find(strtolower($keyword)); Conventions 相关协定 URL传统GET传输参数http://hostname/index.php?r=ControllerID/ActionID当用到CUrlManager这个组件时候(相关参考protected/config/main.php)，url变成http://hostname/ControllerID/ActionID.html 在controller文件中 设定默认显示的action public $defaultAction=’login’; 这样就可以显示默认的第一个action了 action 也可以自由定义 跟controller一样http://www.yiiframework.com/doc/guide/zh_cn/basics.controller定义如下：class UpdateAction extends CAction{ public function run() { // place the action logic here }}当在controller中调用此action时候。action类文件为protected/controllers/post/UpdateAction.phpclass PostController extends CController{ public function actions() { return array( &apos;edit&apos;=&gt;&apos;application.controllers.post.UpdateAction&apos;, ); }} public function actions() 单独的这个函数表名执行controller时候需要前期执行某些函数 Filters preprocess/postprocess 都有可能被用到 可以用YII的errorhandler if($this-&gt;_category === null) throw new CHttpException(500, ‘The requested category does not exist.’);``` 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2016/05/16/PHP-YII框架相关知识笔记-！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>YII</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[50个帮你提升自我的网站!]]></title>
    <url>%2F2015%2F12%2F25%2F50%E4%B8%AA%E5%B8%AE%E4%BD%A0%E6%8F%90%E5%8D%87%E8%87%AA%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%81%2F</url>
    <content type="text"><![CDATA[版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2015/12/25/50个帮你提升自我的网站！/]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Jekyll搭建个人博客笔记！]]></title>
    <url>%2F2015%2F12%2F24%2FWindows%E4%B8%8BJekyll%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一、安装 jekyll 要先安装 Ruby &amp; Python： Python下载地址：https://www.python.org/downloads Ruby 下载地址：http://rubyinstaller.org/downloads3.Ruby DevKit 下载地址如上。4.Jekyll 文档地址：http://jekyll.com.cn/docs/deployment-methods 二、验证上面 3 个安装成功与否：1.win + R键然后输入 cmd2.输入 python -v 查看 python 安装版本3.输入 ruby -v 查看 ruby 安装版本4.输入 gem -v 查看 gem 版本5.输入 gem install jekyll 安装 jekyll6.输入 jekyll -v 查看 jekyll 版本 使用命令创建博客： jekyll new blog ###未完待续。。。 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2015/12/24/Windows下Jekyll搭建个人博客笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HEXO</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World !]]></title>
    <url>%2F2015%2F12%2F12%2Fhello-next%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2015/12/12/hello-next/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo在github上搭建个人博客笔记！]]></title>
    <url>%2F2015%2F12%2F12%2F%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[###一、前提需要Git 和 node.js的支持！ #####Windows10 x64位 , github page 部署 hexo #####nodejs官网下载地址：https://nodejs.org/en/ ####Git for Windows下载地址：https://git-for-windows.github.io/ ####Hexo 中文文档：https://hexo.io/zh-cn/docs/commands.html ####Hexo Themes列表：https://hexo.io/themes/ ####next 主題风格配置：http://theme-next.iissnan.com/ ####安装完成后通过查看版本看是否安装成功，git鼠标点击右键会有菜单显示。 ###安装 hexo： #####1.输入命令：npm install -g hexo （-g 是指全局安装 hexo） #####2.查看安装成功与否，输入命令：hexo -v 查看会有版本等信息列出。 ####3.新建项目文件（必须为空，否则会失败），右键运行Git Bash，输入命令：hexo init 会生成如下文件： 输入 hexo s 命令，生成本地服务。然后浏览器输入 ：http://localhost:4000/ 如果不出意外就会出现如下图： #### ####如果无法访问，可能是端口号占用，更改服务端口号：hexo s -p 5000 ###二、 #####申请注册 gitHub 账号，官网地址：https://github.com/ ，登录创建 仓库 ，仓库名必须为（gitHub账号名）.gitHub.io #####例如：我的账号是：DiorsCoder，仓库名创建为： DiorsCoder.gitHub.io #####修改站点配置文件 DiorsCoder.github.io\ _config.yml ####安装 hexo-deployer-git 自动部署发布工具： npm instal lhexo-deployer-git –save ####发布到 gitHub 输入如下命令：hexo clean &amp;&amp; hexo g -d ####不出意外浏览器访问： https://DiorsCoder.github.io 就能看的部署到线上的项目。 ###三、配置 SSH key ssh-keygen -t rsa -C “邮箱地址” 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：1234//生成 key ssh-keygen -t rsa -C &quot;865196792@qq.com&quot;//检测 github 账号的 ssh 是否设置成功ssh -T git@github.com ####配置 git 信息：1234git config --global user.name &quot;DiorsCoder&quot; # github用户名 git config --global user.email &quot;865196792@qq.com&quot; #github注册邮箱git config --list #查看 ###常用命令和报错处理：123456789101112hexo init #执行站点的初始化hexo g == hexo generate #生成静态页面。在生成时可以加上-d或--deploy参数在生成后立即部署。生成的静态文件在public文件夹下，没有则会自动建立。hexo d == hexo deploy #将 .deploy 目录部署到 gitHub,也就是将public目录下生成的静态文件上传到某个特定的位置，部署时可以加上-g或--generate参数，在部署前先生成一遍静态文件。hexo s == hexo server #开启预览访问端口（默认：4000，&apos;ctr+c&apos;关闭server）,在本地http://localhost:4000启动一个hexo服务器，可以用来预览hexo站点的效果。hexo n == hexo new #新建一个markdown文件。hexo new [layout] &lt;title&gt;# [layout]是该文件的类型，取值有post、draft和page三种，分别对应新建文章、草稿、页面。在运行该命令时，会调用scaffolds下的对应模板。hexo clean #清理Hexo缓存。该操作会强制Hexo清空已生成的全部静态文件以及Hexo自身的数据库，有时候相当有效（更换主题后建议运行）。hexo publish &lt;title&gt;#发布某篇草稿（即将该markdown文件转移到_post文件夹下）#命令可以复合使用：hexo clean &amp;&amp; hexo g -d ####hexo new page message：生成菜单项: ####如果部署失败 （报错：Deployer not found: git，输入命令：npm install hexo-deployer-git –save 解决！） ###輸入 hexo d 命令部署失敗，綫上報錯404或者還是原來的樣子！解決辦法，刪除項目根目錄 .deploy_git 文件夾！重新執行命令： hexo d ####如果部署失败,报错（Could not read from remote repository.） #####解决办法：删除当前key，然后重新生成key，执行（三、配置 SSH key） ，然后从新生成部署。 #####提示如下图则说明部署成功： #####浏览器输入：https://dragonersli.github.io/ 就可以看到项目了，然后后面就是各种配置了。 ####卸载Hexo ：3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g。 #####站点部分配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Site #站点信息title: blog Name #标题subtitle: Subtitle #副标题description: my blog desc #描述author: me #作者language: zh-CN #语言timezone: Asia/Shanghai #时区# URLurl: http://yoururl.com #用于绑定域名, 其他的不需要配置root: /#permalink: :year/:month/:day/:title/permalink: posts/title.htmlpermalink_defaults:# Directory #目录source_dir: source #源文件public_dir: public #生成的网页文件tag_dir: tags #标签archive_dir: archives #归档category_dir: categories #分类code_dir: downloads/codei18n_dir: :lang #国际化skip_render:# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认模板(post page photo draft)titlecase: false #标题转换成大写external_link: true #新标签页里打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true line_number: true #显示行号 auto_detect: true tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Date / Time format #日期时间格式## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination #分页per_page: 10 #每页文章数, 设置成 0 禁用分页pagination_dir: page# Extensions #插件和主题## 插件: http://hexo.io/plugins/## 主题: http://hexo.io/themes/theme: next# Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面deploy:- type: git repo: git@github.com:DiorsCoder/DiorsCoder.github.io.git,gitcafe-pages- type: git repo: git@github.com:DiorsCoder/DiorsCoder.github.io.git,mastermessage: &apos;站点更新: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;&apos; # Disqus #Disqus评论系统disqus_shortname: plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap ###四、主题安装： 1234git clone https://github.com/iissnan/hexo-theme-next themes/next #next主题 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #yilia主题 ####经常修改主题配置文件之后，执行 hexo clean &amp;&amp; hexo g -d 命令部署失败，查看错误信息如下： ####主题配置文件问题有可能是空格问题，也有可能是配置问题。 ####next 主题添加网站运行天数和访问量：运行天数：12345678910111213141516 //在最后一个div中追加 &lt;span&gt; | &lt;/span&gt;&lt;span id=&quot;showDays&quot;&gt;&lt;/span&gt;//修改blog\themes\next\layout\_partials\footer.swig文件，在后面追加 &lt;script&gt; var birthDay = new Date(&apos;09/1/2016&apos;); var now = new Date(); var duration = now.getTime() - birthDay.getTime(); var total= Math.floor(duration / (1000 * 60 * 60 * 24)); document.getElementById(&apos;showDays&apos;).innerHTML=&apos;本站已运行&apos; + total + &apos;天&apos;;&lt;/script&gt;``` 访客量和访客人数： | 本站总访问量 您是第 个小伙伴 ```添加代码示例： 效果如下： 版权声明： 本文首发于： 李世龙的博客！版权所有，翻版必究！本文永久链接：http://DiorsCoder.github.io/2015/12/12/用hexo在github上搭建个人博客笔记！/]]></content>
      <categories>
        <category>PHP笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>